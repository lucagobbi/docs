{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hello, dear","text":""},{"location":"#hello-dear","title":"\ud83d\udc4b Hello, dear!","text":"<pre><code>\"Every adventure requires a first step\".\n(Alice's Adventures in Wonderland - Lewis Carroll)\n</code></pre>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li> <p>\ud83c\udfc3 Onboarding</p> <p>Take your first step with hands-on examples!</p> <p> Get started now</p> </li> <li> <p>\ud83d\udd0c Plugins</p> <p>Dive into advanced concepts to develop and publish your plugin!</p> <p> Plugin documentation</p> </li> <li> <p>\ud83e\ude9d Hooks</p> <p>Explore all the available hooks to customize the Cat!</p> <p> Available Hooks</p> </li> <li> <p>\ud83d\ude80 Deploy</p> <p>Ready-to-use setup to deploy your assistant!</p> <p> Coming soon...</p> </li> </ul>"},{"location":"#cheshire-cat-features","title":"Cheshire Cat Features","text":"<p>The Cheshire Cat is an open-source, hackable and production-ready framework that allows developing intelligent personal  AI assistant agents on top of Large Language Models (LLM).</p> <ul> <li> <p>\ud83e\uddf0 API first framework</p> <p>Chat with the Cat and interact with its endpoints!</p> <p> Python API</p> </li> <li> <p>\ud83d\ude80 Extendable via plugins in Python</p> <p>Write your first plugin, your imagination is the limit!</p> <p> Write your first plugin</p> </li> <li> <p>\ud83c\udf0d Language model agnostic</p> <p>Easily choose from a plenty of models to use!</p> <p> Tutorials coming soon...</p> </li> <li> <p>\ud83d\udcdc Can ingest documents</p> <p>Ground the model based on your knowledge base!</p> <p> Retrieval Augmented Generation</p> </li> <li> <p>\ud83d\udc18 Local Long term memory</p> <p>Make use of a persistent memory across restarts!</p> <p> Cat's Long Term Memory</p> </li> <li> <p>\ud83d\udc0b 100% dockerized</p> <p>Setup the Cat in the blink of an eye with the pre-built docker image!</p> <p> Installation</p> </li> </ul>"},{"location":"#get-in-touch-with-us","title":"Get in touch with us!","text":"<p> Discord \ud83d\udc48 Join our Discord community where you can connect with other developers and ask for support to the contributors or directly to the Cat \ud83d\ude3a mentioning <code>@Cheshire Cat AI</code>.</p> <p>Remember to give the project a star! \u2b50 and thanks! \ud83d\ude4f</p> <p></p> <pre><code>\"Would you tell me, please, which way I ought to go from here?\"\n\"That depends a good deal on where you want to get to,\" said the Cat.\n\"I don't much care where--\" said Alice.\n\"Then it doesn't matter which way you go,\" said the Cat.\n\n(Alice's Adventures in Wonderland - Lewis Carroll)\n</code></pre> <p>License</p> <p>GNU General Public License v3.0</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#faq","title":"\ud83d\ude4b\u200d\u2642\ufe0f FAQ","text":""},{"location":"faq/#general","title":"General","text":""},{"location":"faq/#ive-found-the-cat-and-i-like-it-very-much-but-im-not-able-to-follow-your-instructions-to-install-it-on-my-machine-can-you-help","title":"I've found the Cat and I like it very much, but I'm not able to follow your instructions to install it on my machine. Can you help?","text":"<p>The Cheshire Cat is a framework to help developers to build vertical AIs: you will need some basic technical skills to follow our instructions. Please try to ask in the support channel in our discord server, and remember this is all volunteers effort: be kind! :)</p>"},{"location":"faq/#why-the-cat-does-not-default-to-some-open-llm-instead-of-chatgpt-or-gpt-3","title":"Why the Cat does not default to some open LLM instead of ChatGPT or GPT-3?","text":"<p>Our intention is not to depend on any specific LLM: the Cat does not have a preference about which LLM to use. Nonetheless, at the moment, OpenAI tools still provide the best results for your bucks. Decision is up to you.</p>"},{"location":"faq/#are-text-and-documents-sent-to-the-cat-safe-and-not-shared-with-anybody","title":"Are text and documents sent to the Cat safe and not shared with anybody?","text":"<p>Well, the local memory is safe and under your control, although embeddings and prompts are shared with your configured LLM, meaning you need to check how safe is the LLM. We plan to adopt local LLMs, at which point all your data will be under your control.</p>"},{"location":"faq/#what-is-the-difference-between-langchain-and-the-cat","title":"What is the difference between Langchain and the Cat?","text":"<p>The Cheshire Cat is a production-ready AI framework, it means that with almost no effort you can setup an intelligent agent ready to help both you and your customers.</p> <p>On the other hand, Langchain is a framework for developing applications powered by language models. It offers tons of composable tools and integrations to this purpose and the Cheshire Cat makes use of some of them to manage chains, agents, llm/embedder. You can take an in depth look at our core if you are purr-ious about it.</p>"},{"location":"faq/#i-want-to-use-the-admin-page-for","title":"I want to use the admin page for...","text":"<p>The admin panel is meant to be an administration interface. It's purpose is to chat with the Cat only to debug/play with it, it is not intended to be a final widget chat used by eventual final users.</p> <p>We provide a widget to connect the Cat to your product.</p> <p>You are free to modify the Admin to adapt it to your product, however you will need to respect the GPL3 Licence, meaning you are free to fork the codebase and go on your own, but you are forced to open source eventual changes.</p>"},{"location":"faq/#why-the-admin-does-not-provide-basic-usernamepassword-or-third-party-authentication-such-as-oauth","title":"Why the Admin does not provide Basic (username/password) or Third-party Authentication (such as OAuth)?","text":"<p>The only use case of the Admin is to provide a more friendly way to interact with the Cat with basic authentication through an  <code>api_key</code>.</p>"},{"location":"faq/#basic-info","title":"Basic Info","text":""},{"location":"faq/#can-i-insert-a-long-article-into-the-chat","title":"Can I insert a long article into the chat?","text":"<p>Please avoid pasting long articles into the chat. Use Rabbit Hole to upload long texts instead: just click on the attachment icon in the chat input widget and upload your file.</p>"},{"location":"faq/#are-the-configured-llm-apis-used-to-instruct-the-cat-with-the-documents-im-going-to-upload","title":"Are the configured LLM APIs used to \"instruct\" the Cat with the documents I'm going to upload?","text":"<p>That's not exactly how it works: basically when you ask something to the Cat, we pass to the configured LLM a prompt with your actual question + data that can be useful to answer that question. Data can be parts of your documents or chat history. Please check our documentation for more details about how the Cat works for you.</p>"},{"location":"faq/#can-i-talk-to-the-cat-in-a-language-different-from-english","title":"Can I talk to the Cat in a language different from English?","text":"<p>Of course, you can: just change the prompts in the Plugin folder accordingly, and take care not to mix languages to get best results.</p>"},{"location":"faq/#how-can-i-know-where-the-cat-gets-the-answers-id-like-to-know-if-its-using-the-files-i-uploaded-or-if-its-querying-the-configured-llm","title":"How can I know where the Cat gets the answers? I'd like to know if it's using the files I uploaded or if it's querying the configured LLM.","text":"<p>Just open the console in your browser to check the logs there. At some point soon, this information will end up in the user interface, but at the moment is behind the scenes.</p>"},{"location":"faq/#i-sent-to-the-cat-some-text-and-documents-i-want-to-get-rid-of-how-can-i-do","title":"I sent to the Cat some text and documents I want to get rid of, How can I do?","text":"<p>You can delete the <code>long_term_memory</code> folder and restart the Cat!</p>"},{"location":"faq/#errors","title":"Errors","text":""},{"location":"faq/#why-am-i-getting-the-error-ratelimiterror-in-my-browser-console","title":"Why am I getting the error <code>RateLimitError</code> in my browser console?","text":"<p>Please check if you have a valid credit card connected or if you have used up all the credits of your OpenAI trial period.</p>"},{"location":"faq/#docker-has-no-permissions-to-write","title":"Docker has no permissions to write","text":"<p>This is a matter with your docker installation or the user you run docker from. Usually you can resolve it by using sudo command before calling any docker command, but it's better to create a <code>docker</code> group on your Linux system and give root-level privileges to docker.</p>"},{"location":"faq/#the-cat-seems-not-to-be-working-from-inside-a-virtual-machine","title":"The Cat seems not to be working from inside a Virtual Machine","text":"<p>In VirtualBox, you can select Settings-&gt;Network, then choose NAT in the \"Attached to\" drop down menu. Select \"Advanced\" to configure the port forwarding rules. Assuming the guest IP of your VM is 10.0.2.15 (the default) and the ports configured in the .env files are the defaults, you have to set at least the following rule:</p> Rule name Protocol Host IP Host Port Guest IP Guest Port Rule 1 TCP 127.0.0.1 1865 10.0.2.15 1865 <p>If you want to work on the documentation of the Cat, you also have to add one rule for port 8000 which is used by <code>mkdocs</code>, and to configure <code>mkdocs</code> itself to respond to all requests (not only localhost as per the default).</p>"},{"location":"faq/#customization","title":"Customization","text":""},{"location":"faq/#i-want-to-build-my-own-plugin-for-the-cat-what-should-i-know-about-licensing","title":"I want to build my own plugin for the Cat: what should I know about licensing?","text":"<p>Plugins are any license you wish, you can also sell them. The Cat core is GPL3, meaning you are free to fork and go on your own, but you are forced to open source changes to the core.</p>"},{"location":"faq/#port-1865-is-not-allowed-by-my-operating-system-andor-firewall","title":"Port 1865 is not allowed by my operating system and/or firewall","text":"<p>Change the port as you wish in the <code>.env</code> file.</p> <pre><code># Decide host and port for your Cat. Default will be localhost:1865\nCORE_HOST=localhost\nCORE_PORT=9000\n</code></pre>"},{"location":"faq/#can-i-use-a-different-vector-database-than-qdrant","title":"Can I use a different vector database than Qdrant?","text":"<p>At the moment, we don't provide any way to switch the vector database \ud83d\ude3f but it is planned for the future.</p>"},{"location":"faq/#security","title":"Security","text":""},{"location":"faq/#where-is-the-openai-api-key-or-other-keys-saved-in-the-cat","title":"Where is the OpenAI API key (or other keys) saved in the Cat?","text":"<p>Keys are store in a JSON file, <code>core/metadata.json</code>.</p>"},{"location":"faq/#will-openai-see-my-documents-and-conversations","title":"Will OpenAI see my documents and conversations?","text":"<p>If you are using the Cat with an OpenAI LLM, all your conversations and documents will indeed take a trip into OpenAI servers, because the models are there. We advise to avoid uploading sensitive documents while using an external LLM. If you want to use the Cat in total security and privacy, use a local LLM or a cloud LLM in your control.</p>"},{"location":"faq/#spending","title":"Spending","text":""},{"location":"faq/#i-have-chatgpt-subscription-can-i-use-the-cat","title":"I have chatgpt subscription, can I use the cat?","text":"<p>Chat-gpt subscription is different from OpenAI API</p>"},{"location":"faq/#is-there-a-free-way-to-use-openai-services","title":"Is there a free way to use OpenAI services?","text":"<p>Unfortunately you need to pay to use OpenAI models, but they are quite cheap.</p>"},{"location":"faq/#can-i-run-local-models-like-llama-to-avoid-spending","title":"Can I run local models like LLAMA to avoid spending?","text":"<p>Running a LLM (Large Language Model) locally requires high-end hardware and technical skills. If you don't know what you are doing, we suggest you start using the Cat with ChatGPT. Afterwards you can experiment with local models or by setting up a cloud endpoint. The Cat offers you several ways to use an LLM.</p>"},{"location":"faq/#can-i-know-in-advance-how-much-money-i-will-spend","title":"Can I know in advance how much money I will spend?","text":"<p>That depends on the vendors pricing, how many documents you upload in the Cat memory and how much you chat. We suggest you start with light usage and small documents, and check how the billing is growing in your LLM vendor's website. In our experience LLM cloud usage is cheap, and it will probably be even cheaper in the next months and years.</p>"},{"location":"faq/#is-my-gpu-powerful-enough-to-run-a-local-model","title":"Is my GPU powerful enough to run a local model?","text":"<p>That strongly depends on the size of the model you want to run. Try using this application from HuggingFace to get an idea of which model and the amount of quantization your hardware can handle. </p>"},{"location":"features/","title":"Features","text":"<p>TODO</p>"},{"location":"made-with-the-cat/","title":"&#128075; Made with the Cat","text":""},{"location":"made-with-the-cat/#made-with-the-cat","title":"\ud83d\udc4b Made with the Cat","text":"<p>If you're curious to see what people have already done with the Cat, visit our dedicated  Discord Channel! </p>"},{"location":"administrators/architecture/","title":"Architecture","text":""},{"location":"administrators/architecture/#architecture","title":"Architecture","text":"<p>The Cheshire Cat framework consists of four components: the Core, the Vector Database, the LLM and the embedder.</p> <p>The Core and the Admin Portal are implemented within the framework, while the Vector Database, the LLM and the embedder are external dependencies.</p> <p>The Core communicates with the Vector Database, the LLM and the embedder, while The Admin Portal communicates with the Core.</p> <p>The Core is implemented in Python, Qdrant is utilized as Vector Database, the Core support different LLMs and Embbeders (see the complete list below), the Admin Portal is implemented using the Vue framework.</p>"},{"location":"administrators/architecture/#core","title":"Core","text":""},{"location":"administrators/architecture/#docker-images","title":"Docker Images","text":"<p>To facilitate, speed up, and standardize the Cat's user experience, the Cat contains configuration for use inside Docker.</p> <p>You can use the pre-compiled images present in the Repo's Docker Registry or build it from scratch:</p> <ol> <li> <p>To use the pre-compiled image, add <code>ghcr.io/cheshire-cat-ai/core:&lt;tag-version&gt;</code> as value of <code>image</code> under the name of the service in the docker-compose:</p> <pre><code>cheshire-cat-core:\n    image: ghcr.io/cheshire-cat-ai/core:1.5.1\n</code></pre> </li> <li> <p>To build it from scratch execute <code>docker compose build</code> in the repo folder just cloned.</p> <p>This will generate two Docker images. The first one contains the Cat Core and Admin Portal. The container name of the core is <code>cheshire_cat_core</code>.</p> </li> </ol> <p>The Cat core path <code>./core</code> is mounted into the image <code>cheshire_cat_core</code>, by default changes to files in this folder force a restart of the Core, this behavior can be disabled using the <code>DEBUG</code> environment variable.</p>"},{"location":"administrators/architecture/#admin-portal","title":"Admin Portal","text":"<p>The Admin Portal connects to the core using <code>localhost</code> through the port exposed when the container was created, this value can be customized using environment variables. This port is the only one exposed by the <code>cheshire_cat_core</code> image.</p>"},{"location":"administrators/architecture/#logging","title":"Logging","text":"<p>All the log messages are printed on the standard output and log level can be configured with <code>LOG_LEVEL</code> environment variables. You can check logging system documentation here.</p>"},{"location":"administrators/architecture/#configuration","title":"Configuration","text":"<p>Some options of the Core can be customized using environment variables.</p>"},{"location":"administrators/architecture/#compatible-models","title":"Compatible Models","text":"<p>The cat is agnostic, meaning You can attach your preferred llm and embedder model/provider. The Cat supports the most used ones, but you can increase the number of models/providers by plugins, here is a list of the main ones:</p> <ol> <li>OpenAI and Azure OpenAI</li> <li>Cohere</li> <li>Ollama (LLM model only)</li> <li>HuggingFace TextInference API (LLM model only)</li> <li>Google Gemini</li> <li>Qdrant FastEmbed (Embedder model only)</li> </ol>"},{"location":"administrators/architecture/#vector-memory","title":"Vector Memory","text":""},{"location":"administrators/architecture/#what-we-use-as-vector-memory","title":"What we use as vector memory?","text":"<p>The Cat provides a connection to qdrant through his Python client. By default the Core tries to connect to a Qdrant database, if the connection fails then it switches to the <code>local Qdrant database</code>. It is highly recommended to connect the Cat to a Qdrant database to increase performance and capacity!</p>"},{"location":"administrators/architecture/#qdrant-cloud-or-self-hosting","title":"Qdrant Cloud or Self Hosting","text":"<p>Qdrant provides to 2 paths:</p> <ol> <li>Self-host Qdrant by using docker, follows an example docker-compose:</li> </ol> <pre><code>version: '3.7'\n\n services:\n cheshire-cat-core:\n     image: ghcr.io/cheshire-cat-ai/core:1.5.1\n     container_name: cheshire_cat_core\n     depends_on:\n         - cheshire-cat-vector-memory\n     environment:\n         - PYTHONUNBUFFERED=1\n         - WATCHFILES_FORCE_POLLING=true\n         - CORE_HOST=${CORE_HOST:-localhost}\n         - CORE_PORT=${CORE_PORT:-1865}\n         - QDRANT_HOST=${QDRANT_HOST:-cheshire_cat_vector_memory}\n         - QDRANT_PORT=${QDRANT_PORT:-6333}\n         - CORE_USE_SECURE_PROTOCOLS=${CORE_USE_SECURE_PROTOCOLS:-}\n         - API_KEY=${API_KEY:-}\n         - LOG_LEVEL=${LOG_LEVEL:-WARNING}\n         - DEBUG=${DEBUG:-true}\n         - SAVE_MEMORY_SNAPSHOTS=${SAVE_MEMORY_SNAPSHOTS:-false}\n     ports:\n         - ${CORE_PORT:-1865}:80\n     volumes:\n         - ./cat/static:/app/cat/static\n         - ./cat/plugins:/app/cat/plugins\n         - ./cat/data:/app/cat/data\n     restart: unless-stopped\n\n cheshire-cat-vector-memory:\n     image: qdrant/qdrant:v1.7.1\n     container_name: cheshire_cat_vector_memory\n     expose:\n         - 6333\n     volumes:\n         - ./cat/long_term_memory/vector:/qdrant/storage\n     restart: unless-stopped\n</code></pre> <ol> <li> <p>Use Qdrant Cloud, by setting <code>QDRANT_HOST</code>, <code>QDRANT_PORT</code> and <code>QDRANT_API_KEY</code> Enviroment Variables. Follows an example of <code>.env</code> file:</p> <pre><code>    # Qdrant server\n    QDRANT_HOST=&lt;url of the cluster&gt;\n    QDRANT_PORT=&lt;port of the cluster, usually 6333&gt;\n    QDRANT_API_KEY=&lt;api-key&gt;\n</code></pre> </li> </ol>"},{"location":"administrators/architecture/#admin-portal_1","title":"Admin Portal","text":""},{"location":"administrators/architecture/#use-case","title":"Use case","text":"<p>The Admin Portal is an administration/debugging panel to interact with the Cat by chatting, uploading files, exploring the memory, changing the LLM and Embedder Models while providing minimal authentication through an <code>api_key</code>.</p>"},{"location":"administrators/env-variables/","title":"Environment Variables","text":""},{"location":"administrators/env-variables/#environment-variables","title":"Environment Variables","text":"<p>The Core can be configured using environment variables, the values are read during Cat bootstrap.</p> <p>To set an environment variable, create a file with name <code>.env</code> at the same level of the <code>docker-compose.yml</code> file. The command <code>docker compose up</code> reads the <code>.env</code> file and sets the environment variable.</p> <p>The root folder contains the <code>.env.example</code>, you can use this file as a reference.</p>"},{"location":"administrators/env-variables/#core_host","title":"CORE_HOST","text":"<p>The host at which the Cat is running. The parameter is used by Admin Portal to determine the host to connect to.</p> <p>Default value: <code>localhost</code></p>"},{"location":"administrators/env-variables/#core_port","title":"CORE_PORT","text":"<p>The port the Cat has to use. The parameter is used by Admin Portal to determine the port to connect to.</p> <p>Default value: <code>1865</code></p>"},{"location":"administrators/env-variables/#core_use_secure_protocols","title":"CORE_USE_SECURE_PROTOCOLS","text":"<p>By default, the core APIs are exposed using the HTTP/WS protocol, set this parameter to <code>true</code> if you expose the API using the HTTPS/WSS protocol, for example using NGIX in front of the Cat. The parameter is read by the Admin Portal to determine the protocol to use.</p> <p>Default value: <code>false</code></p>"},{"location":"administrators/env-variables/#qdrant_host","title":"QDRANT_HOST","text":"<p>The host on which Qdrant is running. Cat provides a ready-to-use Docker image for Qdrant. If you want to use an external instance of Qdrant, use this parameter to specify the host where it is running. You can also optionally specify the protocol to use in the URL to make a secure connection (for example https://example.com).</p> <p>Default value: <code>localhost</code></p>"},{"location":"administrators/env-variables/#qdrant_port","title":"QDRANT_PORT","text":"<p>The port on which Qdrant is running. Cat provides a ready-to-use Docker image for Qdrant. If you want to use an external instance of Qdrant, use this parameter to specify the port where it is running.</p> <p>Default value: <code>6333</code></p>"},{"location":"administrators/env-variables/#qdrant_api_key","title":"QDRANT_API_KEY","text":"<p>This is used to set the Qdrant Api Key in the client connection statement. It should be configured if an Api Key is set up on the Qdrant Server.</p> <p>Default value: <code>[empty]</code></p>"},{"location":"administrators/env-variables/#api_key","title":"API_KEY","text":"<p>By default, the core APIs don't require any authorization, if you set this parameter all endpoints will require an <code>access_token</code> header for authentication such as <code>access_token: your-key-here</code>. Failure to provide the correct access token will result in a 403 error.</p> <p>Multiple keys can be accepted by separating them with a pipe (<code>|</code>) as follows: <code>API_KEY=your-key-here|secondary_client_key</code>.</p> <p>Default value: <code>[empty]</code></p>"},{"location":"administrators/env-variables/#cors_allowed_origins","title":"CORS_ALLOWED_ORIGINS","text":"<p>By default, the core APIs can be consumed from all origins, using the parameter you can specify which origins can consume the APIs.</p> <p>Default value: <code>*</code></p>"},{"location":"administrators/env-variables/#log_level","title":"LOG_LEVEL","text":"<p>The log level, available levels are: - <code>DEBUG</code> - <code>INFO</code> - <code>WARNING</code> - <code>ERROR</code> - <code>CRITICAL</code> </p> <p>Default value: <code>WARNING</code></p>"},{"location":"administrators/env-variables/#metadata_file","title":"METADATA_FILE","text":"<p>The name of the file that contains all the Cat settings.</p> <p>Default value: <code>metadata.json</code></p>"},{"location":"administrators/env-variables/#save_memory_snapshots","title":"SAVE_MEMORY_SNAPSHOTS","text":"<p>Set to <code>false</code> to turn off Vector Database snapshot.</p> <p>Default value: <code>true</code></p>"},{"location":"administrators/env-variables/#debug","title":"DEBUG","text":"<p>By default, changes to files in the root folder of the Cat force a restart of the Core, this useful during the development of Plugins. This behavior can be switch off by setting this parameter to <code>false</code>.</p> <p>Default value: <code>true</code></p>"},{"location":"conceptual/llm/","title":"Language Models","text":""},{"location":"conceptual/llm/#language-models","title":"Language Models","text":"<p>A language model is a Deep Learning Neural Network trained on a huge amount of text data to perform different types of language tasks. Commonly, they are also referred to as Large Language Models (LLM). Language models come in many architectures, size and specializations. The peculiarity of the Cheshire Cat is to be model-agnostic. This means it supports many different language models.</p> <p>By default, there are two classes of language models that tackle two different tasks.</p>"},{"location":"conceptual/llm/#completion-model","title":"Completion Model","text":"<p>This is the most known type of language models (see for examples ChatGPT, Cohere and many others). A completion model takes a string as input and generates a plausible answer by completion.</p> <p>Warning</p> <p>A LLM answer should not be accepted as-is, since LLM are subjected to hallucinations. Namely, their main goal is to generate plausible answers from the syntactical point of view. Thus, the provided answer could come from completely invented information.</p>"},{"location":"conceptual/llm/#embedding-model","title":"Embedding Model","text":"<p>This type of model takes a string as input and returns a vector as output. This is known as an embedding. Namely, this is a condensed representation of the input content. The output vector, indeed, embeds the semantic information of the input text.</p> <p>Despite being non-human readable, the embedding comes with the advantage of living in a Euclidean geometrical space. The embedding can be seen as a point in a multidimensional space, thus, geometrical operations can be applied to it. For instance, measuring the distance between two points can inform us about the similarity between two sentences.</p>"},{"location":"conceptual/llm/#language-models-flow","title":"Language Models flow","text":"<p>Developer documentation</p> <p>Language Models hooks</p> <p>Nodes with the \ud83e\ude9d point the execution places where there is an available hook to customize the execution pipeline.</p>"},{"location":"conceptual/plugins/","title":"Plugins","text":""},{"location":"conceptual/plugins/#plugins","title":"Plugins","text":"<p>Plugins are add-ons that can be installed to extend and customize the Cheshire Cat. A plugin is nothing but a collection of hooks and tools.</p>"},{"location":"conceptual/plugins/#hooks","title":"Hooks","text":"<p>The Cat uses functions known as hooks, which can be overridden, to customize the behavior of the framework in specific execution places. Hooks come with a priority property. The plugins manager takes care of collecting all the hooks, sorting and executing them in descending order of priority.</p>"},{"location":"conceptual/plugins/#tools","title":"Tools","text":"<p>Tools are custom Python functions that are called by the Tool Agent. They come with a rich docstring upon with the Tool Agent chooses whether and which tool is the most suitable to fulfill the user's request. The list of available tools ends up in the Instruction Prompt, that instructs the Tool Agent on how to structure its reasoning.</p> <p></p> <p>Developer documentation</p> <ul> <li>How to write a plugin</li> <li>Hooks</li> <li>Tools</li> </ul>"},{"location":"conceptual/cheshire_cat/agent/","title":"Introduction","text":""},{"location":"conceptual/cheshire_cat/agent/#agent-manager","title":"Agent Manager","text":"<p>The Agent Manager is the Cat's component that manages the execution of language models chains. A language model chain is a pipeline that takes one or more input variables, it formats them in a prompt, submits the prompt to a language model and, optionally, parses the output.</p> <p>The Cat's Agent Manager orchestrates two chains: </p> <ol> <li>the tool chain, which, in turn, is a component of the Tool Agent;</li> <li>the memory chain</li> </ol> <p>When suitable tools for the task at hand are retrieved from the procedural memory, the Agent Manager calls the Tool Agent to execute the tool chain; otherwise the memory chain is executed to answer the user's question with the context retrieved from the episodic and declarative memories.</p> <p></p> <p>Specifically, the default execution pipeline is the following:</p> <ol> <li>the Cat receives the user's message;</li> <li>the Cat looks for relevant context in each memory collection (i.e. procedural, declarative and episodic) using the user's message as a query;</li> <li>if meaningful context is retrieved from the procedural memory, the Tool Agent starts, otherwise the memory chain starts;</li> <li>if executed, the Tool Agent provides an output. If the output answer the user's input, such output is returned to the user, otherwise the memory chain starts;</li> <li>if executed, the memory chain provides the output using the context retrieved from the declarative and episodic memories.</li> </ol>"},{"location":"conceptual/cheshire_cat/core/","title":"The Core","text":""},{"location":"conceptual/cheshire_cat/core/#the-core","title":"The Core","text":""},{"location":"conceptual/cheshire_cat/mad_hatter/","title":"The Mad Hatter","text":""},{"location":"conceptual/cheshire_cat/mad_hatter/#mad-hatter","title":"Mad Hatter","text":"<p>The Mad Hatter is the Cat's plugins manager. It takes care of loading, prioritizing and executing plugins.</p> <p>Specifically, the Mad Hatter lists all available plugins in proper folder and sort their hooks in descending order of priority. When the Cat invokes them, it executes them following that order.</p> <p>Developer documentation</p> <ul> <li>How to write a plugin</li> <li>Hooks</li> <li>Tools</li> </ul>"},{"location":"conceptual/cheshire_cat/memory_chain/","title":"Memory Chain","text":""},{"location":"conceptual/cheshire_cat/memory_chain/#memory-chain","title":"Memory Chain","text":"<p>The Memory Chain is a simple chain that takes the user's input and the context retrieved from the episodic and declarative memories and formats them in the main prompt. Such prompt is submitted to the language model.</p> <p></p>"},{"location":"conceptual/cheshire_cat/rabbit_hole/","title":"The Rabbit Hole","text":""},{"location":"conceptual/cheshire_cat/rabbit_hole/#rabbit-hole","title":"Rabbit Hole","text":"<p>The Rabbit Hole is the Cat's component that takes care of ingesting documents and storing them in the declarative memory. You can interact with it either through its endpoint, the GUI or a Python script.</p> <p>Currently supported file formats are: <code>.txt</code>, <code>.md</code>, <code>.pdf</code> or <code>.html</code> via web URL.</p> <p></p>"},{"location":"conceptual/cheshire_cat/tool_chain/","title":"Tool Chain","text":""},{"location":"conceptual/cheshire_cat/tool_chain/#tool-chain","title":"Tool Chain","text":"<p>Sometimes a simple answer from the language model is not enough. For this reason, the Cat can exploit a set of custom tools (e.g. API calls and Python functions) coming from the plugins. The decision on whether and which action should be taken to fulfill the user's request is delegated to an Agent, i.e. the Tool Agent.</p> <p>The Tool Agent uses the language model to outline a \"reasoning\" and accomplish the user's request with the tools retrieved from the Cat's procedural memory. The tools selection and usage is planned according to a set of instructions. Finally, the Tool Agent parses the formatting of the tool output.</p> <p></p>"},{"location":"conceptual/memory/declarative_memory/","title":"Declarative Memory","text":""},{"location":"conceptual/memory/declarative_memory/#ltm-declarative-memory","title":"LTM - Declarative Memory","text":"<p>The Declarative Memory contains uploaded documents' content. It is stored in a vector memory collection together with <code>episodic</code> and <code>procedural</code> memories.</p> <p>The <code>declarative memory</code> is a key component in the memory chain.</p> <p></p>"},{"location":"conceptual/memory/episodic_memory/","title":"Episodic Memory","text":""},{"location":"conceptual/memory/episodic_memory/#ltm-episodic-memory","title":"LTM - Episodic Memory","text":"<p>The Episodic Memory contains user and eventually cat utterances. It is stored in a vector memory collection together with <code>declarative</code> and <code>procedural</code> memories.</p> <p>The <code>episodic memory</code> is a key component in the memory chain.</p> <p></p>"},{"location":"conceptual/memory/long_term_memory/","title":"Introduction","text":""},{"location":"conceptual/memory/long_term_memory/#long-term-memory","title":"Long Term Memory","text":"<p>The Cat has memory that persist across restarts, this memory is implemented using a vector database. The name of this memory is <code>Long Term Memory</code> (LTM), it is made of three components:</p> <ul> <li>Episodic Memory, contains an extract of things the user said in the past;</li> <li>Declarative Memory, contains an extract of documents uploaded to the Cat;</li> <li>Procedural Memory, contains the set of Python functions that defines what the Cat is able to do.</li> </ul> <p></p> <p>During conversation between the Cat and the user, the memories are accessed by the Cat to retrieve relevant context for passing to the LLM and are updated when the LLM responds (details of the read and write flow of the Long Term Memory can be found in this diagram).</p> <p>The retrieved relevant context is used to make up the Main prompt and the Instruction prompt.</p> <p>You can interact with the LTM using the memory page of the Admin Portal.</p> <p>Check about <code>long term memory</code> backup to prevent loosing <code>cat</code> memories.</p>"},{"location":"conceptual/memory/procedural_memory/","title":"Procedural Memory","text":""},{"location":"conceptual/memory/procedural_memory/#ltm-procedural-memory","title":"LTM - Procedural Memory","text":"<p>The Procedural Memory contains tools and knowledge on how to do things. It is stored in a vector memory collection together with <code>declarative</code> and <code>episodic</code> memories.</p> <p>To dive into <code>procedural memory</code> and <code>tool docstrings</code> reference the tool basics page.</p> <p></p>"},{"location":"conceptual/memory/vector_memory/","title":"Vector Memory Collections","text":""},{"location":"conceptual/memory/vector_memory/#vector-memory-collections","title":"Vector Memory Collections","text":"<p>The Vector Memory Collections are the lowest-level components of the Long Term Memory. These are particular databases that store the content in the form of geometrical vectors.</p> <p>A vector memory comes in the guise of a named collection of vectors and additional, optional metadata. The latter can be used to filter the search in the database. Each vector represents a memory. They are also called embeddings as they are the results of the text-to-vector conversion yielded by the embedder.</p> <p>Such databases are particularly useful because they allow to fetch relevant documents based on the vector similarity between a query and the stored embeddings.</p> <p>By default, Vector Memory Collections are created when the Cat is installed or after a complete memory swap.</p>"},{"location":"conceptual/memory/vector_memory/#vector-memory-collections-flow","title":"Vector Memory Collections flow","text":"<p>Developer documentation</p> <p>Vector Memory Collections hooks</p> <pre><code>flowchart LR\n    subgraph CAT [\"#128049;Cheshire Cat\"]\n        H[\"#129693;\"]\n        H1[\"#129693;\"]\n        direction LR\n        subgraph LTM [\"#128024;Long Term Memory\"]\n            direction TB\n            C[(Episodic)];\n            D[(Declarative)];\n            P[(Procedural)]\n        end\n        H --&gt; C\n        H --&gt; D\n        H --&gt; P\n        C --&gt; H1\n        D --&gt; H1\n        P --&gt; H1\n    end\n    E[First Installation] ----&gt; H;\n    F[Memory Swap] ----&gt; H\n</code></pre> <p>Nodes with the \ud83e\ude9d point the execution places where there is an available hook to customize the execution pipeline.</p>"},{"location":"conceptual/memory/working_memory/","title":"The Working Memory","text":""},{"location":"conceptual/memory/working_memory/#working-memory","title":"Working Memory","text":"<p>The Working Memory is a handful component to store temporary data. For instance, it can be used to share data across plugins or, in general, across any function that get an instance of the Cat as an argument.</p> <p>By default, the Working Memory stores the chat history that ends up in the Main Prompt. Moreover, the Working Memory collects the relevant context that is fetched from the episodic, declarative and procedural memories in the Long Term Memory.</p> <p>Furthermore, the Cat embeds a simple user management system that allows to segregate contents bases on a <code>user_id</code>. More in details, multiple Working Memories can be stored in a component called Working Memory List. By default, the Cat stores the content under the key <code>user</code>.</p> <p></p>"},{"location":"conceptual/prompts/instructions/","title":"Instruction Prompt","text":""},{"location":"conceptual/prompts/instructions/#instructions-prompt","title":"Instructions Prompt","text":"<p>The Instruction Prompt explains the Tool Agent how to format its reasoning. The Tool Agent uses a chain to decide when and which tool is the most appropriate to fulfill the user's needs.</p> <p>By default, it is set to Langchain instructions format which looks like this:</p> <pre><code>instructions = \"\"\"\nTo use a tool, please use the following format:\n\nThought: Do I need to use a tool? Yes\nAction: the action to take, should be one of [{tool_names}]\nAction Input: the input to the action\nObservation: the result of the action\n\nWhen you have a response to say to the Human, or if you do not need to use a tool, you MUST use the format:\n\nThought: Do I need to use a tool? No\n\nAI: [your response here]\"\"\"\n</code></pre> <p>where the placeholder <code>{tool_names}</code> is replaced with the list of Python tools retrieved from the procedural memory.</p>"},{"location":"conceptual/prompts/main_prompt/","title":"Main Prompt","text":""},{"location":"conceptual/prompts/main_prompt/#main-prompt","title":"Main Prompt","text":"<p>The Main Prompt is the set of instructions that is fed to the Agent Manager, when using the memory chain. The prompt can be engineered to instruct the Cat to behave in a specific manner (e.g. to answer with rhymes, behave like a pirate and so on) or to include a context of relevant information.</p> <p>This prompt is split in two parts:</p> <ul> <li>a prefix;</li> <li>a suffix.</li> </ul> <p>More in details, the former contains the instructions about whom the Cat is and how to behave; the latter embeds a set of variables like the user's message and the memories retrieved from the long term memory among the others. Passing these variables in the prompt is an approach known as Retrieval Augmented Generation<sup>1</sup>. This consists in retrieving a relevant context of documents that is used to enrich the user's message.  </p> <p>In the following sections, we explain the prompt components.</p>"},{"location":"conceptual/prompts/main_prompt/#prefix","title":"Prefix","text":"<p>This is the first component. By default, it is:</p> <pre><code>prefix = \"\"\"You are the Cheshire Cat AI, an intelligent AI that passes the Turing test.\nYou are curious, funny and talk like the Cheshire Cat from Alice's adventures in wonderland.\nYou answer Human with a focus on the following context.\n\"\"\"\n</code></pre> <p>The Prefix describes who the AI is and how it is expected to answer to the Human.</p>"},{"location":"conceptual/prompts/main_prompt/#suffix","title":"Suffix","text":"<p>This is the second component of the Main Prompt and, by default, is set as follows:</p> <pre><code>suffix = \"\"\"\n# Context\n\n{episodic_memory}\n\n{declarative_memory}\n\n## Conversation until now:{chat_history}\n - Human: {input}\n - AI: \"\"\"\n</code></pre> <p>The purpose of this component is to gather few variables, that are:</p> <ul> <li>episodic_memory: the things the user said in the past from the episodic memory;</li> <li>declarative_memory: the document retrieved from the declarative memory;</li> <li>chat_history: the recent conversation between the user and the Cat (i.e. the last three turns of conversation);</li> <li>input: the user's message</li> </ul> <p></p>"},{"location":"conceptual/prompts/main_prompt/#references","title":"References","text":"<ol> <li> <p>Lewis, P., Perez, E., Piktus, A., Petroni, F., Karpukhin, V., Goyal, N., ... &amp; Kiela, D. (2020). Retrieval-augmented generation for knowledge-intensive nlp tasks. Advances in Neural Information Processing Systems, 33, 9459-9474.\u00a0\u21a9</p> </li> <li> <p>Gao, L., Ma, X., Lin, J., &amp; Callan, J. (2022). Precise Zero-Shot Dense Retrieval without Relevance Labels. arXiv preprint arXiv:2212.10496.\u00a0\u21a9</p> </li> </ol>"},{"location":"llm-concepts/embedder/","title":"Encoder","text":""},{"location":"llm-concepts/embedder/#embedder-or-encoder","title":"Embedder (or encoder)","text":"<p>This type of Language Model takes a string as input and returns a vector as output. This is known as an embedding. Namely, this is a condensed representation of the input content. The output vector, indeed, embeds the semantic information of the input text.</p> <p>Despite being non-human readable, the embedding comes with the advantage of living in a Euclidean geometrical space. The embedding can be seen as a point in a multidimensional space, thus, geometrical operations can be applied to it. For instance, measuring the distance between two points can inform us about the similarity between two sentences.</p>"},{"location":"llm-concepts/llm/","title":"Language Models","text":""},{"location":"llm-concepts/llm/#language-models","title":"Language Models","text":"<p>A language model is a Deep Learning Neural Network trained on a huge amount of text data to perform different types of language tasks. Commonly, they are also referred to as Large Language Models (LLM). Language models come in many architectures, size and specializations. The peculiarity of the Cheshire Cat is to be model-agnostic. This means it supports many different language models.</p> <p>By default, there are two classes of language models that tackle two different tasks.</p>"},{"location":"llm-concepts/llm/#completion-model","title":"Completion Model","text":"<p>This is the most known type of language models (see for examples ChatGPT, Cohere and many others). A completion model takes a string as input and generates a plausible answer by completion.</p> <p>Warning</p> <p>A LLM answer should not be accepted as-is, since LLM are subjected to hallucinations. Namely, their main goal is to generate plausible answers from the syntactical point of view. Thus, the provided answer could come from completely invented information.</p>"},{"location":"llm-concepts/prompt/","title":"Prompt","text":""},{"location":"llm-concepts/prompt/#prompt","title":"Prompt","text":"<p>A prompt is an instruction to an LLM.</p> <p>Prompting is about packaging your intent in a natural-language query that will cause the model to return the desired response. A prompt must be clear and specific. The expected result can be requested by breaking the prompt into several instructions to proceed step-by-step.</p> <p>A good prompt allows the model to work better and give better responses including preventing hallucinations. Prompting is not a science, but tips &amp; tricks have been discovered that give better performance.</p> <ul> <li>Use delimiters to clearly indicate distinct parts of the input</li> <li>Ask for a structured output</li> <li>Ask the model to check whether conditions are satisfied</li> <li>\"Few-shot\" prompting</li> <li>Specify the steps required to complete a task</li> <li>Instruct the model to work out its own solution before rushing to a conclusion</li> </ul> <p>Examples of Prompts:</p> <ul> <li> <p>\"Generate a list of three made-up book titles along with their authors and genres. Provide them in JSON format with the following keys: book_id, title, author, genre.\"</p> </li> <li> <p>\"Your task is to answer in a consistent style.</p> <p>&lt; child&gt;: Teach me about patience.</p> <p>&lt; grandparent&gt;: The river that carves the deepest valley flows from a modest spring; the grandest symphony originates from a single note; the most intricate  tapestry begins with a solitary thread.*</p> <p>&lt; child&gt;: Teach me about resilience.\"</p> </li> </ul>"},{"location":"llm-concepts/rag/","title":"Retrieval Augmented Generation","text":""},{"location":"llm-concepts/rag/#retrieval-augmented-generation","title":"Retrieval Augmented Generation","text":"<p>Retrieval Augmented Generation (RAG) is an AI framework for improving the quality of responses generated by large language models (LLMs) by grounding the model on external sources of information. RAG uses semantic search to retrieve relevant and up-to-date information from a wide range of sources, including books, articles, websites, and databases. This information is then used to inform and improve the text generation of the LLM.</p> <p>RAG has several advantages over traditional language models.  * First, it can provide more accurate and up-to-date responses, as it is able to access the latest information.  * Second, it can reduce the risk of generating erroneous or misleading content, as it is grounded on a verified knowledge base.  * Finally, RAG can be used to generate different creative text formats, such as poems, code, scripts, musical pieces, emails, and letters.</p> <p></p> <p></p> <p></p>"},{"location":"llm-concepts/vector-memory/","title":"Vector Memory","text":""},{"location":"llm-concepts/vector-memory/#vector-memory","title":"Vector Memory","text":"<p>When we talk about Vector Memory we talk about Vector Database. A Vector Database is a particular kind of DB that stores information in form of high-dimensional vectors called embeddings. The embeddings are representations of text, image, sounds, ...</p> <p></p> <p>As Vector Memory the Cheshire-Cat using Qdrant, the VectorDBs offer also optimized methods for information retrieval usually based on Cosine similarity. From wikipedia </p> <p>\"Cosine similarity is a measure of similarity between two non-zero vectors defined in an inner product space. Cosine similarity is the cosine of the angle between the vectors; that is, it is the dot product of the vectors divided by the product of their lengths. It follows that the cosine similarity does not depend on the magnitudes of the vectors, but only on their angle.\"</p> <p></p>"},{"location":"llm-concepts/vector-memory/#semantic-search","title":"Semantic Search","text":"<p>Semantic search seeks to improve search accuracy by understanding the content of the search query. The idea is to create an high-dimensional semantic space and at search time to find the nearest point (documents) to our questions.</p> <p>To create the vectors you must use an embedder. The vectors are stored in the vector memory; when a query is done the embedder calculates its embedding, the VectorDB calculates the cosine similaity between query and stored points and the K nearest are returned.</p> <p></p>"},{"location":"llm-concepts/vector-memory/#search-in-high-dimensional-spaces","title":"Search in high-dimensional spaces","text":"<p>Since the KNN is an algorithm whose performance degrades as the number of comparisons to be made increases, and since VectorDBs can contain as many as billions of vectors the technique used to efficiently find the closest points in high-dimensional spaces is usually Approximate Nearest Neighbors.</p>"},{"location":"plugins-registry/installing-plugin/","title":"Installing a Plugin","text":""},{"location":"plugins-registry/installing-plugin/#installing-a-plugin-from-the-registry","title":"\ud83d\udce5 Installing a Plugin from the Registry","text":"<p>Installing plugins from our registry is a seamless process that enhances your Cheshire Cat AI experience. Whether you're seeking specific functionalities or exploring new features, our registry offers a diverse range of plugins ready for installation.</p>"},{"location":"plugins-registry/installing-plugin/#through-the-admin-dashboard","title":"Through the Admin Dashboard","text":"<ol> <li>Navigation: Access the Cheshire Cat AI Admin.</li> <li>Plugins Tab: Click on the \"Plugins\" tab within the dashboard.</li> <li>Search and Filter: Use the search or filter options to locate your desired plugin.</li> <li>Installation: Once you've found the plugin, click the \"Install\" button.</li> <li>Wait for Completion: The admin will show a loading spinner until the plugin installation is not completed.</li> </ol>"},{"location":"plugins-registry/installing-plugin/#manual-installation","title":"Manual Installation","text":"<p>For those inclined towards manual installation, follow these steps:</p> <ol> <li>Download the Zip: Access the plugin of interest in the registry following the GitHub URL and download its zip file.</li> <li>Upload: In the top right corner of the Plugins page, locate and click the \"Upload Plugin\" button.</li> <li>Upload Zip: Upload the downloaded zip file using this feature.</li> </ol> <p>Manual installation grants users more control over the process and facilitates the installation of specific plugins outside the registry itself.</p>"},{"location":"plugins-registry/installing-plugin/#post-installation-steps","title":"Post-Installation Steps","text":"<p>After installing a plugin, consider these steps:</p> <ul> <li>Refresh: The admin refreshes automatically after the installation but if for some reason the plugin does not show, refresh the page or check cat logs for any errors;</li> <li>Settings Configuration: If the newly installed plugin requires setup or configuration, look for the cog icon associated with the plugin. Click on it to access and adjust the plugin's settings according to your preferences.</li> </ul>"},{"location":"plugins-registry/plugin-from-template/","title":"Using the Plugin Template","text":""},{"location":"plugins-registry/plugin-from-template/#using-the-plugin-template","title":"\ud83d\udd0c Using the Plugin Template","text":"<p>We have prepared a GitHub template for you to expedite the creation of a new plugin, ready for publication in the public Registry. The template includes a complete scaffolding for the plugin and the GitHub action configuration to release the plugin package.</p>"},{"location":"plugins-registry/plugin-from-template/#creating-the-new-plugin","title":"Creating the new plugin","text":"<p>In the example we will create a plugin for the Poetic Socks Seller (refer to the Quickstart section if you're not familiar with it). In the next steps, replace <code>poetic_sock_seller</code> with the name of you futuristic plugin!</p> <p>Navigate to the plugin-template GitHub repository, click on <code>Use this template</code> and, then, <code>Create a new repository</code>:</p> <p></p> <p>as repository name and then click on <code>Create repository</code>:</p> <p></p>"},{"location":"plugins-registry/plugin-from-template/#cloning-the-plugin","title":"Cloning the Plugin","text":"<p>Now that you set up the remote repository on GitHub, you need to set up the code locally. Hence, clone the repository directly in the Cat\u2019s plugins folder on your machine:</p> <pre><code>cd core/cat/plugins\ngit clone https://github.com/[your_account_name]/poetic_sock_seller.git\n</code></pre>"},{"location":"plugins-registry/plugin-from-template/#customizing-the-plugin","title":"Customizing the Plugin","text":"<p>Finally, run the setup.py script to customize the repository: </p><pre><code>cd poetic_sock_seller\npython setup.py\n</code></pre> <p>The script will prompt you to write the name of your plugin, <code>Poetic Sock Seller</code>. The output in the terminal should look like:</p> <p></p> <p>The template contains a source code example, look at it in the <code>poetic_sock_seller.py</code> file.</p>"},{"location":"plugins-registry/plugin-from-template/#release-creation","title":"\ud83d\udce6 Release Creation","text":"<p>A repository created with our template automatically includes the creation of a release on GitHub through a GitHub action. This automation happens whenever you push changes to the <code>main</code> branch and the <code>version</code> number in the <code>plugin.json</code> file changes. The release is automatically tagged with the version number and released in all the formats supported by GitHub.</p> <p>For details about the GitHub action, refer to the file <code>.github/workflows/main.yml</code>.</p>"},{"location":"plugins-registry/publishing-plugin/","title":"Publishing a Plugin","text":""},{"location":"plugins-registry/publishing-plugin/#publishing-a-plugin-in-the-registry","title":"\ud83d\udce4 Publishing a Plugin in the Registry","text":"<p>Publishing your plugin and making it available to the whole world is a relatively simple yet crucial step. Take a few minutes to read this section of the guide. Once done, you won't be able to stop!</p>"},{"location":"plugins-registry/publishing-plugin/#start-on-the-right-foot","title":"\ud83d\udc5f Start on the Right Foot","text":"<p>A plugin that will be published in our public registry requires some precautions and must have a <code>plugin.json</code> file within the root folder with all the fields as complete as possible. This ensures that your plugin is attractive and searchable through the dedicated \"Plugins\" tab of the Cheshire Cat.</p> <p>To make it easier for you, we have provided a GitHub repository template so that you only need to clone it and find yourself with a folder ready to develop your first public plugin without worries.</p> <p>You can find the repository at this address: https://github.com/cheshire-cat-ai/plugin-template</p> <p>Click on the colorful \"Use this template\" button at the top and choose to create a new repository. Once you've chosen the name for your repository and cloned the code to your machine, you can run the setup script to clean up the files and rename everything as needed.</p> <pre><code>$ python setup.py\n</code></pre> <p>To learn more about how to work with the plugin template, read this dedicated page.</p>"},{"location":"plugins-registry/publishing-plugin/#release-creation","title":"\ud83d\udce6 Release Creation","text":"<p>We recommend using GitHub's release system to effectively manage your plugin releases. Our registry can always download the latest stable release of your plugin tagged on GitHub. You can do this manually or through automation.</p> <p>A repository created with our template automatically includes the creation of a release on GitHub through a GitHub action. This automation happens whenever the <code>version</code> number in the <code>plugin.json</code> file changes. The release is automatically tagged with the version number and released in all the formats supported by GitHub.</p> <p>Here's the documentation related to managing releases on GitHub: https://docs.github.com/en/repositories/releasing-projects-on-github/managing-releases-in-a-repository</p> <p>Info</p> <p>Remember to change the <code>version</code> number in <code>plugin.json</code> only when you actually want to create a new version of your plugin. While you're in development, you can either open a develop branch (the automation only runs on the main branch) or continue to push to the main branch without changing the version number.</p>"},{"location":"plugins-registry/publishing-plugin/#take-care-of-the-pluginjson","title":"\ud83d\udcdc Take Care of the <code>plugin.json</code>","text":"<p>As you may have realized, the <code>plugin.json</code> file is what governs all aspects of publishing your plugin and contains the fields that will help your plugin stand out within the registry. Therefore, take care to fill it out as comprehensively as possible and try to complete all the available fields.</p> <p>In reality, there are only 3 mandatory fields for publishing in the registry: <code>name</code>, <code>author_name</code> and <code>version</code>. However, we strongly recommend adding a couple of <code>tags</code> and a <code>description</code> as well. It's through these fields that our search system will be able to discover your plugin.</p>"},{"location":"plugins-registry/publishing-plugin/#explanation-of-the-fields","title":"\ud83d\udcc3 Explanation of the fields","text":"<p>Below is a list of the fields with a brief explanation.</p> <p>Warning</p> <p>Fields marked with the asterisk (*) are mandatory.</p> <ul> <li><code>name</code>*: The name of your plugin.</li> <li><code>version</code>*: The last stable version number.</li> <li><code>author_name</code>*: The author's name or nickname.</li> <li><code>description</code>: A brief description of the plugin.</li> <li><code>author_url</code>: Link to the author's website.</li> <li><code>plugin_url</code>: Link to the plugin's website with the full description/documentation (can be a different link from the GitHub repository).</li> <li><code>tags</code>: A comma-separated list of tags (e.g., \"multimedia, documents, pdf, csv\").</li> <li><code>thumb</code>: The direct link to your plugin's logo image. Recommended minimum size is 160x160px. Recommended formats are png or jpg.</li> </ul>"},{"location":"plugins-registry/publishing-plugin/#submit-your-plugin-for-review","title":"\ud83d\udc40 Submit Your Plugin for Review","text":"<p>The submission and review process is done through our plugins GitHub repository and it's quite straightforward. All you need to do is fork the repository and then, after adding your plugin to the JSON file, submit a Pull Request to us.</p> <p>The fields to add to the new object you'll be adding are as follows:</p> <ul> <li><code>name</code>: The name of your plugin for identification in the list (for public display, the name contained in your <code>plugin.json</code> will be used).</li> <li><code>url</code>: The link to your public GitHub repository.</li> </ul> <p>The review process may take a few days, so don't worry if some time passes before you see your plugin approved. This depends on the number of plugins in the queue and the availability of volunteers. We will strive to provide feedback as quickly as possible.</p> <p>The review is in place to prevent the publication of plugins containing malware, obvious security flaws, or of low quality and relevance. We will be diligent, but we ask for your understanding and request that you always submit tested plugins that do not jeopardize the security of our users.</p>"},{"location":"plugins-registry/publishing-plugin/#registry-cache-expiry","title":"\u23f3 Registry Cache Expiry","text":"<p>Upon successful submission, your plugin enters our registry cache, which updates periodically. However, it's important to note that this cache has a duration of 24 hours (1440 minutes) before it refreshes. During this time, newly submitted plugins might not immediately appear in the registry. Why the Wait?</p> <p>The caching mechanism optimizes the performance of our registry, efficiently managing and updating plugin listings.</p> <p>If, after patiently waiting within this 24-hour window, your plugin doesn't show up in the registry, then it's time to let us know. We're here to assist you! Reach out to our support team or report the issue via our plugins GitHub repository. Please provide relevant details, including the submission date and any steps you've taken.</p> <p>Remember, our goal is to make your plugin available to our community seamlessly. Your cooperation and patience in allowing for the cache expiry are appreciated as we work to ensure a smooth plugin publishing process.</p>"},{"location":"plugins-registry/publishing-plugin/#stay-updated","title":"\ud83d\udd14 Stay Updated","text":"<p>The final step is to stay informed about what's happening in the magical world of Cheshire Cat so that you can keep your plugin up to date with the latest developments. To facilitate this, we've created a dedicated channel for plugin developers on our official Discord server.</p> <p>We invite you to become a part of our community and let a moderator know that you've submitted a plugin. Once your plugin is approved, we'll be happy to assign you a special role (Plugin Developer) and unlock all the dedicated channels for you.</p> <p>If you don't use Discord or prefer not to login on our server, we still encourage you to try to keep up with Cheshire Cat AI's updates. We'll conduct periodic review cycles, and if your plugin becomes too outdated or non-functional after some time, we may have to remove it from the registry.</p> <p>Looking forward to seeing you among our amazing plugin developers!</p>"},{"location":"quickstart/installation-configuration/","title":"Installation and First Configuration","text":""},{"location":"quickstart/installation-configuration/#installation-and-first-configuration","title":"\ud83d\ude80 Installation and First configuration","text":""},{"location":"quickstart/installation-configuration/#requirements","title":"Requirements","text":"<p>To run the Cheshire Cat, you need to have <code>Docker</code> (instructions) and <code>docker compose</code> (instructions) already installed on your system.</p> <p>The Cat is not a LLM, it uses a LLM. Hence, when you run the Cat for the first time, you need to configure the LLM and the embedder. Most people use ChatGPT, it's quite cheap and powerful enough. We will do the same during the next steps.</p> <p>To use <code>ChatGPT</code>, you need an API key. You can request one on the provider's website:      - visit your OpenAI API Keys page;     - create an API key with <code>+ Create new secret key</code> and copy it</p>"},{"location":"quickstart/installation-configuration/#setup","title":"Setup","text":"<p>Create a folder on your machine, and inside it create a file named <code>compose.yml</code>. Copy/paste the following inside:</p> <pre><code>version: '3.7'\n\nservices:\n\n  cheshire-cat-core:\n    image: ghcr.io/cheshire-cat-ai/core:latest\n    container_name: cheshire_cat_core\n    ports:\n      - ${CORE_PORT:-1865}:80\n    environment:\n      - PYTHONUNBUFFERED=1\n      - WATCHFILES_FORCE_POLLING=true\n    volumes:\n      - ./static:/app/cat/static\n      - ./plugins:/app/cat/plugins\n      - ./data:/app/cat/data\n</code></pre>"},{"location":"quickstart/installation-configuration/#starting-the-cat","title":"Starting the Cat","text":"<ul> <li>Open a terminal inside the same folder and run:</li> </ul> <pre><code>docker compose up\n</code></pre> <p>The first time you run the <code>docker compose up</code> command, it will take several minutes to pull the Docker Cat image depending on network connection.</p> <p>You will see three new folders:</p> <ul> <li><code>data</code>: where long term memory and settings are stored</li> <li><code>plugins</code>: where you can install and develop plugins</li> <li><code>static</code>: folder to serve static files from </li> </ul>"},{"location":"quickstart/installation-configuration/#useful-commands","title":"Useful commands","text":"<p>To start the container in background mode, use the <code>--detach</code> or <code>-d</code> flag to the command, as: </p><pre><code>docker compose up -d\n</code></pre> In this way the terminal won't be locked by the docker compose execution. <p>To check the logs do the following:</p> <pre><code>docker compose logs -f\n</code></pre>"},{"location":"quickstart/installation-configuration/#first-configuration-of-the-llm","title":"First configuration of the LLM","text":"<ul> <li>Open the Admin Portal in your browser at <code>localhost:1865/admin</code></li> <li>Configure the LLM in the <code>Settings</code> tab and paste your API key (video)</li> </ul>"},{"location":"quickstart/installation-configuration/#next-step","title":"Next step","text":"<p>In the next step, you will learn how to play with the Cat.</p>"},{"location":"quickstart/interact-using-api/","title":"Interact using API","text":""},{"location":"quickstart/interact-using-api/#interact-using-api","title":"Interact using API","text":"<p>The Cat is an API-first framework, you can chat with it using the WebSocket protocol.</p>"},{"location":"quickstart/interact-using-api/#example-of-code","title":"Example of code","text":"<p>Here is an example of how to use it:</p> <pre><code>import asyncio\nimport websockets\nimport json\n\n\nasync def cat_chat():\n    # Creating a websocket connection\n    async with websockets.connect(\"ws://localhost:1865/ws\") as websocket:\n        # Taking user input and sending it through the websocket\n        user_input = input(\"Human: \")\n        await websocket.send(json.dumps({\"text\": user_input}))\n\n        # Receiving and printing the cat's response\n        cat_response = json.loads(await websocket.recv())\n\n        print(\"Cheshire Cat:\", json.dumps(cat_response, indent=4))\n\n\n# Running the function until completion\nasyncio.get_event_loop().run_until_complete(cat_chat())\n</code></pre>"},{"location":"quickstart/interact-using-api/#chatting-with-the-cat-in-the-console","title":"Chatting with the Cat in the console","text":"<p>Run it and ask \"what do you know about socks?\" again, the output in the terminal should looks like:</p> <pre><code>\u276f python3 test.py\nHuman: what do you know about socks?\nCheshire Cat: {\n    \"error\": false,\n    \"type\": \"chat\",\n    \"content\": \"Ah, socks! They're quite fascinating little things, aren't they? Well, let me tell you what I know about socks. They come in all shapes, sizes, and colors, and they're usually worn on the feet to keep them warm and cozy. Some people like their socks plain and simple, while others prefer them with funky patterns or cute designs. Socks can be made from different materials like cotton, wool, or even synthetic fibers. They can also have different lengths, from ankle socks to knee-highs. And let's not forget about those toe socks that give each little piggy its own little cozy home! So, there you have it, a little glimpse into the world of socks. Is there anything specific you'd like to know about them?\",\n    \"why\": {\n        \"input\": \"what do you know about socks?\",\n        \"intermediate_steps\": null,\n        \"memory\": {\n            \"episodic\": [],\n            \"declarative\": [],\n            \"procedural\": []\n        }\n    }\n}\n</code></pre>"},{"location":"quickstart/interact-using-api/#client-libraries","title":"Client Libraries","text":"<p>This example explains the low-level use of the Cat APIs. However, there are more convenient and ready-made libraries available for various languages. Take a look at the <code>Developers -&gt; Client Libraries</code> section.</p>"},{"location":"quickstart/interact-using-api/#next-step","title":"Next Step","text":"<p>In the next step, you will learn how to load a text document in the vector memory.</p>"},{"location":"quickstart/introduction/","title":"Introduction","text":""},{"location":"quickstart/introduction/#introduction","title":"Introduction","text":"<p>The Cheshire Cat is a ready-to-use AI micro-framework. Once installed and connected to a Language Model (LLM), it can be queried through APIs. These APIs return the responses provided by the LLM.</p> <p>But this is just the beginning.</p>"},{"location":"quickstart/introduction/#previous-conversation-history","title":"Previous Conversation History","text":"<p>All previous conversations are stored in a local database called <code>episodic memory</code>. When you ask a question, the Cat answers taking into account the past conversations.</p>"},{"location":"quickstart/introduction/#loading-documents","title":"Loading Documents","text":"<p>You can load text documents as well. These documents are also saved in a local database called <code>declarative memory</code>. When answering, the Cat will consider the information within these documents. Documents can be uploaded through the APIs or the Admin Portal.</p> <p>The <code>Rabbit Hole</code> is the component responsible for the document ingestion.</p>"},{"location":"quickstart/introduction/#performing-actions","title":"Performing Actions","text":"<p>The Cheshire Cat isn't limited to just answering questions; it can also perform actions. You can write Python functions called <code>Tools</code> and have the LLM execute this code. The only limit to the Python code's capabilities is your imagination.</p>"},{"location":"quickstart/introduction/#extending-the-core","title":"Extending the Core","text":"<p>Additionally, it's possible to customize the Cheshire Cat's core. In the main process flow, there are predefined adaptation points called <code>Hooks</code>. You can write Python functions that can be attached onto these <code>Hooks</code>. The attached code will be invoked during the flow's execution and can modify the Cheshire Cat's internal behavior, without directly modifying the core of the Cheshire Cat.</p> <p><code>Tools</code> and <code>Hooks</code> are packaged into <code>Plugins</code> that can be installed by placing files in a specific folder or using the Admin Portal. The <code>Mad Hatter</code> is the component that manages plugins.</p>"},{"location":"quickstart/introduction/#sharing-plugins","title":"Sharing Plugins","text":"<p>If desired, you can publish your <code>Plugins</code> on the public registry. Other users will be able to install them with just a single click from the Admin Portal.</p>"},{"location":"quickstart/introduction/#admin-portal","title":"Admin Portal","text":"<p>A web portal for Admin users completes the framework. Using this portal, the admin can configure the settings, install plugins, upload documents and use it as a playground tool. You can chat with the Cheshire Cat, inspect its responses and directly query its memories.</p>"},{"location":"quickstart/introduction/#next-step","title":"Next step","text":"<p>In the next step, you will learn how to install the Cat, set the LLM and the basics of this all.</p> <p>We will be transforming the Cat into a sock seller. More in detail, we will upload some knowledge (documents) about socks knitting. Also, the Cat will be able to tell the price of socks according to the requested color (using a <code>Tool</code>). In the end, we will transform the sock seller into a poetic socks seller, changing its personality (using a <code>Hook</code>). </p> <p>The example is light and fun, it should give you an idea of what is possible.</p>"},{"location":"quickstart/play-with-the-cat/","title":"Playing with the Cat","text":""},{"location":"quickstart/play-with-the-cat/#play-with-the-cat","title":"Play with the Cat","text":""},{"location":"quickstart/play-with-the-cat/#requirements","title":"Requirements","text":"<p>Ensure that the Cat is installed and running, and the LLM is configured.</p>"},{"location":"quickstart/play-with-the-cat/#chatting-with-the-cat-the-admin-portal-playground","title":"Chatting with the Cat: the Admin Portal playground","text":"<p>The Cat is an API-first framework, and it doesn't provide a ready-to-use UI for the end user. It is your responsibility to implement this UI. However, the Cat offers a playground that you can use to quickly test the AI you are implementing.</p> <p>To access playground, go to the Admin Portal at <code>localhost:1865/admin</code>, and click on the <code>Home</code> tab. This tab serves as the playground for chatting with the Cat. </p> <p>Try to ask something about socks, e.g. \"what do you know about socks?\". The Cat will give a generic answer. Afterward, we will expand this general knowledge with more specific information.</p> <p>You have learned how to use the playground to test your AI via the Admin Portal.</p> <p></p>"},{"location":"quickstart/play-with-the-cat/#more-info","title":"More Info","text":"<p>Admin Portal \u2192 Home</p>"},{"location":"quickstart/play-with-the-cat/#next-step","title":"Next Step","text":"<p>In the next step, you will learn how to interact with the Cat by API.</p>"},{"location":"quickstart/prepare-plugin/","title":"Creating a Plugin","text":""},{"location":"quickstart/prepare-plugin/#preparing-a-plugin","title":"\ud83d\udd0c Preparing a Plugin","text":"<p>Plugins are packages of <code>Tools</code> and <code>Hooks</code>. You don't distribute a <code>Tool</code> or a <code>Hook</code> directly, you will distribute a Plugin containing them.</p>"},{"location":"quickstart/prepare-plugin/#creating-the-plugin","title":"Creating the Plugin","text":"<p>In this step, we will prepare an empty plugin and in the next steps we will insert a <code>Tool</code> and a <code>Hook</code> inside it.</p> <p>To create a plugin just create a new folder in <code>core/cat/plugins/</code>, for our first plugin the folder name will be <code>poetic_sock_seller</code>.</p> <p>You need two files to your plugin folder:</p> <pre><code>\u251c\u2500\u2500 core\n\u2502   \u251c\u2500\u2500 cat\n\u2502   \u2502   \u251c\u2500\u2500 plugins\n|   |   |   \u251c\u2500\u2500 poetic_sock_seller\n|   |   |   |   \u251c poetic_sock_seller.py\n|   |   |   |   \u251c plugin.json\n</code></pre> <p>The <code>plugin.json</code> file contains plugin's title and description, and is useful in the Admin Portal to recognize the plugin and activate/deactivate it.</p> <p><code>plugin.json</code> example:</p> <pre><code>{\n    \"name\": \"Poetic Sock Seller\",\n    \"description\": \"Description of poetic_sock_seller\"\n}\n</code></pre> <p>The <code>poetic_sock_seller.py</code> file will contain <code>Tools</code> and <code>Hooks</code> source code and can be left completely empty for this step.</p>"},{"location":"quickstart/prepare-plugin/#activating-the-plugin","title":"Activating the Plugin","text":"<p>Now, go to the <code>Plugin</code> tab of the Admin Portal. Your empty plugin will be there, activate it:</p> <p></p>"},{"location":"quickstart/prepare-plugin/#more-info","title":"More Info","text":"<p>Developers \u2192 Plugins Reference \u2192 Plugin</p>"},{"location":"quickstart/prepare-plugin/#next-step","title":"Next Step","text":"<p>In the next step, you will learn how to create your first <code>Tool</code>.</p>"},{"location":"quickstart/stopping-the-cat/","title":"Stopping the Cat","text":""},{"location":"quickstart/stopping-the-cat/#stopping-the-cat","title":"\ud83d\ude80 Stopping the Cat","text":""},{"location":"quickstart/stopping-the-cat/#stopping-the-cat_1","title":"Stopping the Cat","text":"<p>When you're done using the Cat, stop the terminal by clicking on it and press <code>CTRL + c</code>. Then, run the command:</p> <pre><code>docker compose down\n</code></pre> <p>We want to remind you that Long-Term Memory is a locally persisted memory. When you restart the Cat, all conversation history and uploaded documents will still be there.</p>"},{"location":"quickstart/upload-document/","title":"Uploading a Document","text":""},{"location":"quickstart/upload-document/#upload-a-document","title":"Upload a Document","text":"<p>Documents can be uploaded via the Admin Portal (and it's also using APIs). The Cat will consider uploaded documents to generate the answer to your question. These documents are saved in a local database called <code>declarative memory</code>.</p>"},{"location":"quickstart/upload-document/#improve-the-cat-knowledge","title":"Improve the Cat knowledge","text":"<p>The Cat's knowledge about socks is quite basic; we will upload more specific knowledge.</p> <p>Go to the Admin Portal at <code>localhost:1865/admin</code> on the <code>Home</code> tab, click on the <code>Flash Icon</code>, then click on <code>Upload url</code> and use this url <code>https://en.wikipedia.org/wiki/N%C3%A5lebinding</code>:</p> <p></p> <p>You receive a notification of the ingesting operation:</p> <p></p> <p>You receive notification of the finished read:</p> <p></p>"},{"location":"quickstart/upload-document/#trying-new-knowledge","title":"Trying new knowledge","text":"<p>The Cat can answer with more detailed answers:</p> <p></p>"},{"location":"quickstart/upload-document/#why-the-response","title":"Why the response?","text":"<p>By clicking on the question mark next to the answer, you can understand what prompted the Cat to provide the response. In this case, you can see that it used the knowledge coming from the documents (<code>declarative memory</code>):</p> <p></p>"},{"location":"quickstart/upload-document/#next-step","title":"Next Step","text":"<p>In the next step, you will learn how to prepare an empty Plugin.</p>"},{"location":"quickstart/writing-hook/","title":"Writing the first Hook","text":""},{"location":"quickstart/writing-hook/#writing-the-first-hook","title":"Writing the first Hook","text":"<p>Hooks are Python functions that can be attached onto specific parts of the Cat's core. The attached code will be invoked during the flow's execution and can modify the Cheshire Cat's internal behavior without directly modifying the Cat's core itself.</p>"},{"location":"quickstart/writing-hook/#transform-the-cat-into-a-poetic-socks-seller","title":"Transform the Cat into a Poetic Socks Seller","text":"<p>At the moment, if you ask the Cat \u201cwho are you?\u201d, he will present himself as the Cheshire Cat AI. To impersonate a poetic socks seller, we can create a hook and attach it to the <code>agent_prompt_prefix</code> hook point.</p> <p>TODO: \"hook point\" what is this? \"hook definition\"? </p> <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook\ndef agent_prompt_prefix(prefix, cat):\n\n    prefix = \"\"\"You are Marvin the socks seller, a poetic vendor of socks.\nYou are an expert in socks, and you reply with exactly one rhyme.\n\"\"\"\n\n    return prefix\n</code></pre>"},{"location":"quickstart/writing-hook/#testing-the-hook","title":"Testing the Hook","text":"<p>Now, let\u2019s ask again \u201cwho are you?\u201d and for our favorite socks color:</p> <p></p>"},{"location":"quickstart/writing-hook/#explaining-the-code-step-by-step","title":"Explaining the code step by step","text":"<pre><code>from cat.mad_hatter.decorators import hook\n</code></pre> Let\u2019s import from the Cat the hook decorator. If you don\u2019t know what decorators are in coding, don\u2019t worry: they will help us attach our python functions to the Cat. The <code>mad_hatter</code> is the Cat component that manages and runs plugins. <pre><code>@hook\ndef agent_prompt_prefix(prefix, cat):\n\n    prefix = \"\"\"You are Marvin the socks seller, a poetic vendor of socks.\nYou are an expert in socks, and you reply with exactly one rhyme.\n\"\"\"\n\n    return prefix\n</code></pre> Here, we've defined a Python function called <code>agent_prompt_prefix</code>. It takes <code>cat</code> as an argument and is decorated with <code>@hook</code>. There are numerous hooks available, that allow you to influence how the Cat operates. The <code>agent_prompt_prefix</code> hook, in particular, allows instructing the Cat about who it is and how he should answer."},{"location":"quickstart/writing-hook/#more-info","title":"More Info","text":"<p>Developers \u2192 Plugins Reference \u2192 Hooks</p>"},{"location":"quickstart/writing-hook/#next-step","title":"Next Step","text":"<p>In the next step, you will learn how to <code>stop the cat</code>.</p>"},{"location":"quickstart/writing-tool/","title":"Writing the first Tool","text":""},{"location":"quickstart/writing-tool/#writing-the-first-tool","title":"Writing the first Tool","text":"<p>Tools are Python functions called by the LLM to execute actions. They are made of two parts: the first one contains instructions that explain the LLM when and how to call function;  the second one contains the actual code to execute.</p>"},{"location":"quickstart/writing-tool/#creating-the-tool","title":"Creating the Tool","text":"<p>Now, let\u2019s get down to business. A real socks sales representative offers a quantity of socks, with many colors and corresponding price. Let\u2019s say a customer wants to know the price for socks of a specific color. We could write a tool to answer the question. Therefore, copy and past this source code inside the file <code>poetic_sock_seller.py</code>:</p> <pre><code>from cat.mad_hatter.decorators import tool\n\n@tool\ndef socks_prices(color, cat):\n    \"\"\"How much do socks cost? Input is the sock color.\"\"\"\n    prices = {\n        \"black\": 5,\n        \"white\": 10,\n        \"pink\": 50,\n    }\n    if color not in prices.keys():\n        return f\"No {color} socks\"\n    else:\n        return f\"{prices[color]} \u20ac\" \n</code></pre>"},{"location":"quickstart/writing-tool/#testing-the-tool","title":"Testing the Tool","text":"<p>Now, let\u2019s ask for our favorite socks color:</p> <p></p>"},{"location":"quickstart/writing-tool/#why-the-response","title":"Why the response?","text":"<p>By clicking on the question mark next to the answer, you can understand what prompted the Cat to provide the response. In this case, you can see that our tool \"socks_prices\" was used:</p> <p></p>"},{"location":"quickstart/writing-tool/#explaining-the-code-step-by-step","title":"Explaining the code step by step","text":"<pre><code>from cat.mad_hatter.decorators import tool\n</code></pre> <p>Let\u2019s import the tool decorator from the Cat.  If you don\u2019t know what decorators are in coding, don\u2019t worry: they will help us attach our python functions to the Cat. The <code>mad_hatter</code> is the Cat component that manages and runs plugins.</p> <pre><code>@tool\ndef socks_prices(color, cat):\n    \"\"\"How much do socks cost? Input is the sock color.\"\"\"\n</code></pre> <p>We define a function called \"socks_prices,\" which takes as input the color of the desired socks and a cat instance.</p> <p>The <code>@tool()</code> decorator has the main function of letting the Cat know that the following function is a tool.</p> <p>The docstring just after the function signature reads as follows:</p> <p>\"How much do socks cost? Input is the sock color.\"</p> <p>This description instructs the LLM on when to call this tool and describes what input to provide.</p> <p>Going back to the tool actual code:</p> <pre><code>    prices = {\n        \"black\": 5,\n        \"white\": 10,\n        \"pink\": 50,\n    }\n\n    if color not in prices.keys():\n        return f\"No {color} socks\"\n    else:\n        return f\"{prices[color]} \u20ac\" \n</code></pre> <p>Not much to say here: we just check if the color is present in the dictionary and output the price. What is indeed interesting is that, in a tool, you can connect your AI to any service, database, file, device, or whatever you need. Imagine turning on and off the light in your room, searching an e-commerce or writing an email. The only limit is your fantasy \ud83d\ude00.</p>"},{"location":"quickstart/writing-tool/#watchfiles-detected-changes-reloading","title":"WatchFiles detected changes... reloading...","text":"<p>When changes to the plugin's source code are detected, the Cat automatically restarts. Feel free to make changes within the code and observe the results.</p>"},{"location":"quickstart/writing-tool/#debugging","title":"Debugging","text":"<p>Sometimes debugging can be necessary. Please refer to the <code>Developers -&gt; Debugging</code> section for more information.</p>"},{"location":"quickstart/writing-tool/#more-info","title":"More Info","text":"<p>Developers \u2192 Plugins Reference \u2192 Tools</p>"},{"location":"quickstart/writing-tool/#next-step","title":"Next Step","text":"<p>In the next step, you will learn how to create your first <code>Hook</code>.</p>"},{"location":"resources/events/","title":"\ud83e\uddd1 Events","text":""},{"location":"resources/tutorials/","title":"&#129489; Tutorials","text":""},{"location":"resources/tutorials/#tutorials","title":"\ud83e\uddd1 Tutorials","text":"<p>You can find several tutorials both on our blog and in the newsletter (SUBSCRIBE IT!). </p>"},{"location":"resources/video-installation/","title":"&#129489; Installation &amp; Customization","text":""},{"location":"resources/video-installation/#installation-customization","title":"\ud83e\uddd1 Installation &amp; Customization","text":"<p>Watch it on YouTube</p>"},{"location":"technical/how-the-cat-works/","title":"&#128572; Components","text":""},{"location":"technical/how-the-cat-works/#components","title":"\ud83d\ude3c Components","text":"<p>The Cheshire Cat is made of many pluggable components that make it fully customizable.</p> \ud83d\udcac <code>Chat</code> This is the Graphical User Interface (GUI) component that allows you to interact directly with the Cat. From the GUI, you can also set the language model you want the Cat to run. \ud83d\udc30 <code>Rabbit Hole</code> This component handles the ingestion of documents. Files that are sent down the Rabbit Hole are split into chunks and saved in the Cat's declarative memory to be further retrieved in the conversation.  \ud83e\udde0 <code>Large Language Model (LLM)</code> This is one of the core components of the Cheshire Cat framework. A LLM is a Deep Learning model that's been trained on a huge volume of text data and can perform many types of language tasks. The model takes a text string as input (e.g. the user's prompt) and provides a meaningful answer. The answer consistency and adequacy is enriched with the context of previous conversations and documents uploaded in the Cat's memory. \ud83e\uddec <code>Embedder</code> The embedder is another Deep Learning model similar to the LLM. Differently, it doesn't perform language tasks. The model takes a text string as input and encodes it in a numerical representation. This operation allows to represent textual data as vectors and perform geometrical operation on them. For instance, given an input, the embedder is used to retrieve similar sentences from the Cat's memory. \ud83d\udc18 <code>Vector Memory</code> As a result of the Embedder encoding, we get a set of vectors that are used to store the Cat's memory in a vector database. Memories store not only the vector representation of the input, but also the time instant and personalized metadata to facilitate and enhance the information retrieval. The Cat embeds two types of vector memories, namely the episodic and declarative memories. The formers are the things the human said in the past; the latter the documents sent down the Rabbit hole.   \ud83e\udd16 <code>Agent</code> This is another core component of the Cheshire Cat framework. The agent orchestrates the calls that are made to the LLM. This component allows the Cat to decide which action to take according to the input the user provides. Possible actions range from holding the conversation to executing complex tasks, chaining predefined or custom tools. \ud83e\udde9 <code>Plugins</code> These are functions to extend the Cat's capabilities. Plugins are a set of tools and hooks that allow the Agent to achieve complex goals. This component let the Cat assists you with tailored needs."},{"location":"technical/how-the-cat-works/#main-loop","title":"Main loop","text":""},{"location":"technical/how-the-cat-works/#retrieval-augmented-generation-docs-qa","title":"Retrieval augmented Generation (docs Q&amp;A)","text":""},{"location":"technical/API_Documentation/SUMMARY/","title":"SUMMARY","text":"<ul> <li>factory<ul> <li>ollama_utils</li> </ul> </li> <li>log</li> <li>looking_glass<ul> <li>cheshire_cat</li> <li>stray_cat</li> </ul> </li> <li>mad_hatter<ul> <li>core_plugin<ul> <li>hooks<ul> <li>agent</li> <li>flow</li> <li>prompt</li> <li>rabbithole</li> </ul> </li> </ul> </li> <li>mad_hatter</li> <li>plugin</li> </ul> </li> <li>memory<ul> <li>vector_memory</li> <li>vector_memory_collection</li> <li>working_memory</li> </ul> </li> <li>rabbit_hole</li> <li>routes<ul> <li>settings</li> </ul> </li> <li>utils</li> </ul>"},{"location":"technical/API_Documentation/log/","title":"log","text":"<p>The log engine.</p>"},{"location":"technical/API_Documentation/log/#cat.log.CatLogEngine","title":"<code>CatLogEngine</code>","text":"<p>The log engine.</p> <p>Engine to filter the logs in the terminal according to the level of severity.</p> <p>Attributes:</p> Name Type Description <code>LOG_LEVEL</code> <code>str</code> <p>Level of logging set in the <code>.env</code> file.</p> Notes <p>The logging level set in the <code>.env</code> file will print all the logs from that level to above. Available levels are:</p> <pre><code>- `DEBUG`\n- `INFO`\n- `WARNING`\n- `ERROR`\n- `CRITICAL`\n</code></pre> <p>Default to <code>INFO</code>.</p> Source code in <code>cat/log.py</code> <pre><code>class CatLogEngine:\n    \"\"\"The log engine.\n\n    Engine to filter the logs in the terminal according to the level of severity.\n\n    Attributes\n    ----------\n    LOG_LEVEL : str\n        Level of logging set in the `.env` file.\n\n    Notes\n    -----\n    The logging level set in the `.env` file will print all the logs from that level to above.\n    Available levels are:\n\n        - `DEBUG`\n        - `INFO`\n        - `WARNING`\n        - `ERROR`\n        - `CRITICAL`\n\n    Default to `INFO`.\n\n    \"\"\"\n\n    def __init__(self):\n        self.LOG_LEVEL = get_log_level()\n        self.default_log()\n\n        # workaround for pdfminer logging\n        # https://github.com/pdfminer/pdfminer.six/issues/347\n        logging.getLogger(\"pdfminer\").setLevel(logging.WARNING)\n\n    def show_log_level(self, record):\n        \"\"\"Allows to show stuff in the log based on the global setting.\n\n        Parameters\n        ----------\n        record : dict\n\n        Returns\n        -------\n        bool\n\n        \"\"\"\n        return record[\"level\"].no &gt;= logger.level(self.LOG_LEVEL).no\n\n    def default_log(self):\n        \"\"\"Set the same debug level to all the project dependencies.\n\n        Returns\n        -------\n        \"\"\"\n\n        time = \"&lt;green&gt;[{time:YYYY-MM-DD HH:mm:ss.SSS}]&lt;/green&gt;\"\n        level = \"&lt;level&gt;{level: &lt;6}&lt;/level&gt;\"\n        origin = \"&lt;level&gt;{extra[original_name]}.{extra[original_class]}.{extra[original_caller]}::{extra[original_line]}&lt;/level&gt;\"\n        message = \"&lt;level&gt;{message}&lt;/level&gt;\"\n        log_format = f\"{time} {level} {origin} \\n{message}\"\n\n        logger.remove()\n        if self.LOG_LEVEL == \"DEBUG\":\n            return logger.add(\n                sys.stdout,\n                colorize=True,\n                format=log_format,\n                backtrace=True,\n                diagnose=True,\n                filter=self.show_log_level\n            )\n        else:\n            return logger.add(\n                sys.stdout,\n                colorize=True,\n                format=log_format,\n                filter=self.show_log_level,\n                level=self.LOG_LEVEL\n            )\n\n    def get_caller_info(self, skip=3):\n        \"\"\"Get the name of a caller in the format module.class.method.\n\n        Copied from: https://gist.github.com/techtonik/2151727\n\n        Parameters\n        ----------\n        skip :  int\n            Specifies how many levels of stack to skip while getting caller name.\n\n        Returns\n        -------\n        package : str\n            Caller package.\n        module : str\n            Caller module.\n        klass : str\n            Caller classname if one otherwise None.\n        caller : str\n            Caller function or method (if a class exist).\n        line : int\n            The line of the call.\n\n\n        Notes\n        -----\n        skip=1 means \"who calls me\",\n        skip=2 \"who calls my caller\" etc.\n\n        An empty string is returned if skipped levels exceed stack height.\n        \"\"\"\n        stack = inspect.stack()\n        start = 0 + skip\n        if len(stack) &lt; start + 1:\n            return \"\"\n        parentframe = stack[start][0]\n\n        # module and packagename.\n        module_info = inspect.getmodule(parentframe)\n        if module_info:\n            mod = module_info.__name__.split(\".\")\n            package = mod[0]\n            module = \".\".join(mod[1:])\n\n        # class name.\n        klass = \"\"\n        if \"self\" in parentframe.f_locals:\n            klass = parentframe.f_locals[\"self\"].__class__.__name__\n\n        # method or function name.\n        caller = None\n        if parentframe.f_code.co_name != \"&lt;module&gt;\":  # top level usually\n            caller = parentframe.f_code.co_name\n\n        # call line.\n        line = parentframe.f_lineno\n\n        # Remove reference to frame\n        # See: https://docs.python.org/3/library/inspect.html#the-interpreter-stack\n        del parentframe\n\n        return package, module, klass, caller, line\n\n    def __call__(self, msg, level=\"DEBUG\"):\n        \"\"\"Alias of self.log()\"\"\"\n        self.log(msg, level)\n\n    def debug(self, msg):\n        \"\"\"Logs a DEBUG message\"\"\"\n        self.log(msg, level=\"DEBUG\")\n\n    def info(self, msg):\n        \"\"\"Logs an INFO message\"\"\"\n        self.log(msg, level=\"INFO\")\n\n    def warning(self, msg):\n        \"\"\"Logs a WARNING message\"\"\"\n        self.log(msg, level=\"WARNING\")\n\n    def error(self, msg):\n        \"\"\"Logs an ERROR message\"\"\"\n        self.log(msg, level=\"ERROR\")\n\n    def critical(self, msg):\n        \"\"\"Logs a CRITICAL message\"\"\"\n        self.log(msg, level=\"CRITICAL\")\n\n    def log(self, msg, level=\"DEBUG\"):\n        \"\"\"Log a message\n\n        Parameters\n        ----------\n        msg :\n            Message to be logged.\n        level : str\n            Logging level.\"\"\"\n\n        (package, module, klass, caller, line) = self.get_caller_info()\n\n        custom_logger = logger.bind(\n            original_name=f\"{package}.{module}\",\n            original_line=line,\n            original_class=klass,\n            original_caller=caller,\n        )\n\n        # prettify\n        if type(msg) in [dict, list, str]: # TODO: should be recursive\n            try:\n                msg = json.dumps(msg, indent=4)\n            except:\n                pass\n        else:\n            msg = pformat(msg)\n\n        # actual log\n        custom_logger.log(level, msg)\n\n    def welcome(self):\n        \"\"\"Welcome message in the terminal.\"\"\"\n        secure = os.getenv('CORE_USE_SECURE_PROTOCOLS', '')\n        if secure != '':\n            secure = 's'\n\n        cat_host = os.getenv(\"CORE_HOST\", \"localhost\")\n        cat_port = os.getenv(\"CORE_PORT\", \"1865\")\n        cat_address = f'http{secure}://{cat_host}:{cat_port}'\n\n        with open(\"cat/welcome.txt\", 'r') as f:\n            print(f.read())\n\n        print('\\n=============== ^._.^ ===============\\n')\n        print(f'Cat REST API:   {cat_address}/docs')\n        print(f'Cat PUBLIC:     {cat_address}/public')\n        print(f'Cat ADMIN:      {cat_address}/admin\\n')\n        print('======================================')\n</code></pre>"},{"location":"technical/API_Documentation/log/#cat.log.CatLogEngine.__call__","title":"<code>__call__(msg, level='DEBUG')</code>","text":"<p>Alias of self.log()</p> Source code in <code>cat/log.py</code> <pre><code>def __call__(self, msg, level=\"DEBUG\"):\n    \"\"\"Alias of self.log()\"\"\"\n    self.log(msg, level)\n</code></pre>"},{"location":"technical/API_Documentation/log/#cat.log.CatLogEngine.critical","title":"<code>critical(msg)</code>","text":"<p>Logs a CRITICAL message</p> Source code in <code>cat/log.py</code> <pre><code>def critical(self, msg):\n    \"\"\"Logs a CRITICAL message\"\"\"\n    self.log(msg, level=\"CRITICAL\")\n</code></pre>"},{"location":"technical/API_Documentation/log/#cat.log.CatLogEngine.debug","title":"<code>debug(msg)</code>","text":"<p>Logs a DEBUG message</p> Source code in <code>cat/log.py</code> <pre><code>def debug(self, msg):\n    \"\"\"Logs a DEBUG message\"\"\"\n    self.log(msg, level=\"DEBUG\")\n</code></pre>"},{"location":"technical/API_Documentation/log/#cat.log.CatLogEngine.default_log","title":"<code>default_log()</code>","text":"<p>Set the same debug level to all the project dependencies.</p> Source code in <code>cat/log.py</code> <pre><code>def default_log(self):\n    \"\"\"Set the same debug level to all the project dependencies.\n\n    Returns\n    -------\n    \"\"\"\n\n    time = \"&lt;green&gt;[{time:YYYY-MM-DD HH:mm:ss.SSS}]&lt;/green&gt;\"\n    level = \"&lt;level&gt;{level: &lt;6}&lt;/level&gt;\"\n    origin = \"&lt;level&gt;{extra[original_name]}.{extra[original_class]}.{extra[original_caller]}::{extra[original_line]}&lt;/level&gt;\"\n    message = \"&lt;level&gt;{message}&lt;/level&gt;\"\n    log_format = f\"{time} {level} {origin} \\n{message}\"\n\n    logger.remove()\n    if self.LOG_LEVEL == \"DEBUG\":\n        return logger.add(\n            sys.stdout,\n            colorize=True,\n            format=log_format,\n            backtrace=True,\n            diagnose=True,\n            filter=self.show_log_level\n        )\n    else:\n        return logger.add(\n            sys.stdout,\n            colorize=True,\n            format=log_format,\n            filter=self.show_log_level,\n            level=self.LOG_LEVEL\n        )\n</code></pre>"},{"location":"technical/API_Documentation/log/#cat.log.CatLogEngine.error","title":"<code>error(msg)</code>","text":"<p>Logs an ERROR message</p> Source code in <code>cat/log.py</code> <pre><code>def error(self, msg):\n    \"\"\"Logs an ERROR message\"\"\"\n    self.log(msg, level=\"ERROR\")\n</code></pre>"},{"location":"technical/API_Documentation/log/#cat.log.CatLogEngine.get_caller_info","title":"<code>get_caller_info(skip=3)</code>","text":"<p>Get the name of a caller in the format module.class.method.</p> <p>Copied from: https://gist.github.com/techtonik/2151727</p> <p>Parameters:</p> Name Type Description Default <code>skip</code> <code> int</code> <p>Specifies how many levels of stack to skip while getting caller name.</p> <code>3</code> <p>Returns:</p> Name Type Description <code>package</code> <code>str</code> <p>Caller package.</p> <code>module</code> <code>str</code> <p>Caller module.</p> <code>klass</code> <code>str</code> <p>Caller classname if one otherwise None.</p> <code>caller</code> <code>str</code> <p>Caller function or method (if a class exist).</p> <code>line</code> <code>int</code> <p>The line of the call.</p> Notes <p>skip=1 means \"who calls me\", skip=2 \"who calls my caller\" etc.</p> <p>An empty string is returned if skipped levels exceed stack height.</p> Source code in <code>cat/log.py</code> <pre><code>def get_caller_info(self, skip=3):\n    \"\"\"Get the name of a caller in the format module.class.method.\n\n    Copied from: https://gist.github.com/techtonik/2151727\n\n    Parameters\n    ----------\n    skip :  int\n        Specifies how many levels of stack to skip while getting caller name.\n\n    Returns\n    -------\n    package : str\n        Caller package.\n    module : str\n        Caller module.\n    klass : str\n        Caller classname if one otherwise None.\n    caller : str\n        Caller function or method (if a class exist).\n    line : int\n        The line of the call.\n\n\n    Notes\n    -----\n    skip=1 means \"who calls me\",\n    skip=2 \"who calls my caller\" etc.\n\n    An empty string is returned if skipped levels exceed stack height.\n    \"\"\"\n    stack = inspect.stack()\n    start = 0 + skip\n    if len(stack) &lt; start + 1:\n        return \"\"\n    parentframe = stack[start][0]\n\n    # module and packagename.\n    module_info = inspect.getmodule(parentframe)\n    if module_info:\n        mod = module_info.__name__.split(\".\")\n        package = mod[0]\n        module = \".\".join(mod[1:])\n\n    # class name.\n    klass = \"\"\n    if \"self\" in parentframe.f_locals:\n        klass = parentframe.f_locals[\"self\"].__class__.__name__\n\n    # method or function name.\n    caller = None\n    if parentframe.f_code.co_name != \"&lt;module&gt;\":  # top level usually\n        caller = parentframe.f_code.co_name\n\n    # call line.\n    line = parentframe.f_lineno\n\n    # Remove reference to frame\n    # See: https://docs.python.org/3/library/inspect.html#the-interpreter-stack\n    del parentframe\n\n    return package, module, klass, caller, line\n</code></pre>"},{"location":"technical/API_Documentation/log/#cat.log.CatLogEngine.info","title":"<code>info(msg)</code>","text":"<p>Logs an INFO message</p> Source code in <code>cat/log.py</code> <pre><code>def info(self, msg):\n    \"\"\"Logs an INFO message\"\"\"\n    self.log(msg, level=\"INFO\")\n</code></pre>"},{"location":"technical/API_Documentation/log/#cat.log.CatLogEngine.log","title":"<code>log(msg, level='DEBUG')</code>","text":"<p>Log a message</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <p>Message to be logged.</p> required <code>level</code> <code>str</code> <p>Logging level.</p> <code>'DEBUG'</code> Source code in <code>cat/log.py</code> <pre><code>def log(self, msg, level=\"DEBUG\"):\n    \"\"\"Log a message\n\n    Parameters\n    ----------\n    msg :\n        Message to be logged.\n    level : str\n        Logging level.\"\"\"\n\n    (package, module, klass, caller, line) = self.get_caller_info()\n\n    custom_logger = logger.bind(\n        original_name=f\"{package}.{module}\",\n        original_line=line,\n        original_class=klass,\n        original_caller=caller,\n    )\n\n    # prettify\n    if type(msg) in [dict, list, str]: # TODO: should be recursive\n        try:\n            msg = json.dumps(msg, indent=4)\n        except:\n            pass\n    else:\n        msg = pformat(msg)\n\n    # actual log\n    custom_logger.log(level, msg)\n</code></pre>"},{"location":"technical/API_Documentation/log/#cat.log.CatLogEngine.show_log_level","title":"<code>show_log_level(record)</code>","text":"<p>Allows to show stuff in the log based on the global setting.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>dict</code> required <p>Returns:</p> Type Description <code>bool</code> Source code in <code>cat/log.py</code> <pre><code>def show_log_level(self, record):\n    \"\"\"Allows to show stuff in the log based on the global setting.\n\n    Parameters\n    ----------\n    record : dict\n\n    Returns\n    -------\n    bool\n\n    \"\"\"\n    return record[\"level\"].no &gt;= logger.level(self.LOG_LEVEL).no\n</code></pre>"},{"location":"technical/API_Documentation/log/#cat.log.CatLogEngine.warning","title":"<code>warning(msg)</code>","text":"<p>Logs a WARNING message</p> Source code in <code>cat/log.py</code> <pre><code>def warning(self, msg):\n    \"\"\"Logs a WARNING message\"\"\"\n    self.log(msg, level=\"WARNING\")\n</code></pre>"},{"location":"technical/API_Documentation/log/#cat.log.CatLogEngine.welcome","title":"<code>welcome()</code>","text":"<p>Welcome message in the terminal.</p> Source code in <code>cat/log.py</code> <pre><code>def welcome(self):\n    \"\"\"Welcome message in the terminal.\"\"\"\n    secure = os.getenv('CORE_USE_SECURE_PROTOCOLS', '')\n    if secure != '':\n        secure = 's'\n\n    cat_host = os.getenv(\"CORE_HOST\", \"localhost\")\n    cat_port = os.getenv(\"CORE_PORT\", \"1865\")\n    cat_address = f'http{secure}://{cat_host}:{cat_port}'\n\n    with open(\"cat/welcome.txt\", 'r') as f:\n        print(f.read())\n\n    print('\\n=============== ^._.^ ===============\\n')\n    print(f'Cat REST API:   {cat_address}/docs')\n    print(f'Cat PUBLIC:     {cat_address}/public')\n    print(f'Cat ADMIN:      {cat_address}/admin\\n')\n    print('======================================')\n</code></pre>"},{"location":"technical/API_Documentation/log/#cat.log.get_log_level","title":"<code>get_log_level()</code>","text":"<p>Return the global LOG level.</p> Source code in <code>cat/log.py</code> <pre><code>def get_log_level():\n    \"\"\"Return the global LOG level.\"\"\"\n    return os.getenv(\"LOG_LEVEL\", \"INFO\")\n</code></pre>"},{"location":"technical/API_Documentation/rabbit_hole/","title":"rabbit_hole","text":""},{"location":"technical/API_Documentation/rabbit_hole/#cat.rabbit_hole.RabbitHole","title":"<code>RabbitHole</code>","text":"<p>Manages content ingestion. I'm late... I'm late!</p> Source code in <code>cat/rabbit_hole.py</code> <pre><code>@singleton\nclass RabbitHole:\n    \"\"\"Manages content ingestion. I'm late... I'm late!\"\"\"\n    def __init__(self, cat) -&gt; None:\n        self.__cat = cat\n\n    # each time we access the file handlers, plugins can intervene\n    def __reload_file_handlers(self):\n\n        # default file handlers\n        self.__file_handlers = {\n            \"application/pdf\": PDFMinerParser(),\n            \"text/plain\": TextParser(),\n            \"text/markdown\": TextParser(),\n            \"text/html\": BS4HTMLParser()\n        }\n\n        # no access to stray\n        self.__file_handlers = self.__cat.mad_hatter.execute_hook(\"rabbithole_instantiates_parsers\", self.__file_handlers, cat=self.__cat)\n\n    def __reload_text_splitter(self):\n\n        # default text splitter\n        self.__text_splitter = RecursiveCharacterTextSplitter.from_tiktoken_encoder(\n            chunk_size=256,\n            chunk_overlap=64,\n            separators = [\"\\\\n\\\\n\", \"\\n\\n\", \".\\\\n\", \".\\n\", \"\\\\n\", \"\\n\", \" \", \"\"],\n            encoding_name = \"cl100k_base\",\n            keep_separator = True,\n            strip_whitespace = True\n        )\n\n        # no access to stray\n        self.__text_splitter = self.__cat.mad_hatter.execute_hook(\"rabbithole_instantiates_splitter\", self.__text_splitter, cat=self.__cat)\n\n    def ingest_memory(self, stray, file: UploadFile):\n        \"\"\"Upload memories to the declarative memory from a JSON file.\n\n        Parameters\n        ----------\n        file : UploadFile\n            File object sent via `rabbithole/memory` hook.\n\n        Notes\n        -----\n        This method allows uploading a JSON file containing vector and text memories directly to the declarative memory.\n        When doing this, please, make sure the embedder used to export the memories is the same as the one used\n        when uploading.\n        The method also performs a check on the dimensionality of the embeddings (i.e. length of each vector).\n\n        \"\"\"\n\n        # Get file bytes\n        file_bytes = file.file.read()\n\n        # Load fyle byte in a dict\n        memories = json.loads(file_bytes.decode(\"utf-8\"))\n\n        # Check the embedder used for the uploaded memories is the same the Cat is using now\n        upload_embedder = memories[\"embedder\"]\n        cat_embedder = str(stray.embedder.__class__.__name__)\n\n        if upload_embedder != cat_embedder:\n            message = f'Embedder mismatch: file embedder {upload_embedder} is different from {cat_embedder}'\n            raise Exception(message)\n\n        # Get Declarative memories in file\n        declarative_memories = memories[\"collections\"][\"declarative\"]\n\n        # Store data to upload the memories in batch\n        ids = [i[\"id\"] for i in declarative_memories]\n        payloads = [{\n            \"page_content\": p[\"page_content\"],\n            \"metadata\": p[\"metadata\"]\n        } for p in declarative_memories]\n        vectors = [v[\"vector\"] for v in declarative_memories]\n\n        log.info(f\"Preparing to load {len(vectors)} vector memories\")\n\n        # Check embedding size is correct\n        embedder_size = stray.memory.vectors.declarative.embedder_size\n        len_mismatch = [len(v) == embedder_size for v in vectors]\n\n        if not any(len_mismatch):\n            message = f'Embedding size mismatch: vectors length should be {embedder_size}'\n            raise Exception(message)\n\n        # Upsert memories in batch mode # TODO REFACTOR: use VectorMemoryCollection.add_point\n        stray.memory.vectors.vector_db.upsert(\n            collection_name=\"declarative\",\n            points=models.Batch(\n                ids=ids,\n                payloads=payloads,\n                vectors=vectors\n            )\n        )\n\n    def ingest_file(\n            self,\n            stray,\n            file: Union[str, UploadFile],\n            chunk_size: int | None = None,\n            chunk_overlap: int | None = None,\n    ):\n        \"\"\"Load a file in the Cat's declarative memory.\n\n        The method splits and converts the file in Langchain `Document`. Then, it stores the `Document` in the Cat's\n        memory.\n\n        Parameters\n        ----------\n        file : str, UploadFile\n            The file can be a path passed as a string or an `UploadFile` object if the document is ingested using the\n            `rabbithole` endpoint.\n        chunk_size : int\n            Number of tokens in each document chunk.\n        chunk_overlap : int\n            Number of overlapping tokens between consecutive chunks.\n\n        Notes\n        ----------\n        Currently supported formats are `.txt`, `.pdf` and `.md`.\n\n        See Also\n        ----------\n        before_rabbithole_stores_documents\n        \"\"\"\n\n        # split file into a list of docs\n        docs = self.file_to_docs(\n            stray=stray,\n            file=file, \n            chunk_size=chunk_size, \n            chunk_overlap=chunk_overlap\n        )\n\n        # store in memory\n        if isinstance(file, str):\n            filename = file\n        else:\n            filename = file.filename\n\n        self.store_documents(\n            stray=stray,\n            docs=docs, \n            source=filename \n        )\n\n    def file_to_docs(\n            self,\n            stray,\n            file: Union[str, UploadFile],\n            chunk_size: int | None = None,\n            chunk_overlap: int | None = None,\n    ) -&gt; List[Document]:\n        \"\"\"Load and convert files to Langchain `Document`.\n\n        This method takes a file either from a Python script, from the `/rabbithole/` or `/rabbithole/web` endpoints.\n        Hence, it loads it in memory and splits it in overlapped chunks of text.\n\n        Parameters\n        ----------\n        file : str, UploadFile\n            The file can be either a string path if loaded programmatically, a FastAPI `UploadFile`\n            if coming from the `/rabbithole/` endpoint or a URL if coming from the `/rabbithole/web` endpoint.\n        chunk_size : int\n            Number of tokens in each document chunk.\n        chunk_overlap : int\n            Number of overlapping tokens between consecutive chunks.\n\n        Returns\n        -------\n        docs : List[Document]\n            List of Langchain `Document` of chunked text.\n\n        Notes\n        -----\n        This method is used by both `/rabbithole/` and `/rabbithole/web` endpoints.\n        Currently supported files are `.txt`, `.pdf`, `.md` and web pages.\n\n        \"\"\"\n\n        # Check type of incoming file.\n        if isinstance(file, UploadFile):\n            # Get mime type and source of UploadFile\n            content_type = mimetypes.guess_type(file.filename)[0]\n            source = file.filename\n\n            # Get file bytes\n            file_bytes = file.file.read()\n        elif isinstance(file, str):\n            # Check if string file is a string or url\n            parsed_file = urlparse(file)\n            is_url = all([parsed_file.scheme, parsed_file.netloc])\n\n            if is_url:\n                # Make a request with a fake browser name\n                request = httpx.get(file, headers={\"User-Agent\": \"Magic Browser\"})\n\n                # Define mime type and source of url\n                content_type = request.headers[\"Content-Type\"].split(\";\")[0]\n                source = file\n\n                try:\n                    # Get binary content of url\n                    file_bytes = request.content\n                except HTTPError as e:\n                    log.error(e)\n            else:\n                # Get mime type from file extension and source\n                content_type = mimetypes.guess_type(file)[0]\n                source = os.path.basename(file)\n\n                # Get file bytes\n                with open(file, \"rb\") as f:\n                    file_bytes = f.read()\n        else:\n            raise ValueError(f\"{type(file)} is not a valid type.\")\n        return self.string_to_docs(\n            stray=stray,\n            file_bytes=file_bytes,\n            source=source,\n            content_type=content_type,\n            chunk_size=chunk_size,\n            chunk_overlap=chunk_overlap\n        )\n\n\n    def string_to_docs(\n            self,\n            stray,\n            file_bytes: str,\n            source: str = None,\n            content_type: str = \"text/plain\",\n            chunk_size: int | None = None,\n            chunk_overlap: int | None = None,\n        ) -&gt; List[Document]:\n        \"\"\"Convert string to Langchain `Document`.\n\n        Takes a string, converts it to langchain `Document`.\n        Hence, loads it in memory and splits it in overlapped chunks of text.\n\n        Parameters\n        ----------\n        file_bytes : str\n            The string to be converted.\n        source: str\n            Source filename.\n        content_type:\n            Mimetype of content.\n        chunk_size : int\n            Number of tokens in each document chunk.\n        chunk_overlap : int\n            Number of overlapping tokens between consecutive chunks.\n        send_message: bool\n            If true will send parsing message information to frontend.\n\n        Returns\n        -------\n        docs : List[Document]\n            List of Langchain `Document` of chunked text.\n        \"\"\"\n\n        # Load the bytes in the Blob schema\n        blob = Blob(data=file_bytes,\n                    mimetype=content_type,\n                    source=source).from_data(data=file_bytes,\n                                             mime_type=content_type,\n                                             path=source)\n        # Parser based on the mime type\n        parser = MimeTypeBasedParser(handlers=self.file_handlers)\n\n        # Parse the text\n        stray.send_ws_message(\"I'm parsing the content. Big content could require some minutes...\")\n        super_docs = parser.parse(blob)\n\n        # Split\n        stray.send_ws_message(\"Parsing completed. Now let's go with reading process...\")\n        docs = self.__split_text(\n            stray=stray,\n            text=super_docs,\n            chunk_size=chunk_size,\n            chunk_overlap=chunk_overlap\n        )\n        return docs\n\n\n    def store_documents(self, stray, docs: List[Document], source: str) -&gt; None:\n        \"\"\"Add documents to the Cat's declarative memory.\n\n        This method loops a list of Langchain `Document` and adds some metadata. Namely, the source filename and the\n        timestamp of insertion. Once done, the method notifies the client via Websocket connection.\n\n        Parameters\n        ----------\n        docs : List[Document]\n            List of Langchain `Document` to be inserted in the Cat's declarative memory.\n        source : str\n            Source name to be added as a metadata. It can be a file name or an URL.\n\n        Notes\n        -------\n        At this point, it is possible to customize the Cat's behavior using the `before_rabbithole_insert_memory` hook\n        to edit the memories before they are inserted in the vector database.\n\n        See Also\n        --------\n        before_rabbithole_insert_memory\n        \"\"\"\n\n        log.info(f\"Preparing to memorize {len(docs)} vectors\")\n\n        # hook the docs before they are stored in the vector memory\n        docs = stray.mad_hatter.execute_hook(\n            \"before_rabbithole_stores_documents\", docs, cat=stray\n        )\n\n        # classic embed\n        time_last_notification = time.time()\n        time_interval = 10  # a notification every 10 secs\n        stored_points = []\n        for d, doc in enumerate(docs):\n            if time.time() - time_last_notification &gt; time_interval:\n                time_last_notification = time.time()\n                perc_read = int(d / len(docs) * 100)\n                read_message = f\"Read {perc_read}% of {source}\"\n                stray.send_ws_message(read_message)\n                log.warning(read_message)\n\n            doc.metadata[\"source\"] = source\n            doc.metadata[\"when\"] = time.time()\n            doc = stray.mad_hatter.execute_hook(\n                \"before_rabbithole_insert_memory\", doc, cat=stray\n            )\n            inserting_info = f\"{d + 1}/{len(docs)}):    {doc.page_content}\"\n            if doc.page_content != \"\":\n                doc_embedding = stray.embedder.embed_documents([doc.page_content])\n                stored_point = stray.memory.vectors.declarative.add_point(\n                    doc.page_content,\n                    doc_embedding[0],\n                    doc.metadata,\n                )\n                stored_points.append(stored_point)\n\n                log.info(f\"Inserted into memory ({inserting_info})\")\n            else:\n                log.info(f\"Skipped memory insertion of empty doc ({inserting_info})\")\n\n            # wait a little to avoid APIs rate limit errors\n            time.sleep(0.05)\n\n        # hook the points after they are stored in the vector memory\n        stray.mad_hatter.execute_hook(\n            \"after_rabbithole_stored_documents\", source, stored_points, cat=stray\n        )\n\n        # notify client\n        finished_reading_message = \\\n            f\"Finished reading {source}, I made {len(docs)} thoughts on it.\"\n\n        stray.send_ws_message(finished_reading_message)\n\n        log.warning(f\"Done uploading {source}\")\n\n\n    def __split_text(self, stray, text, chunk_size, chunk_overlap):\n        \"\"\"Split text in overlapped chunks.\n\n        This method executes the `rabbithole_splits_text` to split the incoming text in overlapped\n        chunks of text. Other two hooks are available to edit the text before and after the split step.\n\n        Parameters\n        ----------\n        text : str\n            Content of the loaded file.\n        chunk_size : int\n            Number of tokens in each document chunk.\n        chunk_overlap : int\n            Number of overlapping tokens between consecutive chunks.\n\n        Returns\n        -------\n        docs : List[Document]\n            List of split Langchain `Document`.\n\n        Notes\n        -----\n        The default behavior only executes the `rabbithole_splits_text` hook. `before_rabbithole_splits_text` and\n        `after_rabbithole_splitted_text` hooks return the original input without any modification.\n\n        See Also\n        --------\n        before_rabbithole_splits_text\n        rabbithole_splits_text\n        after_rabbithole_splitted_text\n\n        \"\"\"\n        # do something on the text before it is split\n        text = stray.mad_hatter.execute_hook(\"before_rabbithole_splits_text\", text, cat=stray)\n\n        # hooks decide the test splitter (see @property .text_splitter)\n        text_splitter = self.text_splitter\n\n        # override chunk_size and chunk_overlap only if the request has those info\n        if chunk_size:\n            text_splitter._chunk_size = chunk_size\n        if chunk_overlap:\n            text_splitter._chunk_overlap = chunk_overlap\n\n        log.info(f\"Chunk size: {chunk_size}, chunk overlap: {chunk_overlap}\")\n        # split text\n        docs = text_splitter.split_documents(text)\n        # remove short texts (page numbers, isolated words, etc.)\n        # TODO: join each short chunk with previous one, instead of deleting them\n        docs = list(filter(lambda d: len(d.page_content) &gt; 10, docs))\n\n        # do something on the text after it is split\n        docs = stray.mad_hatter.execute_hook(\"after_rabbithole_splitted_text\", docs, cat=stray)\n\n        return docs\n\n    # each time we access the file handlers, plugins can intervene\n    @property\n    def file_handlers(self):\n        self.__reload_file_handlers()\n        return self.__file_handlers\n\n    # each time we access the text splitter, plugins can intervene\n    @property\n    def text_splitter(self):\n        self.__reload_text_splitter()\n        return self.__text_splitter\n</code></pre>"},{"location":"technical/API_Documentation/rabbit_hole/#cat.rabbit_hole.RabbitHole.__split_text","title":"<code>__split_text(stray, text, chunk_size, chunk_overlap)</code>","text":"<p>Split text in overlapped chunks.</p> <p>This method executes the <code>rabbithole_splits_text</code> to split the incoming text in overlapped chunks of text. Other two hooks are available to edit the text before and after the split step.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Content of the loaded file.</p> required <code>chunk_size</code> <code>int</code> <p>Number of tokens in each document chunk.</p> required <code>chunk_overlap</code> <code>int</code> <p>Number of overlapping tokens between consecutive chunks.</p> required <p>Returns:</p> Name Type Description <code>docs</code> <code>List[Document]</code> <p>List of split Langchain <code>Document</code>.</p> Notes <p>The default behavior only executes the <code>rabbithole_splits_text</code> hook. <code>before_rabbithole_splits_text</code> and <code>after_rabbithole_splitted_text</code> hooks return the original input without any modification.</p> See Also <p>before_rabbithole_splits_text rabbithole_splits_text after_rabbithole_splitted_text</p> Source code in <code>cat/rabbit_hole.py</code> <pre><code>def __split_text(self, stray, text, chunk_size, chunk_overlap):\n    \"\"\"Split text in overlapped chunks.\n\n    This method executes the `rabbithole_splits_text` to split the incoming text in overlapped\n    chunks of text. Other two hooks are available to edit the text before and after the split step.\n\n    Parameters\n    ----------\n    text : str\n        Content of the loaded file.\n    chunk_size : int\n        Number of tokens in each document chunk.\n    chunk_overlap : int\n        Number of overlapping tokens between consecutive chunks.\n\n    Returns\n    -------\n    docs : List[Document]\n        List of split Langchain `Document`.\n\n    Notes\n    -----\n    The default behavior only executes the `rabbithole_splits_text` hook. `before_rabbithole_splits_text` and\n    `after_rabbithole_splitted_text` hooks return the original input without any modification.\n\n    See Also\n    --------\n    before_rabbithole_splits_text\n    rabbithole_splits_text\n    after_rabbithole_splitted_text\n\n    \"\"\"\n    # do something on the text before it is split\n    text = stray.mad_hatter.execute_hook(\"before_rabbithole_splits_text\", text, cat=stray)\n\n    # hooks decide the test splitter (see @property .text_splitter)\n    text_splitter = self.text_splitter\n\n    # override chunk_size and chunk_overlap only if the request has those info\n    if chunk_size:\n        text_splitter._chunk_size = chunk_size\n    if chunk_overlap:\n        text_splitter._chunk_overlap = chunk_overlap\n\n    log.info(f\"Chunk size: {chunk_size}, chunk overlap: {chunk_overlap}\")\n    # split text\n    docs = text_splitter.split_documents(text)\n    # remove short texts (page numbers, isolated words, etc.)\n    # TODO: join each short chunk with previous one, instead of deleting them\n    docs = list(filter(lambda d: len(d.page_content) &gt; 10, docs))\n\n    # do something on the text after it is split\n    docs = stray.mad_hatter.execute_hook(\"after_rabbithole_splitted_text\", docs, cat=stray)\n\n    return docs\n</code></pre>"},{"location":"technical/API_Documentation/rabbit_hole/#cat.rabbit_hole.RabbitHole.file_to_docs","title":"<code>file_to_docs(stray, file, chunk_size=None, chunk_overlap=None)</code>","text":"<p>Load and convert files to Langchain <code>Document</code>.</p> <p>This method takes a file either from a Python script, from the <code>/rabbithole/</code> or <code>/rabbithole/web</code> endpoints. Hence, it loads it in memory and splits it in overlapped chunks of text.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>(str, UploadFile)</code> <p>The file can be either a string path if loaded programmatically, a FastAPI <code>UploadFile</code> if coming from the <code>/rabbithole/</code> endpoint or a URL if coming from the <code>/rabbithole/web</code> endpoint.</p> required <code>chunk_size</code> <code>int</code> <p>Number of tokens in each document chunk.</p> <code>None</code> <code>chunk_overlap</code> <code>int</code> <p>Number of overlapping tokens between consecutive chunks.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>docs</code> <code>List[Document]</code> <p>List of Langchain <code>Document</code> of chunked text.</p> Notes <p>This method is used by both <code>/rabbithole/</code> and <code>/rabbithole/web</code> endpoints. Currently supported files are <code>.txt</code>, <code>.pdf</code>, <code>.md</code> and web pages.</p> Source code in <code>cat/rabbit_hole.py</code> <pre><code>def file_to_docs(\n        self,\n        stray,\n        file: Union[str, UploadFile],\n        chunk_size: int | None = None,\n        chunk_overlap: int | None = None,\n) -&gt; List[Document]:\n    \"\"\"Load and convert files to Langchain `Document`.\n\n    This method takes a file either from a Python script, from the `/rabbithole/` or `/rabbithole/web` endpoints.\n    Hence, it loads it in memory and splits it in overlapped chunks of text.\n\n    Parameters\n    ----------\n    file : str, UploadFile\n        The file can be either a string path if loaded programmatically, a FastAPI `UploadFile`\n        if coming from the `/rabbithole/` endpoint or a URL if coming from the `/rabbithole/web` endpoint.\n    chunk_size : int\n        Number of tokens in each document chunk.\n    chunk_overlap : int\n        Number of overlapping tokens between consecutive chunks.\n\n    Returns\n    -------\n    docs : List[Document]\n        List of Langchain `Document` of chunked text.\n\n    Notes\n    -----\n    This method is used by both `/rabbithole/` and `/rabbithole/web` endpoints.\n    Currently supported files are `.txt`, `.pdf`, `.md` and web pages.\n\n    \"\"\"\n\n    # Check type of incoming file.\n    if isinstance(file, UploadFile):\n        # Get mime type and source of UploadFile\n        content_type = mimetypes.guess_type(file.filename)[0]\n        source = file.filename\n\n        # Get file bytes\n        file_bytes = file.file.read()\n    elif isinstance(file, str):\n        # Check if string file is a string or url\n        parsed_file = urlparse(file)\n        is_url = all([parsed_file.scheme, parsed_file.netloc])\n\n        if is_url:\n            # Make a request with a fake browser name\n            request = httpx.get(file, headers={\"User-Agent\": \"Magic Browser\"})\n\n            # Define mime type and source of url\n            content_type = request.headers[\"Content-Type\"].split(\";\")[0]\n            source = file\n\n            try:\n                # Get binary content of url\n                file_bytes = request.content\n            except HTTPError as e:\n                log.error(e)\n        else:\n            # Get mime type from file extension and source\n            content_type = mimetypes.guess_type(file)[0]\n            source = os.path.basename(file)\n\n            # Get file bytes\n            with open(file, \"rb\") as f:\n                file_bytes = f.read()\n    else:\n        raise ValueError(f\"{type(file)} is not a valid type.\")\n    return self.string_to_docs(\n        stray=stray,\n        file_bytes=file_bytes,\n        source=source,\n        content_type=content_type,\n        chunk_size=chunk_size,\n        chunk_overlap=chunk_overlap\n    )\n</code></pre>"},{"location":"technical/API_Documentation/rabbit_hole/#cat.rabbit_hole.RabbitHole.ingest_file","title":"<code>ingest_file(stray, file, chunk_size=None, chunk_overlap=None)</code>","text":"<p>Load a file in the Cat's declarative memory.</p> <p>The method splits and converts the file in Langchain <code>Document</code>. Then, it stores the <code>Document</code> in the Cat's memory.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>(str, UploadFile)</code> <p>The file can be a path passed as a string or an <code>UploadFile</code> object if the document is ingested using the <code>rabbithole</code> endpoint.</p> required <code>chunk_size</code> <code>int</code> <p>Number of tokens in each document chunk.</p> <code>None</code> <code>chunk_overlap</code> <code>int</code> <p>Number of overlapping tokens between consecutive chunks.</p> <code>None</code> Notes <p>Currently supported formats are <code>.txt</code>, <code>.pdf</code> and <code>.md</code>.</p> See Also <p>before_rabbithole_stores_documents</p> Source code in <code>cat/rabbit_hole.py</code> <pre><code>def ingest_file(\n        self,\n        stray,\n        file: Union[str, UploadFile],\n        chunk_size: int | None = None,\n        chunk_overlap: int | None = None,\n):\n    \"\"\"Load a file in the Cat's declarative memory.\n\n    The method splits and converts the file in Langchain `Document`. Then, it stores the `Document` in the Cat's\n    memory.\n\n    Parameters\n    ----------\n    file : str, UploadFile\n        The file can be a path passed as a string or an `UploadFile` object if the document is ingested using the\n        `rabbithole` endpoint.\n    chunk_size : int\n        Number of tokens in each document chunk.\n    chunk_overlap : int\n        Number of overlapping tokens between consecutive chunks.\n\n    Notes\n    ----------\n    Currently supported formats are `.txt`, `.pdf` and `.md`.\n\n    See Also\n    ----------\n    before_rabbithole_stores_documents\n    \"\"\"\n\n    # split file into a list of docs\n    docs = self.file_to_docs(\n        stray=stray,\n        file=file, \n        chunk_size=chunk_size, \n        chunk_overlap=chunk_overlap\n    )\n\n    # store in memory\n    if isinstance(file, str):\n        filename = file\n    else:\n        filename = file.filename\n\n    self.store_documents(\n        stray=stray,\n        docs=docs, \n        source=filename \n    )\n</code></pre>"},{"location":"technical/API_Documentation/rabbit_hole/#cat.rabbit_hole.RabbitHole.ingest_memory","title":"<code>ingest_memory(stray, file)</code>","text":"<p>Upload memories to the declarative memory from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>UploadFile</code> <p>File object sent via <code>rabbithole/memory</code> hook.</p> required Notes <p>This method allows uploading a JSON file containing vector and text memories directly to the declarative memory. When doing this, please, make sure the embedder used to export the memories is the same as the one used when uploading. The method also performs a check on the dimensionality of the embeddings (i.e. length of each vector).</p> Source code in <code>cat/rabbit_hole.py</code> <pre><code>def ingest_memory(self, stray, file: UploadFile):\n    \"\"\"Upload memories to the declarative memory from a JSON file.\n\n    Parameters\n    ----------\n    file : UploadFile\n        File object sent via `rabbithole/memory` hook.\n\n    Notes\n    -----\n    This method allows uploading a JSON file containing vector and text memories directly to the declarative memory.\n    When doing this, please, make sure the embedder used to export the memories is the same as the one used\n    when uploading.\n    The method also performs a check on the dimensionality of the embeddings (i.e. length of each vector).\n\n    \"\"\"\n\n    # Get file bytes\n    file_bytes = file.file.read()\n\n    # Load fyle byte in a dict\n    memories = json.loads(file_bytes.decode(\"utf-8\"))\n\n    # Check the embedder used for the uploaded memories is the same the Cat is using now\n    upload_embedder = memories[\"embedder\"]\n    cat_embedder = str(stray.embedder.__class__.__name__)\n\n    if upload_embedder != cat_embedder:\n        message = f'Embedder mismatch: file embedder {upload_embedder} is different from {cat_embedder}'\n        raise Exception(message)\n\n    # Get Declarative memories in file\n    declarative_memories = memories[\"collections\"][\"declarative\"]\n\n    # Store data to upload the memories in batch\n    ids = [i[\"id\"] for i in declarative_memories]\n    payloads = [{\n        \"page_content\": p[\"page_content\"],\n        \"metadata\": p[\"metadata\"]\n    } for p in declarative_memories]\n    vectors = [v[\"vector\"] for v in declarative_memories]\n\n    log.info(f\"Preparing to load {len(vectors)} vector memories\")\n\n    # Check embedding size is correct\n    embedder_size = stray.memory.vectors.declarative.embedder_size\n    len_mismatch = [len(v) == embedder_size for v in vectors]\n\n    if not any(len_mismatch):\n        message = f'Embedding size mismatch: vectors length should be {embedder_size}'\n        raise Exception(message)\n\n    # Upsert memories in batch mode # TODO REFACTOR: use VectorMemoryCollection.add_point\n    stray.memory.vectors.vector_db.upsert(\n        collection_name=\"declarative\",\n        points=models.Batch(\n            ids=ids,\n            payloads=payloads,\n            vectors=vectors\n        )\n    )\n</code></pre>"},{"location":"technical/API_Documentation/rabbit_hole/#cat.rabbit_hole.RabbitHole.store_documents","title":"<code>store_documents(stray, docs, source)</code>","text":"<p>Add documents to the Cat's declarative memory.</p> <p>This method loops a list of Langchain <code>Document</code> and adds some metadata. Namely, the source filename and the timestamp of insertion. Once done, the method notifies the client via Websocket connection.</p> <p>Parameters:</p> Name Type Description Default <code>docs</code> <code>List[Document]</code> <p>List of Langchain <code>Document</code> to be inserted in the Cat's declarative memory.</p> required <code>source</code> <code>str</code> <p>Source name to be added as a metadata. It can be a file name or an URL.</p> required Notes <p>At this point, it is possible to customize the Cat's behavior using the <code>before_rabbithole_insert_memory</code> hook to edit the memories before they are inserted in the vector database.</p> See Also <p>before_rabbithole_insert_memory</p> Source code in <code>cat/rabbit_hole.py</code> <pre><code>def store_documents(self, stray, docs: List[Document], source: str) -&gt; None:\n    \"\"\"Add documents to the Cat's declarative memory.\n\n    This method loops a list of Langchain `Document` and adds some metadata. Namely, the source filename and the\n    timestamp of insertion. Once done, the method notifies the client via Websocket connection.\n\n    Parameters\n    ----------\n    docs : List[Document]\n        List of Langchain `Document` to be inserted in the Cat's declarative memory.\n    source : str\n        Source name to be added as a metadata. It can be a file name or an URL.\n\n    Notes\n    -------\n    At this point, it is possible to customize the Cat's behavior using the `before_rabbithole_insert_memory` hook\n    to edit the memories before they are inserted in the vector database.\n\n    See Also\n    --------\n    before_rabbithole_insert_memory\n    \"\"\"\n\n    log.info(f\"Preparing to memorize {len(docs)} vectors\")\n\n    # hook the docs before they are stored in the vector memory\n    docs = stray.mad_hatter.execute_hook(\n        \"before_rabbithole_stores_documents\", docs, cat=stray\n    )\n\n    # classic embed\n    time_last_notification = time.time()\n    time_interval = 10  # a notification every 10 secs\n    stored_points = []\n    for d, doc in enumerate(docs):\n        if time.time() - time_last_notification &gt; time_interval:\n            time_last_notification = time.time()\n            perc_read = int(d / len(docs) * 100)\n            read_message = f\"Read {perc_read}% of {source}\"\n            stray.send_ws_message(read_message)\n            log.warning(read_message)\n\n        doc.metadata[\"source\"] = source\n        doc.metadata[\"when\"] = time.time()\n        doc = stray.mad_hatter.execute_hook(\n            \"before_rabbithole_insert_memory\", doc, cat=stray\n        )\n        inserting_info = f\"{d + 1}/{len(docs)}):    {doc.page_content}\"\n        if doc.page_content != \"\":\n            doc_embedding = stray.embedder.embed_documents([doc.page_content])\n            stored_point = stray.memory.vectors.declarative.add_point(\n                doc.page_content,\n                doc_embedding[0],\n                doc.metadata,\n            )\n            stored_points.append(stored_point)\n\n            log.info(f\"Inserted into memory ({inserting_info})\")\n        else:\n            log.info(f\"Skipped memory insertion of empty doc ({inserting_info})\")\n\n        # wait a little to avoid APIs rate limit errors\n        time.sleep(0.05)\n\n    # hook the points after they are stored in the vector memory\n    stray.mad_hatter.execute_hook(\n        \"after_rabbithole_stored_documents\", source, stored_points, cat=stray\n    )\n\n    # notify client\n    finished_reading_message = \\\n        f\"Finished reading {source}, I made {len(docs)} thoughts on it.\"\n\n    stray.send_ws_message(finished_reading_message)\n\n    log.warning(f\"Done uploading {source}\")\n</code></pre>"},{"location":"technical/API_Documentation/rabbit_hole/#cat.rabbit_hole.RabbitHole.string_to_docs","title":"<code>string_to_docs(stray, file_bytes, source=None, content_type='text/plain', chunk_size=None, chunk_overlap=None)</code>","text":"<p>Convert string to Langchain <code>Document</code>.</p> <p>Takes a string, converts it to langchain <code>Document</code>. Hence, loads it in memory and splits it in overlapped chunks of text.</p> <p>Parameters:</p> Name Type Description Default <code>file_bytes</code> <code>str</code> <p>The string to be converted.</p> required <code>source</code> <code>str</code> <p>Source filename.</p> <code>None</code> <code>content_type</code> <code>str</code> <p>Mimetype of content.</p> <code>'text/plain'</code> <code>chunk_size</code> <code>int</code> <p>Number of tokens in each document chunk.</p> <code>None</code> <code>chunk_overlap</code> <code>int</code> <p>Number of overlapping tokens between consecutive chunks.</p> <code>None</code> <code>send_message</code> <p>If true will send parsing message information to frontend.</p> required <p>Returns:</p> Name Type Description <code>docs</code> <code>List[Document]</code> <p>List of Langchain <code>Document</code> of chunked text.</p> Source code in <code>cat/rabbit_hole.py</code> <pre><code>def string_to_docs(\n        self,\n        stray,\n        file_bytes: str,\n        source: str = None,\n        content_type: str = \"text/plain\",\n        chunk_size: int | None = None,\n        chunk_overlap: int | None = None,\n    ) -&gt; List[Document]:\n    \"\"\"Convert string to Langchain `Document`.\n\n    Takes a string, converts it to langchain `Document`.\n    Hence, loads it in memory and splits it in overlapped chunks of text.\n\n    Parameters\n    ----------\n    file_bytes : str\n        The string to be converted.\n    source: str\n        Source filename.\n    content_type:\n        Mimetype of content.\n    chunk_size : int\n        Number of tokens in each document chunk.\n    chunk_overlap : int\n        Number of overlapping tokens between consecutive chunks.\n    send_message: bool\n        If true will send parsing message information to frontend.\n\n    Returns\n    -------\n    docs : List[Document]\n        List of Langchain `Document` of chunked text.\n    \"\"\"\n\n    # Load the bytes in the Blob schema\n    blob = Blob(data=file_bytes,\n                mimetype=content_type,\n                source=source).from_data(data=file_bytes,\n                                         mime_type=content_type,\n                                         path=source)\n    # Parser based on the mime type\n    parser = MimeTypeBasedParser(handlers=self.file_handlers)\n\n    # Parse the text\n    stray.send_ws_message(\"I'm parsing the content. Big content could require some minutes...\")\n    super_docs = parser.parse(blob)\n\n    # Split\n    stray.send_ws_message(\"Parsing completed. Now let's go with reading process...\")\n    docs = self.__split_text(\n        stray=stray,\n        text=super_docs,\n        chunk_size=chunk_size,\n        chunk_overlap=chunk_overlap\n    )\n    return docs\n</code></pre>"},{"location":"technical/API_Documentation/utils/","title":"utils","text":"<p>Various utiles used from the projects.</p>"},{"location":"technical/API_Documentation/utils/#cat.utils.get_base_path","title":"<code>get_base_path()</code>","text":"<p>Allows exposing the base path.</p> Source code in <code>cat/utils.py</code> <pre><code>def get_base_path():\n    \"\"\"Allows exposing the base path.\"\"\"\n    return 'cat/'\n</code></pre>"},{"location":"technical/API_Documentation/utils/#cat.utils.get_base_url","title":"<code>get_base_url()</code>","text":"<p>Allows exposing the base url.</p> Source code in <code>cat/utils.py</code> <pre><code>def get_base_url():\n    \"\"\"Allows exposing the base url.\"\"\"\n    secure = os.getenv('CORE_USE_SECURE_PROTOCOLS', '')\n    if secure != '':\n        secure = 's'\n    cat_host = os.getenv('CORE_HOST', 'localhost')\n    cat_port = os.getenv('CORE_PORT', '1865')\n    return f'http{secure}://{cat_host}:{cat_port}/'\n</code></pre>"},{"location":"technical/API_Documentation/utils/#cat.utils.get_plugins_path","title":"<code>get_plugins_path()</code>","text":"<p>Allows exposing the plugins' path.</p> Source code in <code>cat/utils.py</code> <pre><code>def get_plugins_path():\n    \"\"\"Allows exposing the plugins' path.\"\"\"\n    return os.path.join(get_base_path(), 'plugins/')\n</code></pre>"},{"location":"technical/API_Documentation/utils/#cat.utils.get_static_path","title":"<code>get_static_path()</code>","text":"<p>Allows exposing the static files' path.</p> Source code in <code>cat/utils.py</code> <pre><code>def get_static_path():\n    \"\"\"Allows exposing the static files' path.\"\"\"\n    return os.path.join(get_base_path(), 'static/')\n</code></pre>"},{"location":"technical/API_Documentation/utils/#cat.utils.get_static_url","title":"<code>get_static_url()</code>","text":"<p>Allows exposing the static server url.</p> Source code in <code>cat/utils.py</code> <pre><code>def get_static_url():\n    \"\"\"Allows exposing the static server url.\"\"\"\n    return get_base_url() + 'static/'\n</code></pre>"},{"location":"technical/API_Documentation/utils/#cat.utils.to_camel_case","title":"<code>to_camel_case(text)</code>","text":"<p>Format string to camel case.</p> <p>Takes a string of words separated by either hyphens or underscores and returns a string of words in camel case.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>String of hyphens or underscores separated words.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Camel case formatted string.</p> Source code in <code>cat/utils.py</code> <pre><code>def to_camel_case(text: str) -&gt; str:\n    \"\"\"Format string to camel case.\n\n    Takes a string of words separated by either hyphens or underscores and returns a string of words in camel case.\n\n    Parameters\n    ----------\n    text : str\n        String of hyphens or underscores separated words.\n\n    Returns\n    -------\n    str\n        Camel case formatted string.\n    \"\"\"\n    s = text.replace(\"-\", \" \").replace(\"_\", \" \").capitalize()\n    s = s.split()\n    if len(text) == 0:\n        return text\n    return s[0] + \"\".join(i.capitalize() for i in s[1:])\n</code></pre>"},{"location":"technical/API_Documentation/utils/#cat.utils.verbal_timedelta","title":"<code>verbal_timedelta(td)</code>","text":"<p>Convert a timedelta in human form.</p> <p>The function takes a timedelta and converts it to a human-readable string format.</p> <p>Parameters:</p> Name Type Description Default <code>td</code> <code>timedelta</code> <p>Difference between two dates.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Human-readable string of time difference.</p> Notes <p>This method is used to give the Language Model information time information about the memories retrieved from the vector database.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; print(verbal_timedelta(timedelta(days=2, weeks=1))\n'One week and two days ago'\n</code></pre> Source code in <code>cat/utils.py</code> <pre><code>def verbal_timedelta(td: timedelta) -&gt; str:\n    \"\"\"Convert a timedelta in human form.\n\n    The function takes a timedelta and converts it to a human-readable string format.\n\n    Parameters\n    ----------\n    td : timedelta\n        Difference between two dates.\n\n    Returns\n    -------\n    str\n        Human-readable string of time difference.\n\n    Notes\n    -----\n    This method is used to give the Language Model information time information about the memories retrieved from\n    the vector database.\n\n    Examples\n    --------\n    &gt;&gt;&gt; print(verbal_timedelta(timedelta(days=2, weeks=1))\n    'One week and two days ago'\n    \"\"\"\n\n    if td.days != 0:\n        abs_days = abs(td.days)\n        if abs_days &gt; 7:\n            abs_delta = \"{} weeks\".format(td.days // 7)\n        else:\n            abs_delta = \"{} days\".format(td.days)\n    else:\n        abs_minutes = abs(td.seconds) // 60\n        if abs_minutes &gt; 60:\n            abs_delta = \"{} hours\".format(abs_minutes // 60)\n        else:\n            abs_delta = \"{} minutes\".format(abs_minutes)\n    if td &lt; timedelta(0):\n        return \"{} ago\".format(abs_delta)\n    else:\n        return \"{} ago\".format(abs_delta)\n</code></pre>"},{"location":"technical/API_Documentation/factory/ollama_utils/","title":"ollama_utils","text":""},{"location":"technical/API_Documentation/looking_glass/cheshire_cat/","title":"cheshire_cat","text":""},{"location":"technical/API_Documentation/looking_glass/cheshire_cat/#cat.looking_glass.cheshire_cat.CheshireCat","title":"<code>CheshireCat</code>","text":"<p>The Cheshire Cat.</p> <p>This is the main class that manages everything.</p> <p>Attributes:</p> Name Type Description <code>todo</code> <code>list</code> <p>Yet to be written.</p> Source code in <code>cat/looking_glass/cheshire_cat.py</code> <pre><code>@singleton\nclass CheshireCat:\n    \"\"\"The Cheshire Cat.\n\n    This is the main class that manages everything.\n\n    Attributes\n    ----------\n    todo : list\n        Yet to be written.\n\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Cat initialization.\n\n        At init time the Cat executes the bootstrap.\n        \"\"\"\n\n        # bootstrap the cat!\n        # instantiate MadHatter (loads all plugins' hooks and tools)\n        self.mad_hatter = MadHatter()\n\n        # allows plugins to do something before cat components are loaded\n        self.mad_hatter.execute_hook(\"before_cat_bootstrap\", cat=self)\n\n        # load LLM and embedder\n        self.load_natural_language()\n\n        # Load memories (vector collections and working_memory)\n        self.load_memory()\n\n        # After memory is loaded, we can get/create tools embeddings\n        # every time the mad_hatter finishes syncing hooks, tools and forms, it will notify the Cat (so it can embed tools in vector memory)\n        self.mad_hatter.on_finish_plugins_sync_callback = self.embed_procedures\n        self.embed_procedures()  # first time launched manually\n\n        # Agent manager instance (for reasoning)\n        self.agent_manager = AgentManager()\n\n        # Rabbit Hole Instance\n        self.rabbit_hole = RabbitHole(self)  # :(\n\n        # allows plugins to do something after the cat bootstrap is complete\n        self.mad_hatter.execute_hook(\"after_cat_bootstrap\", cat=self)\n\n    def load_natural_language(self):\n        \"\"\"Load Natural Language related objects.\n\n        The method exposes in the Cat all the NLP related stuff. Specifically, it sets the language models\n        (LLM and Embedder).\n\n        Warnings\n        --------\n        When using small Language Models it is suggested to turn off the memories and make the main prompt smaller\n        to prevent them to fail.\n\n        See Also\n        --------\n        agent_prompt_prefix\n        \"\"\"\n        # LLM and embedder\n        self._llm = self.load_language_model()\n        self.embedder = self.load_language_embedder()\n\n    def load_language_model(self) -&gt; BaseLanguageModel:\n        \"\"\"Large Language Model (LLM) selection at bootstrap time.\n\n        Returns\n        -------\n        llm : BaseLanguageModel\n            Langchain `BaseLanguageModel` instance of the selected model.\n\n        Notes\n        -----\n        Bootstrapping is the process of loading the plugins, the natural language objects (e.g. the LLM), the memories,\n        the *Agent Manager* and the *Rabbit Hole*.\n\n        \"\"\"\n\n        selected_llm = crud.get_setting_by_name(name=\"llm_selected\")\n\n        if selected_llm is None:\n            # return default LLM\n            llm = LLMDefaultConfig.get_llm_from_config({})\n\n        else:\n            # get LLM factory class\n            selected_llm_class = selected_llm[\"value\"][\"name\"]\n            FactoryClass = get_llm_from_name(selected_llm_class)\n\n            # obtain configuration and instantiate LLM\n            selected_llm_config = crud.get_setting_by_name(name=selected_llm_class)\n            try:\n                llm = FactoryClass.get_llm_from_config(selected_llm_config[\"value\"])\n            except Exception as e:\n                import traceback\n\n                traceback.print_exc()\n                llm = LLMDefaultConfig.get_llm_from_config({})\n\n        return llm\n\n    def load_language_embedder(self) -&gt; embedders.EmbedderSettings:\n        \"\"\"Hook into the  embedder selection.\n\n        Allows to modify how the Cat selects the embedder at bootstrap time.\n\n        Bootstrapping is the process of loading the plugins, the natural language objects (e.g. the LLM),\n        the memories, the *Agent Manager* and the *Rabbit Hole*.\n\n        Parameters\n        ----------\n        cat: CheshireCat\n            Cheshire Cat instance.\n\n        Returns\n        -------\n        embedder : Embeddings\n            Selected embedder model.\n        \"\"\"\n        # Embedding LLM\n\n        selected_embedder = crud.get_setting_by_name(name=\"embedder_selected\")\n\n        if selected_embedder is not None:\n            # get Embedder factory class\n            selected_embedder_class = selected_embedder[\"value\"][\"name\"]\n            FactoryClass = get_embedder_from_name(selected_embedder_class)\n\n            # obtain configuration and instantiate Embedder\n            selected_embedder_config = crud.get_setting_by_name(\n                name=selected_embedder_class\n            )\n            try:\n                embedder = FactoryClass.get_embedder_from_config(\n                    selected_embedder_config[\"value\"]\n                )\n            except AttributeError as e:\n                import traceback\n\n                traceback.print_exc()\n                embedder = embedders.EmbedderDumbConfig.get_embedder_from_config({})\n            return embedder\n\n        # OpenAI embedder\n        if type(self._llm) in [OpenAI, ChatOpenAI]:\n            embedder = embedders.EmbedderOpenAIConfig.get_embedder_from_config(\n                {\n                    \"openai_api_key\": self._llm.openai_api_key,\n                }\n            )\n\n        # For Azure avoid automatic embedder selection\n\n        # Cohere\n        elif type(self._llm) in [Cohere]:\n            embedder = embedders.EmbedderCohereConfig.get_embedder_from_config(\n                {\n                    \"cohere_api_key\": self._llm.cohere_api_key,\n                    \"model\": \"embed-multilingual-v2.0\",\n                    # Now the best model for embeddings is embed-multilingual-v2.0\n                }\n            )\n\n\n        elif type(self._llm) in [ChatGoogleGenerativeAI]:\n            embedder = embedders.EmbedderGeminiChatConfig.get_embedder_from_config(\n                {\n                    \"model\": \"models/embedding-001\",\n                    \"google_api_key\": self._llm.google_api_key,\n                }\n            )\n\n        else:\n            # If no embedder matches vendor, and no external embedder is configured, we use the DumbEmbedder.\n            #   `This embedder is not a model properly trained\n            #    and this makes it not suitable to effectively embed text,\n            #    \"but it does not know this and embeds anyway\".` - cit. Nicola Corbellini\n            embedder = embedders.EmbedderDumbConfig.get_embedder_from_config({})\n\n        return embedder\n\n    def load_memory(self):\n        \"\"\"Load LongTerMemory and WorkingMemory.\"\"\"\n        # Memory\n\n        # Get embedder size (langchain classes do not store it)\n        embedder_size = len(self.embedder.embed_query(\"hello world\"))\n\n        # Get embedder name (useful for for vectorstore aliases)\n        if hasattr(self.embedder, \"model\"):\n            embedder_name = self.embedder.model\n        elif hasattr(self.embedder, \"repo_id\"):\n            embedder_name = self.embedder.repo_id\n        else:\n            embedder_name = \"default_embedder\"\n\n        # instantiate long term memory\n        vector_memory_config = {\n            \"embedder_name\": embedder_name,\n            \"embedder_size\": embedder_size,\n        }\n        self.memory = LongTermMemory(vector_memory_config=vector_memory_config)\n\n    def build_embedded_procedures_hashes(self, embedded_procedures):\n\n        hashes = {}\n        for ep in embedded_procedures:\n            # log.warning(ep)\n            metadata = ep.payload[\"metadata\"]\n            content = ep.payload[\"page_content\"]\n            source = metadata[\"source\"]\n            # there may be legacy points with no trigger_type\n            trigger_type = metadata.get(\"trigger_type\", \"unsupported\")\n\n            p_hash = f\"{source}.{trigger_type}.{content}\"\n            hashes[p_hash] = ep.id\n\n        return hashes\n\n    def build_active_procedures_hashes(self, active_procedures):\n\n        hashes = {}\n        for ap in active_procedures:\n            for trigger_type, trigger_list in ap.triggers_map.items():\n                for trigger_content in trigger_list:\n                    p_hash = f\"{ap.name}.{trigger_type}.{trigger_content}\"\n                    hashes[p_hash] = {\n                        \"obj\": ap,\n                        \"source\": ap.name,\n                        \"type\": ap.procedure_type,\n                        \"trigger_type\": trigger_type,\n                        \"content\": trigger_content,\n                    }\n        return hashes\n\n    def embed_procedures(self):\n\n        # Retrieve from vectorDB all procedural embeddings\n        embedded_procedures = self.memory.vectors.procedural.get_all_points()\n        embedded_procedures_hashes = self.build_embedded_procedures_hashes(\n            embedded_procedures\n        )\n\n        # Easy access to active procedures in mad_hatter (source of truth!)\n        active_procedures_hashes = self.build_active_procedures_hashes(\n            self.mad_hatter.procedures\n        )\n\n        # points_to_be_kept     = set(active_procedures_hashes.keys()) and set(embedded_procedures_hashes.keys()) not necessary\n        points_to_be_deleted = \\\n            set(embedded_procedures_hashes.keys()) - set(active_procedures_hashes.keys())\n        points_to_be_embedded = \\\n            set(active_procedures_hashes.keys()) - set(embedded_procedures_hashes.keys())\n\n        points_to_be_deleted_ids = [\n            embedded_procedures_hashes[p] for p in points_to_be_deleted\n        ]\n        if points_to_be_deleted_ids:\n            log.warning(f\"Deleting triggers: {points_to_be_deleted}\")\n            self.memory.vectors.procedural.delete_points(points_to_be_deleted_ids)\n\n        active_triggers_to_be_embedded = [\n            active_procedures_hashes[p] for p in points_to_be_embedded\n        ]\n        for t in active_triggers_to_be_embedded:\n\n            metadata = {\n                \"source\": t[\"source\"],\n                \"type\": t[\"type\"],\n                \"trigger_type\": t[\"trigger_type\"],\n                \"when\": time.time(),\n            }\n\n            trigger_embedding = self.embedder.embed_documents([t[\"content\"]])\n            self.memory.vectors.procedural.add_point(\n                t[\"content\"],\n                trigger_embedding[0],\n                metadata,\n            )\n\n            log.warning(\n                f\"Newly embedded {t['type']} trigger: {t['source']}, {t['trigger_type']}, {t['content']}\"\n            )\n\n    def send_ws_message(self, content: str, msg_type=\"notification\"):\n        log.error(\"No websocket connection open\")\n\n    # REFACTOR: cat.llm should be available here, without streaming clearly\n    # (one could be interested in calling the LLM anytime, not only when there is a session)\n    def llm(self, prompt, *args, **kwargs) -&gt; str:\n        \"\"\"Generate a response using the LLM model.\n\n        This method is useful for generating a response with both a chat and a completion model using the same syntax\n\n        Parameters\n        ----------\n        prompt : str\n            The prompt for generating the response.\n\n        Returns\n        -------\n        str\n            The generated response.\n\n        \"\"\"\n\n        # Check if self._llm is a completion model and generate a response\n        if isinstance(self._llm, BaseLLM):\n            return self._llm(prompt)\n\n        # Check if self._llm is a chat model and call it as a completion model\n        if isinstance(self._llm, BaseChatModel):\n            return self._llm.call_as_llm(prompt)\n</code></pre>"},{"location":"technical/API_Documentation/looking_glass/cheshire_cat/#cat.looking_glass.cheshire_cat.CheshireCat.__init__","title":"<code>__init__()</code>","text":"<p>Cat initialization.</p> <p>At init time the Cat executes the bootstrap.</p> Source code in <code>cat/looking_glass/cheshire_cat.py</code> <pre><code>def __init__(self):\n    \"\"\"Cat initialization.\n\n    At init time the Cat executes the bootstrap.\n    \"\"\"\n\n    # bootstrap the cat!\n    # instantiate MadHatter (loads all plugins' hooks and tools)\n    self.mad_hatter = MadHatter()\n\n    # allows plugins to do something before cat components are loaded\n    self.mad_hatter.execute_hook(\"before_cat_bootstrap\", cat=self)\n\n    # load LLM and embedder\n    self.load_natural_language()\n\n    # Load memories (vector collections and working_memory)\n    self.load_memory()\n\n    # After memory is loaded, we can get/create tools embeddings\n    # every time the mad_hatter finishes syncing hooks, tools and forms, it will notify the Cat (so it can embed tools in vector memory)\n    self.mad_hatter.on_finish_plugins_sync_callback = self.embed_procedures\n    self.embed_procedures()  # first time launched manually\n\n    # Agent manager instance (for reasoning)\n    self.agent_manager = AgentManager()\n\n    # Rabbit Hole Instance\n    self.rabbit_hole = RabbitHole(self)  # :(\n\n    # allows plugins to do something after the cat bootstrap is complete\n    self.mad_hatter.execute_hook(\"after_cat_bootstrap\", cat=self)\n</code></pre>"},{"location":"technical/API_Documentation/looking_glass/cheshire_cat/#cat.looking_glass.cheshire_cat.CheshireCat.llm","title":"<code>llm(prompt, *args, **kwargs)</code>","text":"<p>Generate a response using the LLM model.</p> <p>This method is useful for generating a response with both a chat and a completion model using the same syntax</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The prompt for generating the response.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The generated response.</p> Source code in <code>cat/looking_glass/cheshire_cat.py</code> <pre><code>def llm(self, prompt, *args, **kwargs) -&gt; str:\n    \"\"\"Generate a response using the LLM model.\n\n    This method is useful for generating a response with both a chat and a completion model using the same syntax\n\n    Parameters\n    ----------\n    prompt : str\n        The prompt for generating the response.\n\n    Returns\n    -------\n    str\n        The generated response.\n\n    \"\"\"\n\n    # Check if self._llm is a completion model and generate a response\n    if isinstance(self._llm, BaseLLM):\n        return self._llm(prompt)\n\n    # Check if self._llm is a chat model and call it as a completion model\n    if isinstance(self._llm, BaseChatModel):\n        return self._llm.call_as_llm(prompt)\n</code></pre>"},{"location":"technical/API_Documentation/looking_glass/cheshire_cat/#cat.looking_glass.cheshire_cat.CheshireCat.load_language_embedder","title":"<code>load_language_embedder()</code>","text":"<p>Hook into the  embedder selection.</p> <p>Allows to modify how the Cat selects the embedder at bootstrap time.</p> <p>Bootstrapping is the process of loading the plugins, the natural language objects (e.g. the LLM), the memories, the Agent Manager and the Rabbit Hole.</p> <p>Parameters:</p> Name Type Description Default <code>cat</code> <p>Cheshire Cat instance.</p> required <p>Returns:</p> Name Type Description <code>embedder</code> <code>Embeddings</code> <p>Selected embedder model.</p> Source code in <code>cat/looking_glass/cheshire_cat.py</code> <pre><code>def load_language_embedder(self) -&gt; embedders.EmbedderSettings:\n    \"\"\"Hook into the  embedder selection.\n\n    Allows to modify how the Cat selects the embedder at bootstrap time.\n\n    Bootstrapping is the process of loading the plugins, the natural language objects (e.g. the LLM),\n    the memories, the *Agent Manager* and the *Rabbit Hole*.\n\n    Parameters\n    ----------\n    cat: CheshireCat\n        Cheshire Cat instance.\n\n    Returns\n    -------\n    embedder : Embeddings\n        Selected embedder model.\n    \"\"\"\n    # Embedding LLM\n\n    selected_embedder = crud.get_setting_by_name(name=\"embedder_selected\")\n\n    if selected_embedder is not None:\n        # get Embedder factory class\n        selected_embedder_class = selected_embedder[\"value\"][\"name\"]\n        FactoryClass = get_embedder_from_name(selected_embedder_class)\n\n        # obtain configuration and instantiate Embedder\n        selected_embedder_config = crud.get_setting_by_name(\n            name=selected_embedder_class\n        )\n        try:\n            embedder = FactoryClass.get_embedder_from_config(\n                selected_embedder_config[\"value\"]\n            )\n        except AttributeError as e:\n            import traceback\n\n            traceback.print_exc()\n            embedder = embedders.EmbedderDumbConfig.get_embedder_from_config({})\n        return embedder\n\n    # OpenAI embedder\n    if type(self._llm) in [OpenAI, ChatOpenAI]:\n        embedder = embedders.EmbedderOpenAIConfig.get_embedder_from_config(\n            {\n                \"openai_api_key\": self._llm.openai_api_key,\n            }\n        )\n\n    # For Azure avoid automatic embedder selection\n\n    # Cohere\n    elif type(self._llm) in [Cohere]:\n        embedder = embedders.EmbedderCohereConfig.get_embedder_from_config(\n            {\n                \"cohere_api_key\": self._llm.cohere_api_key,\n                \"model\": \"embed-multilingual-v2.0\",\n                # Now the best model for embeddings is embed-multilingual-v2.0\n            }\n        )\n\n\n    elif type(self._llm) in [ChatGoogleGenerativeAI]:\n        embedder = embedders.EmbedderGeminiChatConfig.get_embedder_from_config(\n            {\n                \"model\": \"models/embedding-001\",\n                \"google_api_key\": self._llm.google_api_key,\n            }\n        )\n\n    else:\n        # If no embedder matches vendor, and no external embedder is configured, we use the DumbEmbedder.\n        #   `This embedder is not a model properly trained\n        #    and this makes it not suitable to effectively embed text,\n        #    \"but it does not know this and embeds anyway\".` - cit. Nicola Corbellini\n        embedder = embedders.EmbedderDumbConfig.get_embedder_from_config({})\n\n    return embedder\n</code></pre>"},{"location":"technical/API_Documentation/looking_glass/cheshire_cat/#cat.looking_glass.cheshire_cat.CheshireCat.load_language_model","title":"<code>load_language_model()</code>","text":"<p>Large Language Model (LLM) selection at bootstrap time.</p> <p>Returns:</p> Name Type Description <code>llm</code> <code>BaseLanguageModel</code> <p>Langchain <code>BaseLanguageModel</code> instance of the selected model.</p> Notes <p>Bootstrapping is the process of loading the plugins, the natural language objects (e.g. the LLM), the memories, the Agent Manager and the Rabbit Hole.</p> Source code in <code>cat/looking_glass/cheshire_cat.py</code> <pre><code>def load_language_model(self) -&gt; BaseLanguageModel:\n    \"\"\"Large Language Model (LLM) selection at bootstrap time.\n\n    Returns\n    -------\n    llm : BaseLanguageModel\n        Langchain `BaseLanguageModel` instance of the selected model.\n\n    Notes\n    -----\n    Bootstrapping is the process of loading the plugins, the natural language objects (e.g. the LLM), the memories,\n    the *Agent Manager* and the *Rabbit Hole*.\n\n    \"\"\"\n\n    selected_llm = crud.get_setting_by_name(name=\"llm_selected\")\n\n    if selected_llm is None:\n        # return default LLM\n        llm = LLMDefaultConfig.get_llm_from_config({})\n\n    else:\n        # get LLM factory class\n        selected_llm_class = selected_llm[\"value\"][\"name\"]\n        FactoryClass = get_llm_from_name(selected_llm_class)\n\n        # obtain configuration and instantiate LLM\n        selected_llm_config = crud.get_setting_by_name(name=selected_llm_class)\n        try:\n            llm = FactoryClass.get_llm_from_config(selected_llm_config[\"value\"])\n        except Exception as e:\n            import traceback\n\n            traceback.print_exc()\n            llm = LLMDefaultConfig.get_llm_from_config({})\n\n    return llm\n</code></pre>"},{"location":"technical/API_Documentation/looking_glass/cheshire_cat/#cat.looking_glass.cheshire_cat.CheshireCat.load_memory","title":"<code>load_memory()</code>","text":"<p>Load LongTerMemory and WorkingMemory.</p> Source code in <code>cat/looking_glass/cheshire_cat.py</code> <pre><code>def load_memory(self):\n    \"\"\"Load LongTerMemory and WorkingMemory.\"\"\"\n    # Memory\n\n    # Get embedder size (langchain classes do not store it)\n    embedder_size = len(self.embedder.embed_query(\"hello world\"))\n\n    # Get embedder name (useful for for vectorstore aliases)\n    if hasattr(self.embedder, \"model\"):\n        embedder_name = self.embedder.model\n    elif hasattr(self.embedder, \"repo_id\"):\n        embedder_name = self.embedder.repo_id\n    else:\n        embedder_name = \"default_embedder\"\n\n    # instantiate long term memory\n    vector_memory_config = {\n        \"embedder_name\": embedder_name,\n        \"embedder_size\": embedder_size,\n    }\n    self.memory = LongTermMemory(vector_memory_config=vector_memory_config)\n</code></pre>"},{"location":"technical/API_Documentation/looking_glass/cheshire_cat/#cat.looking_glass.cheshire_cat.CheshireCat.load_natural_language","title":"<code>load_natural_language()</code>","text":"<p>Load Natural Language related objects.</p> <p>The method exposes in the Cat all the NLP related stuff. Specifically, it sets the language models (LLM and Embedder).</p> Warnings <p>When using small Language Models it is suggested to turn off the memories and make the main prompt smaller to prevent them to fail.</p> See Also <p>agent_prompt_prefix</p> Source code in <code>cat/looking_glass/cheshire_cat.py</code> <pre><code>def load_natural_language(self):\n    \"\"\"Load Natural Language related objects.\n\n    The method exposes in the Cat all the NLP related stuff. Specifically, it sets the language models\n    (LLM and Embedder).\n\n    Warnings\n    --------\n    When using small Language Models it is suggested to turn off the memories and make the main prompt smaller\n    to prevent them to fail.\n\n    See Also\n    --------\n    agent_prompt_prefix\n    \"\"\"\n    # LLM and embedder\n    self._llm = self.load_language_model()\n    self.embedder = self.load_language_embedder()\n</code></pre>"},{"location":"technical/API_Documentation/looking_glass/stray_cat/","title":"stray_cat","text":""},{"location":"technical/API_Documentation/looking_glass/stray_cat/#cat.looking_glass.stray_cat.StrayCat","title":"<code>StrayCat</code>","text":"<p>User/session based object containing working memory and a few utility pointers</p> Source code in <code>cat/looking_glass/stray_cat.py</code> <pre><code>class StrayCat:\n    \"\"\"User/session based object containing working memory and a few utility pointers\"\"\"\n\n    def __init__(\n            self,\n            user_id: str,\n            main_loop,\n            ws: WebSocket = None,\n        ):\n        self.__user_id = user_id\n        self.working_memory = WorkingMemory()\n\n        # attribute to store ws connection\n        self.__ws = ws\n\n        self.__main_loop = main_loop\n\n        self.__loop = asyncio.new_event_loop()\n\n    def __send_ws_json(self, data: Any):\n            # Run the corutine in the main event loop in the main thread \n            # and wait for the result\n            asyncio.run_coroutine_threadsafe(\n                self.__ws.send_json(data), \n                loop=self.__main_loop\n             ).result()\n\n    def __build_why(self) -&gt; MessageWhy:\n\n        # build data structure for output (response and why with memories)\n        # TODO: these 3 lines are a mess, simplify\n        episodic_report = [dict(d[0]) | {\"score\": float(d[1]), \"id\": d[3]} for d in self.working_memory.episodic_memories]\n        declarative_report = [dict(d[0]) | {\"score\": float(d[1]), \"id\": d[3]} for d in self.working_memory.declarative_memories]\n        procedural_report = [dict(d[0]) | {\"score\": float(d[1]), \"id\": d[3]} for d in self.working_memory.procedural_memories]\n\n        # why this response?\n        why = MessageWhy(\n            input=self.working_memory.user_message_json.text,\n            intermediate_steps=[],\n            memory={\n                \"episodic\": episodic_report,\n                \"declarative\": declarative_report,\n                \"procedural\": procedural_report,\n            }\n        )\n\n        return why\n\n    def send_ws_message(self, content: str, msg_type: MSG_TYPES=\"notification\"):\n\n        \"\"\"Send a message via websocket.\n\n        This method is useful for sending a message via websocket directly without passing through the LLM\n\n        Parameters\n        ----------\n        content : str\n            The content of the message.\n        msg_type : str\n            The type of the message. Should be either `notification`, `chat`, `chat_token` or `error`\n        \"\"\"\n\n        if self.__ws is None:\n            log.warning(f\"No websocket connection is open for user {self.user_id}\")\n            return\n\n        options = get_args(MSG_TYPES)\n\n        if msg_type not in options:\n            raise ValueError(f\"The message type `{msg_type}` is not valid. Valid types: {', '.join(options)}\")\n\n        if msg_type == \"error\":\n           self.__send_ws_json(\n                {\n                    \"type\": msg_type,\n                    \"name\": \"GenericError\",\n                    \"description\": str(content)\n                }\n            )\n        else:\n             self.__send_ws_json(\n                {\n                    \"type\": msg_type,\n                    \"content\": content\n                }\n            )\n\n    def send_chat_message(self, message: Union[str, CatMessage], save=False):\n        if self.__ws is None:\n            log.warning(f\"No websocket connection is open for user {self.user_id}\")\n            return\n\n        if isinstance(message, str):\n            why = self.__build_why()\n            message = CatMessage(\n                    content=message,\n                    user_id=self.user_id,\n                    why=why\n                )\n\n        if save:\n            self.working_memory.update_conversation_history(who=\"AI\", message=message[\"content\"], why=message[\"why\"])\n\n        self.__send_ws_json(message.model_dump())\n\n    def send_notification(self, content: str):\n        self.send_ws_message(\n            content=content, \n            msg_type=\"notification\"\n        )\n\n    def send_error(self, error: Union[str, Exception]):\n\n        if self.__ws is None:\n            log.warning(f\"No websocket connection is open for user {self.user_id}\")\n            return\n\n        if isinstance(error, str):\n            error_message = {\n                        \"type\": \"error\",\n                        \"name\": \"GenericError\",\n                        \"description\": str(error)\n                    }\n        else:\n            error_message = {\n                        \"type\": \"error\",\n                        \"name\": error.__class__.__name__,\n                        \"description\": str(error)\n                    }\n\n        self.__send_ws_json(error_message)\n\n    def recall_relevant_memories_to_working_memory(self, query=None):\n        \"\"\"Retrieve context from memory.\n\n        The method retrieves the relevant memories from the vector collections that are given as context to the LLM.\n        Recalled memories are stored in the working memory.\n\n        Parameters\n        ----------\n        query : str, optional\n        The query used to make a similarity search in the Cat's vector memories. If not provided, the query\n        will be derived from the user's message.\n\n        Notes\n        -----\n        The user's message is used as a query to make a similarity search in the Cat's vector memories.\n        Five hooks allow to customize the recall pipeline before and after it is done.\n\n        See Also\n        --------\n        cat_recall_query\n        before_cat_recalls_memories\n        before_cat_recalls_episodic_memories\n        before_cat_recalls_declarative_memories\n        before_cat_recalls_procedural_memories\n        after_cat_recalls_memories\n        \"\"\"\n        recall_query = query\n\n        if query is None:\n            # If query is not provided, use the user's message as the query\n            recall_query = self.working_memory.user_message_json.text\n\n        # We may want to search in memory\n        recall_query = self.mad_hatter.execute_hook(\"cat_recall_query\", recall_query, cat=self)\n        log.info(f\"Recall query: '{recall_query}'\")\n\n        # Embed recall query\n        recall_query_embedding = self.embedder.embed_query(recall_query)\n        self.working_memory.recall_query = recall_query\n\n        # hook to do something before recall begins\n        self.mad_hatter.execute_hook(\"before_cat_recalls_memories\", cat=self)\n\n        # Setting default recall configs for each memory\n        # TODO: can these data structures become instances of a RecallSettings class?\n        default_episodic_recall_config = {\n            \"embedding\": recall_query_embedding,\n            \"k\": 3,\n            \"threshold\": 0.7,\n            \"metadata\": {\"source\": self.user_id},\n        }\n\n        default_declarative_recall_config = {\n            \"embedding\": recall_query_embedding,\n            \"k\": 3,\n            \"threshold\": 0.7,\n            \"metadata\": None,\n        }\n\n        default_procedural_recall_config = {\n            \"embedding\": recall_query_embedding,\n            \"k\": 3,\n            \"threshold\": 0.7,\n            \"metadata\": None,\n        }\n\n        # hooks to change recall configs for each memory\n        recall_configs = [\n            self.mad_hatter.execute_hook(\n                \"before_cat_recalls_episodic_memories\", default_episodic_recall_config, cat=self),\n            self.mad_hatter.execute_hook(\n                \"before_cat_recalls_declarative_memories\", default_declarative_recall_config, cat=self),\n            self.mad_hatter.execute_hook(\n                \"before_cat_recalls_procedural_memories\", default_procedural_recall_config, cat=self)\n        ]\n\n        memory_types = self.memory.vectors.collections.keys()\n\n        for config, memory_type in zip(recall_configs, memory_types):\n            memory_key = f\"{memory_type}_memories\"\n\n            # recall relevant memories for collection\n            vector_memory = getattr(self.memory.vectors, memory_type)\n            memories = vector_memory.recall_memories_from_embedding(**config)\n\n            setattr(self.working_memory, memory_key, memories) # self.working_memory.procedural_memories = ...\n\n        # hook to modify/enrich retrieved memories\n        self.mad_hatter.execute_hook(\"after_cat_recalls_memories\", cat=self)\n\n    def llm(self, prompt: str, stream: bool = False) -&gt; str:\n        \"\"\"Generate a response using the LLM model.\n\n        This method is useful for generating a response with both a chat and a completion model using the same syntax\n\n        Parameters\n        ----------\n        prompt : str\n            The prompt for generating the response.\n\n        Returns\n        -------\n        str\n            The generated response.\n\n        \"\"\"\n\n        # should we stream the tokens?\n        callbacks = []\n        if stream:\n            callbacks.append(NewTokenHandler(self))\n\n        # Check if self._llm is a completion model and generate a response\n        if isinstance(self._llm, BaseLLM):\n            return self._llm(prompt, callbacks=callbacks)\n\n        # Check if self._llm is a chat model and call it as a completion model\n        if isinstance(self._llm, BaseChatModel):\n            return self._llm.call_as_llm(prompt, callbacks=callbacks)\n\n    async def __call__(self, message_dict):\n            \"\"\"Call the Cat instance.\n\n            This method is called on the user's message received from the client.\n\n            Parameters\n            ----------\n            message_dict : dict\n                Dictionary received from the Websocket client.\n            save : bool, optional\n                If True, the user's message is stored in the chat history. Default is True.\n\n            Returns\n            -------\n            final_output : dict\n                Dictionary with the Cat's answer to be sent to the client.\n\n            Notes\n            -----\n            Here happens the main pipeline of the Cat. Namely, the Cat receives the user's input and recall the memories.\n            The retrieved context is formatted properly and given in input to the Agent that uses the LLM to produce the\n            answer. This is formatted in a dictionary to be sent as a JSON via Websocket to the client.\n\n            \"\"\"\n\n            # Parse websocket message into UserMessage obj\n            user_message = UserMessage.model_validate(message_dict)\n            log.info(user_message)\n\n            # set a few easy access variables\n            self.working_memory.user_message_json = user_message\n\n            # hook to modify/enrich user input\n            self.working_memory.user_message_json = self.mad_hatter.execute_hook(\n                \"before_cat_reads_message\",\n                self.working_memory.user_message_json,\n                cat=self\n            )\n\n            # text of latest Human message\n            user_message_text = self.working_memory.user_message_json.text\n\n            # update conversation history (Human turn)\n            self.working_memory.update_conversation_history(who=\"Human\", message=user_message_text)\n\n            # recall episodic and declarative memories from vector collections\n            #   and store them in working_memory\n            try:\n                self.recall_relevant_memories_to_working_memory()\n            except Exception as e:\n                log.error(e)\n                traceback.print_exc(e)\n\n                err_message = (\n                    \"You probably changed Embedder and old vector memory is not compatible. \"\n                    \"Please delete `core/long_term_memory` folder.\"\n                )\n\n                return {\n                    \"type\": \"error\",\n                    \"name\": \"VectorMemoryError\",\n                    \"description\": err_message,\n                }\n\n            # reply with agent\n            try:\n                cat_message = await self.agent_manager.execute_agent(self)\n            except Exception as e:\n                # This error happens when the LLM\n                #   does not respect prompt instructions.\n                # We grab the LLM output here anyway, so small and\n                #   non instruction-fine-tuned models can still be used.\n                error_description = str(e)\n\n                log.error(error_description)\n                if \"Could not parse LLM output: `\" not in error_description:\n                    raise e\n\n                unparsable_llm_output = error_description.replace(\"Could not parse LLM output: `\", \"\").replace(\"`\", \"\")\n                cat_message = {\n                    \"input\": user_message_text,\n                    \"intermediate_steps\": [],\n                    \"output\": unparsable_llm_output\n                }\n\n            log.info(\"cat_message:\")\n            log.info(cat_message)\n\n            doc = Document(\n                page_content=user_message_text,\n                metadata={\n                    \"source\": self.user_id,\n                    \"when\": time.time()\n                }\n            )\n            doc = self.mad_hatter.execute_hook(\n                \"before_cat_stores_episodic_memory\", doc, cat=self\n            )\n            # store user message in episodic memory\n            # TODO: vectorize and store also conversation chunks\n            #   (not raw dialog, but summarization)\n            user_message_embedding = self.embedder.embed_documents([user_message_text])\n            _ = self.memory.vectors.episodic.add_point(\n                doc.page_content,\n                user_message_embedding[0],\n                doc.metadata,\n            )\n\n            # why this response?\n            why = self.__build_why()\n            why.intermediate_steps = cat_message.get(\"intermediate_steps\", [])\n\n            # prepare final cat message\n            final_output = CatMessage(\n                user_id=self.user_id,\n                content=str(cat_message.get(\"output\")),\n                why=why\n            )\n\n            # run message through plugins\n            final_output = self.mad_hatter.execute_hook(\"before_cat_sends_message\", final_output, cat=self)\n\n            # update conversation history (AI turn)\n            self.working_memory.update_conversation_history(who=\"AI\", message=final_output.content, why=final_output.why)\n\n            return final_output\n\n    def run(self, user_message_json):\n        try:\n            cat_message = self.loop.run_until_complete(\n                self.__call__(user_message_json)\n            )\n            # send message back to client\n            self.send_chat_message(cat_message)\n        except Exception as e:\n            # Log any unexpected errors\n            log.error(e)\n            traceback.print_exc()\n            # Send error as websocket message\n            self.send_error(e)\n\n    def classify(self, sentence: str, labels: List[str] | Dict[str, List[str]]) -&gt; str:\n        \"\"\"Classify a sentence.\n\n        Parameters\n        ----------\n        sentence : str\n            Sentence to be classified.\n        labels : List[str] or Dict[str, List[str]]\n            Possible output categories and optional examples.\n\n        Returns\n        -------\n        label : str\n            Sentence category.\n\n        Examples\n        -------\n        &gt;&gt;&gt; cat.classify(\"I feel good\", labels=[\"positive\", \"negative\"])\n        \"positive\"\n\n        Or giving examples for each category:\n\n        &gt;&gt;&gt; example_labels = {\n        ...     \"positive\": [\"I feel nice\", \"happy today\"],\n        ...     \"negative\": [\"I feel bad\", \"not my best day\"],\n        ... }\n        ... cat.classify(\"it is a bad day\", labels=example_labels)\n        \"negative\"\n\n        \"\"\"\n\n        if type(labels) in [dict, Dict]:\n            labels_names = labels.keys()\n            examples_list = \"\\n\\nExamples:\"\n            for label, examples in labels.items():\n                for ex in examples:\n                    examples_list += f'\\n\"{ex}\" -&gt; \"{label}\"'\n        else:\n            labels_names = labels\n            examples_list = \"\"\n\n        labels_list = '\"' + '\", \"'.join(labels_names) + '\"'\n\n        prompt = f\"\"\"Classify this sentence:\n\"{sentence}\"\n\nAllowed classes are:\n{labels_list}{examples_list}\n\n\"{sentence}\" -&gt; \"\"\"\n\n        response = self.llm(prompt)\n        log.critical(response)\n\n        for l in labels_names:\n            if l in response:\n                return l\n\n        return None\n\n    def stringify_chat_history(self, latest_n: int = 5) -&gt; str:\n        \"\"\"Serialize chat history.\n        Converts to text the recent conversation turns.\n\n        Parameters\n        ----------\n        latest_n : int\n            Hoe many latest turns to stringify.\n\n        Returns\n        -------\n        history : str\n            String with recent conversation turns.\n\n        Notes\n        -----\n        Such context is placed in the `agent_prompt_suffix` in the place held by {chat_history}.\n\n        The chat history is a dictionary with keys::\n            'who': the name of who said the utterance;\n            'message': the utterance.\n\n        \"\"\"\n\n        history = self.working_memory.history[-latest_n:]\n\n        history_string = \"\"\n        for turn in history:\n            history_string += f\"\\n - {turn['who']}: {turn['message']}\"\n\n        return history_string\n\n    @property\n    def user_id(self):\n        return self.__user_id\n\n    @property\n    def _llm(self):\n        return CheshireCat()._llm\n\n    @property\n    def embedder(self):\n        return CheshireCat().embedder\n\n    @property\n    def memory(self):\n        return CheshireCat().memory\n\n    @property\n    def rabbit_hole(self):\n        return CheshireCat().rabbit_hole\n\n    @property\n    def mad_hatter(self):\n        return CheshireCat().mad_hatter\n\n    @property\n    def agent_manager(self):\n        return CheshireCat().agent_manager\n\n    @property\n    def loop(self):\n        return self.__loop\n</code></pre>"},{"location":"technical/API_Documentation/looking_glass/stray_cat/#cat.looking_glass.stray_cat.StrayCat.__call__","title":"<code>__call__(message_dict)</code>  <code>async</code>","text":"<p>Call the Cat instance.</p> <p>This method is called on the user's message received from the client.</p> <p>Parameters:</p> Name Type Description Default <code>message_dict</code> <code>dict</code> <p>Dictionary received from the Websocket client.</p> required <code>save</code> <code>bool</code> <p>If True, the user's message is stored in the chat history. Default is True.</p> required <p>Returns:</p> Name Type Description <code>final_output</code> <code>dict</code> <p>Dictionary with the Cat's answer to be sent to the client.</p> Notes <p>Here happens the main pipeline of the Cat. Namely, the Cat receives the user's input and recall the memories. The retrieved context is formatted properly and given in input to the Agent that uses the LLM to produce the answer. This is formatted in a dictionary to be sent as a JSON via Websocket to the client.</p> Source code in <code>cat/looking_glass/stray_cat.py</code> <pre><code>async def __call__(self, message_dict):\n        \"\"\"Call the Cat instance.\n\n        This method is called on the user's message received from the client.\n\n        Parameters\n        ----------\n        message_dict : dict\n            Dictionary received from the Websocket client.\n        save : bool, optional\n            If True, the user's message is stored in the chat history. Default is True.\n\n        Returns\n        -------\n        final_output : dict\n            Dictionary with the Cat's answer to be sent to the client.\n\n        Notes\n        -----\n        Here happens the main pipeline of the Cat. Namely, the Cat receives the user's input and recall the memories.\n        The retrieved context is formatted properly and given in input to the Agent that uses the LLM to produce the\n        answer. This is formatted in a dictionary to be sent as a JSON via Websocket to the client.\n\n        \"\"\"\n\n        # Parse websocket message into UserMessage obj\n        user_message = UserMessage.model_validate(message_dict)\n        log.info(user_message)\n\n        # set a few easy access variables\n        self.working_memory.user_message_json = user_message\n\n        # hook to modify/enrich user input\n        self.working_memory.user_message_json = self.mad_hatter.execute_hook(\n            \"before_cat_reads_message\",\n            self.working_memory.user_message_json,\n            cat=self\n        )\n\n        # text of latest Human message\n        user_message_text = self.working_memory.user_message_json.text\n\n        # update conversation history (Human turn)\n        self.working_memory.update_conversation_history(who=\"Human\", message=user_message_text)\n\n        # recall episodic and declarative memories from vector collections\n        #   and store them in working_memory\n        try:\n            self.recall_relevant_memories_to_working_memory()\n        except Exception as e:\n            log.error(e)\n            traceback.print_exc(e)\n\n            err_message = (\n                \"You probably changed Embedder and old vector memory is not compatible. \"\n                \"Please delete `core/long_term_memory` folder.\"\n            )\n\n            return {\n                \"type\": \"error\",\n                \"name\": \"VectorMemoryError\",\n                \"description\": err_message,\n            }\n\n        # reply with agent\n        try:\n            cat_message = await self.agent_manager.execute_agent(self)\n        except Exception as e:\n            # This error happens when the LLM\n            #   does not respect prompt instructions.\n            # We grab the LLM output here anyway, so small and\n            #   non instruction-fine-tuned models can still be used.\n            error_description = str(e)\n\n            log.error(error_description)\n            if \"Could not parse LLM output: `\" not in error_description:\n                raise e\n\n            unparsable_llm_output = error_description.replace(\"Could not parse LLM output: `\", \"\").replace(\"`\", \"\")\n            cat_message = {\n                \"input\": user_message_text,\n                \"intermediate_steps\": [],\n                \"output\": unparsable_llm_output\n            }\n\n        log.info(\"cat_message:\")\n        log.info(cat_message)\n\n        doc = Document(\n            page_content=user_message_text,\n            metadata={\n                \"source\": self.user_id,\n                \"when\": time.time()\n            }\n        )\n        doc = self.mad_hatter.execute_hook(\n            \"before_cat_stores_episodic_memory\", doc, cat=self\n        )\n        # store user message in episodic memory\n        # TODO: vectorize and store also conversation chunks\n        #   (not raw dialog, but summarization)\n        user_message_embedding = self.embedder.embed_documents([user_message_text])\n        _ = self.memory.vectors.episodic.add_point(\n            doc.page_content,\n            user_message_embedding[0],\n            doc.metadata,\n        )\n\n        # why this response?\n        why = self.__build_why()\n        why.intermediate_steps = cat_message.get(\"intermediate_steps\", [])\n\n        # prepare final cat message\n        final_output = CatMessage(\n            user_id=self.user_id,\n            content=str(cat_message.get(\"output\")),\n            why=why\n        )\n\n        # run message through plugins\n        final_output = self.mad_hatter.execute_hook(\"before_cat_sends_message\", final_output, cat=self)\n\n        # update conversation history (AI turn)\n        self.working_memory.update_conversation_history(who=\"AI\", message=final_output.content, why=final_output.why)\n\n        return final_output\n</code></pre>"},{"location":"technical/API_Documentation/looking_glass/stray_cat/#cat.looking_glass.stray_cat.StrayCat.classify","title":"<code>classify(sentence, labels)</code>","text":"<p>Classify a sentence.</p> <p>Parameters:</p> Name Type Description Default <code>sentence</code> <code>str</code> <p>Sentence to be classified.</p> required <code>labels</code> <code>List[str] or Dict[str, List[str]]</code> <p>Possible output categories and optional examples.</p> required <p>Returns:</p> Name Type Description <code>label</code> <code>str</code> <p>Sentence category.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cat.classify(\"I feel good\", labels=[\"positive\", \"negative\"])\n\"positive\"\n</code></pre> <p>Or giving examples for each category:</p> <pre><code>&gt;&gt;&gt; example_labels = {\n...     \"positive\": [\"I feel nice\", \"happy today\"],\n...     \"negative\": [\"I feel bad\", \"not my best day\"],\n... }\n... cat.classify(\"it is a bad day\", labels=example_labels)\n\"negative\"\n</code></pre> Source code in <code>cat/looking_glass/stray_cat.py</code> <pre><code>    def classify(self, sentence: str, labels: List[str] | Dict[str, List[str]]) -&gt; str:\n        \"\"\"Classify a sentence.\n\n        Parameters\n        ----------\n        sentence : str\n            Sentence to be classified.\n        labels : List[str] or Dict[str, List[str]]\n            Possible output categories and optional examples.\n\n        Returns\n        -------\n        label : str\n            Sentence category.\n\n        Examples\n        -------\n        &gt;&gt;&gt; cat.classify(\"I feel good\", labels=[\"positive\", \"negative\"])\n        \"positive\"\n\n        Or giving examples for each category:\n\n        &gt;&gt;&gt; example_labels = {\n        ...     \"positive\": [\"I feel nice\", \"happy today\"],\n        ...     \"negative\": [\"I feel bad\", \"not my best day\"],\n        ... }\n        ... cat.classify(\"it is a bad day\", labels=example_labels)\n        \"negative\"\n\n        \"\"\"\n\n        if type(labels) in [dict, Dict]:\n            labels_names = labels.keys()\n            examples_list = \"\\n\\nExamples:\"\n            for label, examples in labels.items():\n                for ex in examples:\n                    examples_list += f'\\n\"{ex}\" -&gt; \"{label}\"'\n        else:\n            labels_names = labels\n            examples_list = \"\"\n\n        labels_list = '\"' + '\", \"'.join(labels_names) + '\"'\n\n        prompt = f\"\"\"Classify this sentence:\n\"{sentence}\"\n\nAllowed classes are:\n{labels_list}{examples_list}\n\n\"{sentence}\" -&gt; \"\"\"\n\n        response = self.llm(prompt)\n        log.critical(response)\n\n        for l in labels_names:\n            if l in response:\n                return l\n\n        return None\n</code></pre>"},{"location":"technical/API_Documentation/looking_glass/stray_cat/#cat.looking_glass.stray_cat.StrayCat.llm","title":"<code>llm(prompt, stream=False)</code>","text":"<p>Generate a response using the LLM model.</p> <p>This method is useful for generating a response with both a chat and a completion model using the same syntax</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The prompt for generating the response.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The generated response.</p> Source code in <code>cat/looking_glass/stray_cat.py</code> <pre><code>def llm(self, prompt: str, stream: bool = False) -&gt; str:\n    \"\"\"Generate a response using the LLM model.\n\n    This method is useful for generating a response with both a chat and a completion model using the same syntax\n\n    Parameters\n    ----------\n    prompt : str\n        The prompt for generating the response.\n\n    Returns\n    -------\n    str\n        The generated response.\n\n    \"\"\"\n\n    # should we stream the tokens?\n    callbacks = []\n    if stream:\n        callbacks.append(NewTokenHandler(self))\n\n    # Check if self._llm is a completion model and generate a response\n    if isinstance(self._llm, BaseLLM):\n        return self._llm(prompt, callbacks=callbacks)\n\n    # Check if self._llm is a chat model and call it as a completion model\n    if isinstance(self._llm, BaseChatModel):\n        return self._llm.call_as_llm(prompt, callbacks=callbacks)\n</code></pre>"},{"location":"technical/API_Documentation/looking_glass/stray_cat/#cat.looking_glass.stray_cat.StrayCat.recall_relevant_memories_to_working_memory","title":"<code>recall_relevant_memories_to_working_memory(query=None)</code>","text":"<p>Retrieve context from memory.</p> <p>The method retrieves the relevant memories from the vector collections that are given as context to the LLM. Recalled memories are stored in the working memory.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <code>None</code> <code>The</code> required <code>will</code> required Notes <p>The user's message is used as a query to make a similarity search in the Cat's vector memories. Five hooks allow to customize the recall pipeline before and after it is done.</p> See Also <p>cat_recall_query before_cat_recalls_memories before_cat_recalls_episodic_memories before_cat_recalls_declarative_memories before_cat_recalls_procedural_memories after_cat_recalls_memories</p> Source code in <code>cat/looking_glass/stray_cat.py</code> <pre><code>def recall_relevant_memories_to_working_memory(self, query=None):\n    \"\"\"Retrieve context from memory.\n\n    The method retrieves the relevant memories from the vector collections that are given as context to the LLM.\n    Recalled memories are stored in the working memory.\n\n    Parameters\n    ----------\n    query : str, optional\n    The query used to make a similarity search in the Cat's vector memories. If not provided, the query\n    will be derived from the user's message.\n\n    Notes\n    -----\n    The user's message is used as a query to make a similarity search in the Cat's vector memories.\n    Five hooks allow to customize the recall pipeline before and after it is done.\n\n    See Also\n    --------\n    cat_recall_query\n    before_cat_recalls_memories\n    before_cat_recalls_episodic_memories\n    before_cat_recalls_declarative_memories\n    before_cat_recalls_procedural_memories\n    after_cat_recalls_memories\n    \"\"\"\n    recall_query = query\n\n    if query is None:\n        # If query is not provided, use the user's message as the query\n        recall_query = self.working_memory.user_message_json.text\n\n    # We may want to search in memory\n    recall_query = self.mad_hatter.execute_hook(\"cat_recall_query\", recall_query, cat=self)\n    log.info(f\"Recall query: '{recall_query}'\")\n\n    # Embed recall query\n    recall_query_embedding = self.embedder.embed_query(recall_query)\n    self.working_memory.recall_query = recall_query\n\n    # hook to do something before recall begins\n    self.mad_hatter.execute_hook(\"before_cat_recalls_memories\", cat=self)\n\n    # Setting default recall configs for each memory\n    # TODO: can these data structures become instances of a RecallSettings class?\n    default_episodic_recall_config = {\n        \"embedding\": recall_query_embedding,\n        \"k\": 3,\n        \"threshold\": 0.7,\n        \"metadata\": {\"source\": self.user_id},\n    }\n\n    default_declarative_recall_config = {\n        \"embedding\": recall_query_embedding,\n        \"k\": 3,\n        \"threshold\": 0.7,\n        \"metadata\": None,\n    }\n\n    default_procedural_recall_config = {\n        \"embedding\": recall_query_embedding,\n        \"k\": 3,\n        \"threshold\": 0.7,\n        \"metadata\": None,\n    }\n\n    # hooks to change recall configs for each memory\n    recall_configs = [\n        self.mad_hatter.execute_hook(\n            \"before_cat_recalls_episodic_memories\", default_episodic_recall_config, cat=self),\n        self.mad_hatter.execute_hook(\n            \"before_cat_recalls_declarative_memories\", default_declarative_recall_config, cat=self),\n        self.mad_hatter.execute_hook(\n            \"before_cat_recalls_procedural_memories\", default_procedural_recall_config, cat=self)\n    ]\n\n    memory_types = self.memory.vectors.collections.keys()\n\n    for config, memory_type in zip(recall_configs, memory_types):\n        memory_key = f\"{memory_type}_memories\"\n\n        # recall relevant memories for collection\n        vector_memory = getattr(self.memory.vectors, memory_type)\n        memories = vector_memory.recall_memories_from_embedding(**config)\n\n        setattr(self.working_memory, memory_key, memories) # self.working_memory.procedural_memories = ...\n\n    # hook to modify/enrich retrieved memories\n    self.mad_hatter.execute_hook(\"after_cat_recalls_memories\", cat=self)\n</code></pre>"},{"location":"technical/API_Documentation/looking_glass/stray_cat/#cat.looking_glass.stray_cat.StrayCat.send_ws_message","title":"<code>send_ws_message(content, msg_type='notification')</code>","text":"<p>Send a message via websocket.</p> <p>This method is useful for sending a message via websocket directly without passing through the LLM</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>The content of the message.</p> required <code>msg_type</code> <code>str</code> <p>The type of the message. Should be either <code>notification</code>, <code>chat</code>, <code>chat_token</code> or <code>error</code></p> <code>'notification'</code> Source code in <code>cat/looking_glass/stray_cat.py</code> <pre><code>def send_ws_message(self, content: str, msg_type: MSG_TYPES=\"notification\"):\n\n    \"\"\"Send a message via websocket.\n\n    This method is useful for sending a message via websocket directly without passing through the LLM\n\n    Parameters\n    ----------\n    content : str\n        The content of the message.\n    msg_type : str\n        The type of the message. Should be either `notification`, `chat`, `chat_token` or `error`\n    \"\"\"\n\n    if self.__ws is None:\n        log.warning(f\"No websocket connection is open for user {self.user_id}\")\n        return\n\n    options = get_args(MSG_TYPES)\n\n    if msg_type not in options:\n        raise ValueError(f\"The message type `{msg_type}` is not valid. Valid types: {', '.join(options)}\")\n\n    if msg_type == \"error\":\n       self.__send_ws_json(\n            {\n                \"type\": msg_type,\n                \"name\": \"GenericError\",\n                \"description\": str(content)\n            }\n        )\n    else:\n         self.__send_ws_json(\n            {\n                \"type\": msg_type,\n                \"content\": content\n            }\n        )\n</code></pre>"},{"location":"technical/API_Documentation/looking_glass/stray_cat/#cat.looking_glass.stray_cat.StrayCat.stringify_chat_history","title":"<code>stringify_chat_history(latest_n=5)</code>","text":"<p>Serialize chat history. Converts to text the recent conversation turns.</p> <p>Parameters:</p> Name Type Description Default <code>latest_n</code> <code>int</code> <p>Hoe many latest turns to stringify.</p> <code>5</code> <p>Returns:</p> Name Type Description <code>history</code> <code>str</code> <p>String with recent conversation turns.</p> Notes <p>Such context is placed in the <code>agent_prompt_suffix</code> in the place held by {chat_history}.</p> <p>The chat history is a dictionary with keys::     'who': the name of who said the utterance;     'message': the utterance.</p> Source code in <code>cat/looking_glass/stray_cat.py</code> <pre><code>def stringify_chat_history(self, latest_n: int = 5) -&gt; str:\n    \"\"\"Serialize chat history.\n    Converts to text the recent conversation turns.\n\n    Parameters\n    ----------\n    latest_n : int\n        Hoe many latest turns to stringify.\n\n    Returns\n    -------\n    history : str\n        String with recent conversation turns.\n\n    Notes\n    -----\n    Such context is placed in the `agent_prompt_suffix` in the place held by {chat_history}.\n\n    The chat history is a dictionary with keys::\n        'who': the name of who said the utterance;\n        'message': the utterance.\n\n    \"\"\"\n\n    history = self.working_memory.history[-latest_n:]\n\n    history_string = \"\"\n    for turn in history:\n        history_string += f\"\\n - {turn['who']}: {turn['message']}\"\n\n    return history_string\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/mad_hatter/","title":"mad_hatter","text":""},{"location":"technical/API_Documentation/mad_hatter/plugin/","title":"plugin","text":""},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/agent/","title":"agent","text":"<p>Hooks to modify the Cat's Agent.</p> <p>Here is a collection of methods to hook into the Agent execution pipeline.</p>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/agent/#cat.mad_hatter.core_plugin.hooks.agent.agent_allowed_tools","title":"<code>agent_allowed_tools(allowed_tools, cat)</code>","text":"<p>Hook the allowed tools.</p> <p>Allows to decide which tools end up in the Agent prompt.</p> <p>To decide, you can filter the list of tools' names, but you can also check the context in <code>cat.working_memory</code> and launch custom chains with <code>cat._llm</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required <p>Returns:</p> Name Type Description <code>tools</code> <code>List[str]</code> <p>List of allowed Langchain tools.</p> Source code in <code>cat/mad_hatter/core_plugin/hooks/agent.py</code> <pre><code>@hook(priority=0)\ndef agent_allowed_tools(allowed_tools: List[str], cat) -&gt; List[str]:\n    \"\"\"Hook the allowed tools.\n\n    Allows to decide which tools end up in the *Agent* prompt.\n\n    To decide, you can filter the list of tools' names, but you can also check the context in `cat.working_memory`\n    and launch custom chains with `cat._llm`.\n\n    Parameters\n    ---------\n    cat : CheshireCat\n        Cheshire Cat instance.\n\n    Returns\n    -------\n    tools : List[str]\n        List of allowed Langchain tools.\n    \"\"\"\n\n    return allowed_tools\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/agent/#cat.mad_hatter.core_plugin.hooks.agent.agent_fast_reply","title":"<code>agent_fast_reply(fast_reply, cat)</code>","text":"<p>This hook is useful to shortcut the Cat response. If you do not want the agent to run, return the final response from here and it will end up in the chat without the agent being executed.</p> <p>Parameters:</p> Name Type Description Default <code>fast_reply</code> <p>Input is dict (initially empty), which can be enriched whith an \"output\" key with the shortcut response.</p> required <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required <p>Returns:</p> Name Type Description <code>response</code> <code>Union[None, Dict]</code> <p>Cat response if you want to avoid using the agent, or None / {} if you want the agent to be executed. See below for examples of Cat response</p> <p>Examples:</p> <p>Example 1: can't talk about this topic </p><pre><code># here you could use cat._llm to do topic evaluation\nif \"dog\" in agent_input[\"input\"]:\n    return {\n        \"output\": \"You went out of topic. Can't talk about dog.\"\n    }\n</code></pre> <p>Example 2: don't remember (no uploaded documents about topic) </p><pre><code>num_declarative_memories = len( cat.working_memory.declarative_memories )\nif num_declarative_memories == 0:\n    return {\n       \"output\": \"Sorry, I have no memories about that.\"\n    }\n</code></pre> Source code in <code>cat/mad_hatter/core_plugin/hooks/agent.py</code> <pre><code>@hook(priority=0)\ndef agent_fast_reply(fast_reply, cat) -&gt; Union[None, Dict]:\n    \"\"\"This hook is useful to shortcut the Cat response.\n    If you do not want the agent to run, return the final response from here and it will end up in the chat without the agent being executed.\n\n    Parameters\n    --------\n    fast_reply: dict\n        Input is dict (initially empty), which can be enriched whith an \"output\" key with the shortcut response.\n    cat : CheshireCat\n        Cheshire Cat instance.\n\n    Returns\n    --------\n    response : Union[None, Dict]\n        Cat response if you want to avoid using the agent, or None / {} if you want the agent to be executed.\n        See below for examples of Cat response\n\n    Examples\n    --------\n\n    Example 1: can't talk about this topic\n    ```python\n    # here you could use cat._llm to do topic evaluation\n    if \"dog\" in agent_input[\"input\"]:\n        return {\n            \"output\": \"You went out of topic. Can't talk about dog.\"\n        }\n    ```\n\n    Example 2: don't remember (no uploaded documents about topic)\n    ```python\n    num_declarative_memories = len( cat.working_memory.declarative_memories )\n    if num_declarative_memories == 0:\n        return {\n           \"output\": \"Sorry, I have no memories about that.\"\n        }\n    ```\n    \"\"\"\n\n    return fast_reply\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/agent/#cat.mad_hatter.core_plugin.hooks.agent.before_agent_starts","title":"<code>before_agent_starts(agent_input, cat)</code>","text":"<p>Hook to read and edit the agent input</p> <p>Parameters:</p> Name Type Description Default <code>agent_input</code> <code>Dict</code> <p>Input that is about to be passed to the agent.</p> required <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required <p>Returns:</p> Name Type Description <code>response</code> <code>Dict</code> <p>Agent Input</p> Source code in <code>cat/mad_hatter/core_plugin/hooks/agent.py</code> <pre><code>@hook(priority=0)\ndef before_agent_starts(agent_input: Dict, cat) -&gt; Dict:\n    \"\"\"Hook to read and edit the agent input\n\n    Parameters\n    --------\n    agent_input: dict\n        Input that is about to be passed to the agent.\n    cat : CheshireCat\n        Cheshire Cat instance.\n\n    Returns\n    --------\n    response : Dict\n        Agent Input\n    \"\"\"\n\n    return agent_input\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/flow/","title":"flow","text":"<p>Hooks to modify the Cat's flow of execution.</p> <p>Here is a collection of methods to hook into the Cat execution pipeline.</p>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/flow/#cat.mad_hatter.core_plugin.hooks.flow.after_cat_bootstrap","title":"<code>after_cat_bootstrap(cat)</code>","text":"<p>Hook into the end of the Cat start up.</p> <p>Bootstrapping is the process of loading the plugins, the natural language objects (e.g. the LLM), the memories, the Agent Manager and the Rabbit Hole.</p> <p>This hook allows to intercept the end of such process and is executed right after the Cat has finished loading its components.</p> <p>This can be used to set or store variables to be shared further in the pipeline.</p> <p>Parameters:</p> Name Type Description Default <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required Source code in <code>cat/mad_hatter/core_plugin/hooks/flow.py</code> <pre><code>@hook(priority=0)\ndef after_cat_bootstrap(cat) -&gt; None:\n    \"\"\"Hook into the end of the Cat start up.\n\n    Bootstrapping is the process of loading the plugins, the natural language objects (e.g. the LLM),\n    the memories, the *Agent Manager* and the *Rabbit Hole*.\n\n    This hook allows to intercept the end of such process and is executed right after the Cat has finished loading\n    its components.\n\n    This can be used to set or store variables to be shared further in the pipeline.\n\n    Parameters\n    ----------\n    cat : CheshireCat\n        Cheshire Cat instance.\n    \"\"\"\n    pass # do nothing\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/flow/#cat.mad_hatter.core_plugin.hooks.flow.after_cat_recalls_memories","title":"<code>after_cat_recalls_memories(cat)</code>","text":"<p>Hook after semantic search in memories.</p> <p>The hook is executed just after the Cat searches for the meaningful context in memories and stores it in the Working Memory.</p> <p>Parameters:</p> Name Type Description Default <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required Source code in <code>cat/mad_hatter/core_plugin/hooks/flow.py</code> <pre><code>@hook(priority=0)\ndef after_cat_recalls_memories(cat) -&gt; None:\n    \"\"\"Hook after semantic search in memories.\n\n    The hook is executed just after the Cat searches for the meaningful context in memories\n    and stores it in the *Working Memory*.\n\n    Parameters\n    ----------\n    cat : CheshireCat\n        Cheshire Cat instance.\n\n    \"\"\"\n    pass # do nothing\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/flow/#cat.mad_hatter.core_plugin.hooks.flow.before_cat_bootstrap","title":"<code>before_cat_bootstrap(cat)</code>","text":"<p>Hook into the Cat start up.</p> <p>Bootstrapping is the process of loading the plugins, the natural language objects (e.g. the LLM), the memories, the Agent Manager and the Rabbit Hole.</p> <p>This hook allows to intercept such process and is executed in the middle of plugins and natural language objects loading.</p> <p>This hook can be used to set or store variables to be propagated to subsequent loaded objects.</p> <p>Parameters:</p> Name Type Description Default <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required Source code in <code>cat/mad_hatter/core_plugin/hooks/flow.py</code> <pre><code>@hook(priority=0)\ndef before_cat_bootstrap(cat) -&gt; None:\n    \"\"\"Hook into the Cat start up.\n\n    Bootstrapping is the process of loading the plugins, the natural language objects (e.g. the LLM),\n    the memories, the *Agent Manager* and the *Rabbit Hole*.\n\n    This hook allows to intercept such process and is executed in the middle of plugins and\n    natural language objects loading.\n\n    This hook can be used to set or store variables to be propagated to subsequent loaded objects.\n\n    Parameters\n    ----------\n    cat : CheshireCat\n        Cheshire Cat instance.\n    \"\"\"\n    pass # do nothing\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/flow/#cat.mad_hatter.core_plugin.hooks.flow.before_cat_reads_message","title":"<code>before_cat_reads_message(user_message_json, cat)</code>","text":"<p>Hook the incoming user's JSON dictionary.</p> <p>Allows to edit and enrich the incoming message received from the WebSocket connection.</p> <p>For instance, this hook can be used to translate the user's message before feeding it to the Cat. Another use case is to add custom keys to the JSON dictionary.</p> <p>The incoming message is a JSON dictionary with keys:     {         \"text\": message content     }</p> <p>Parameters:</p> Name Type Description Default <code>user_message_json</code> <code>dict</code> <p>JSON dictionary with the message received from the chat.</p> required <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required <p>Returns:</p> Name Type Description <code>user_message_json</code> <code>dict</code> <p>Edited JSON dictionary that will be fed to the Cat.</p> Notes <p>For example:</p> <pre><code>{\n    \"text\": \"Hello Cheshire Cat!\",\n    \"custom_key\": True\n}\n</code></pre> <p>where \"custom_key\" is a newly added key to the dictionary to store any data.</p> Source code in <code>cat/mad_hatter/core_plugin/hooks/flow.py</code> <pre><code>@hook(priority=0)\ndef before_cat_reads_message(user_message_json: dict, cat) -&gt; dict:\n    \"\"\"Hook the incoming user's JSON dictionary.\n\n    Allows to edit and enrich the incoming message received from the WebSocket connection.\n\n    For instance, this hook can be used to translate the user's message before feeding it to the Cat.\n    Another use case is to add custom keys to the JSON dictionary.\n\n    The incoming message is a JSON dictionary with keys:\n        {\n            \"text\": message content\n        }\n\n    Parameters\n    ----------\n    user_message_json : dict\n        JSON dictionary with the message received from the chat.\n    cat : CheshireCat\n        Cheshire Cat instance.\n\n\n    Returns\n    -------\n    user_message_json : dict\n        Edited JSON dictionary that will be fed to the Cat.\n\n    Notes\n    -----\n    For example:\n\n        {\n            \"text\": \"Hello Cheshire Cat!\",\n            \"custom_key\": True\n        }\n\n    where \"custom_key\" is a newly added key to the dictionary to store any data.\n\n    \"\"\"\n    return user_message_json\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/flow/#cat.mad_hatter.core_plugin.hooks.flow.before_cat_recalls_declarative_memories","title":"<code>before_cat_recalls_declarative_memories(declarative_recall_config, cat)</code>","text":"<p>Hook into semantic search in memories.</p> <p>Allows to intercept when the Cat queries the memories using the embedded user's input.</p> <p>The hook is executed just before the Cat searches for the meaningful context in both memories and stores it in the Working Memory.</p> <p>The hook return the values for maximum number (k) of items to retrieve from memory and the score threshold applied to the query in the vector memory (items with score under threshold are not retrieved) It also returns the embedded query (embedding) and the conditions on recall (metadata).</p> <p>Parameters:</p> Name Type Description Default <code>declarative_recall_config</code> <code>dict</code> <p>Dictionary with data needed to recall declarative memories</p> required <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required <p>Returns:</p> Name Type Description <code>declarative_recall_config</code> <code>dict</code> <p>Edited dictionary that will be fed to the embedder.</p> Source code in <code>cat/mad_hatter/core_plugin/hooks/flow.py</code> <pre><code>@hook(priority=0)\ndef before_cat_recalls_declarative_memories(declarative_recall_config: dict, cat) -&gt; dict:\n    \"\"\"Hook into semantic search in memories.\n\n    Allows to intercept when the Cat queries the memories using the embedded user's input.\n\n    The hook is executed just before the Cat searches for the meaningful context in both memories\n    and stores it in the *Working Memory*.\n\n    The hook return the values for maximum number (k) of items to retrieve from memory and the score threshold applied\n    to the query in the vector memory (items with score under threshold are not retrieved)\n    It also returns the embedded query (embedding) and the conditions on recall (metadata).\n\n    Parameters\n    ----------\n    declarative_recall_config: dict\n        Dictionary with data needed to recall declarative memories\n    cat : CheshireCat\n        Cheshire Cat instance.\n\n    Returns\n    -------\n    declarative_recall_config: dict\n        Edited dictionary that will be fed to the embedder.\n\n    \"\"\"\n    return declarative_recall_config\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/flow/#cat.mad_hatter.core_plugin.hooks.flow.before_cat_recalls_episodic_memories","title":"<code>before_cat_recalls_episodic_memories(episodic_recall_config, cat)</code>","text":"<p>Hook into semantic search in memories.</p> <p>Allows to intercept when the Cat queries the memories using the embedded user's input.</p> <p>The hook is executed just before the Cat searches for the meaningful context in both memories and stores it in the Working Memory.</p> <p>The hook return the values for maximum number (k) of items to retrieve from memory and the score threshold applied to the query in the vector memory (items with score under threshold are not retrieved). It also returns the embedded query (embedding) and the conditions on recall (metadata).</p> <p>Parameters:</p> Name Type Description Default <code>episodic_recall_config</code> <code>dict</code> <p>Dictionary with data needed to recall episodic memories</p> required <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required <p>Returns:</p> Name Type Description <code>episodic_recall_config</code> <code>dict</code> <p>Edited dictionary that will be fed to the embedder.</p> Source code in <code>cat/mad_hatter/core_plugin/hooks/flow.py</code> <pre><code>@hook(priority=0)\ndef before_cat_recalls_episodic_memories(episodic_recall_config: dict, cat) -&gt; dict:\n    \"\"\"Hook into semantic search in memories.\n\n    Allows to intercept when the Cat queries the memories using the embedded user's input.\n\n    The hook is executed just before the Cat searches for the meaningful context in both memories\n    and stores it in the *Working Memory*.\n\n    The hook return the values for maximum number (k) of items to retrieve from memory and the score threshold applied\n    to the query in the vector memory (items with score under threshold are not retrieved).\n    It also returns the embedded query (embedding) and the conditions on recall (metadata).\n\n    Parameters\n    ----------\n    episodic_recall_config : dict\n        Dictionary with data needed to recall episodic memories\n    cat : CheshireCat\n        Cheshire Cat instance.\n\n    Returns\n    -------\n    episodic_recall_config: dict\n        Edited dictionary that will be fed to the embedder.\n\n    \"\"\"\n    return episodic_recall_config\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/flow/#cat.mad_hatter.core_plugin.hooks.flow.before_cat_recalls_memories","title":"<code>before_cat_recalls_memories(cat)</code>","text":"<p>Hook into semantic search in memories.</p> <p>Allows to intercept when the Cat queries the memories using the embedded user's input.</p> <p>The hook is executed just before the Cat searches for the meaningful context in both memories and stores it in the Working Memory.</p> <p>Parameters:</p> Name Type Description Default <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required Source code in <code>cat/mad_hatter/core_plugin/hooks/flow.py</code> <pre><code>@hook(priority=0)\ndef before_cat_recalls_memories(cat) -&gt; None:\n    \"\"\"Hook into semantic search in memories.\n\n    Allows to intercept when the Cat queries the memories using the embedded user's input.\n\n    The hook is executed just before the Cat searches for the meaningful context in both memories\n    and stores it in the *Working Memory*.\n\n    Parameters\n    ----------\n    cat : CheshireCat\n        Cheshire Cat instance.\n\n    \"\"\"\n    pass # do nothing\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/flow/#cat.mad_hatter.core_plugin.hooks.flow.before_cat_recalls_procedural_memories","title":"<code>before_cat_recalls_procedural_memories(procedural_recall_config, cat)</code>","text":"<p>Hook into semantic search in memories.</p> <p>Allows to intercept when the Cat queries the memories using the embedded user's input.</p> <p>The hook is executed just before the Cat searches for the meaningful context in both memories and stores it in the Working Memory.</p> <p>The hook return the values for maximum number (k) of items to retrieve from memory and the score threshold applied to the query in the vector memory (items with score under threshold are not retrieved) It also returns the embedded query (embedding) and the conditions on recall (metadata).</p> <p>Parameters:</p> Name Type Description Default <code>procedural_recall_config</code> <code>dict</code> <p>Dictionary with data needed to recall tools from procedural memory</p> required <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required <p>Returns:</p> Name Type Description <code>procedural_recall_config</code> <code>dict</code> <p>Edited dictionary that will be fed to the embedder.</p> Source code in <code>cat/mad_hatter/core_plugin/hooks/flow.py</code> <pre><code>@hook(priority=0)\ndef before_cat_recalls_procedural_memories(procedural_recall_config: dict, cat) -&gt; dict:\n    \"\"\"Hook into semantic search in memories.\n\n    Allows to intercept when the Cat queries the memories using the embedded user's input.\n\n    The hook is executed just before the Cat searches for the meaningful context in both memories\n    and stores it in the *Working Memory*.\n\n    The hook return the values for maximum number (k) of items to retrieve from memory and the score threshold applied\n    to the query in the vector memory (items with score under threshold are not retrieved)\n    It also returns the embedded query (embedding) and the conditions on recall (metadata).\n\n    Parameters\n    ----------\n    procedural_recall_config: dict\n        Dictionary with data needed to recall tools from procedural memory\n    cat : CheshireCat\n        Cheshire Cat instance.\n\n    Returns\n    -------\n    procedural_recall_config: dict\n        Edited dictionary that will be fed to the embedder.\n\n    \"\"\"\n    return procedural_recall_config\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/flow/#cat.mad_hatter.core_plugin.hooks.flow.before_cat_sends_message","title":"<code>before_cat_sends_message(message, cat)</code>","text":"<p>Hook the outgoing Cat's message.</p> <p>Allows to edit the JSON dictionary that will be sent to the client via WebSocket connection.</p> <p>This hook can be used to edit the message sent to the user or to add keys to the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>dict</code> <p>JSON dictionary to be sent to the WebSocket client.</p> required <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required <p>Returns:</p> Name Type Description <code>message</code> <code>dict</code> <p>Edited JSON dictionary with the Cat's answer.</p> Notes <p>Default <code>message</code> is::</p> <pre><code>    {\n        \"type\": \"chat\",\n        \"content\": cat_message[\"output\"],\n        \"why\": {\n            \"input\": cat_message[\"input\"],\n            \"output\": cat_message[\"output\"],\n            \"intermediate_steps\": cat_message[\"intermediate_steps\"],\n            \"memory\": {\n                \"vectors\": {\n                    \"episodic\": episodic_report,\n                    \"declarative\": declarative_report\n                }\n            },\n        },\n    }\n</code></pre> Source code in <code>cat/mad_hatter/core_plugin/hooks/flow.py</code> <pre><code>@hook(priority=0)\ndef before_cat_sends_message(message: dict, cat) -&gt; dict:\n    \"\"\"Hook the outgoing Cat's message.\n\n    Allows to edit the JSON dictionary that will be sent to the client via WebSocket connection.\n\n    This hook can be used to edit the message sent to the user or to add keys to the dictionary.\n\n    Parameters\n    ----------\n    message : dict\n        JSON dictionary to be sent to the WebSocket client.\n    cat : CheshireCat\n        Cheshire Cat instance.\n\n    Returns\n    -------\n    message : dict\n        Edited JSON dictionary with the Cat's answer.\n\n    Notes\n    -----\n    Default `message` is::\n\n            {\n                \"type\": \"chat\",\n                \"content\": cat_message[\"output\"],\n                \"why\": {\n                    \"input\": cat_message[\"input\"],\n                    \"output\": cat_message[\"output\"],\n                    \"intermediate_steps\": cat_message[\"intermediate_steps\"],\n                    \"memory\": {\n                        \"vectors\": {\n                            \"episodic\": episodic_report,\n                            \"declarative\": declarative_report\n                        }\n                    },\n                },\n            }\n\n    \"\"\"\n\n    return message\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/flow/#cat.mad_hatter.core_plugin.hooks.flow.before_cat_stores_episodic_memory","title":"<code>before_cat_stores_episodic_memory(doc, cat)</code>","text":"<p>Hook the user message <code>Document</code> before is inserted in the vector memory.</p> <p>Allows editing and enhancing a single <code>Document</code> before the Cat add it to the episodic vector memory.</p> <p>Parameters:</p> Name Type Description Default <code>doc</code> <code>Document</code> <p>Langchain <code>Document</code> to be inserted in memory.</p> required <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required <p>Returns:</p> Name Type Description <code>doc</code> <code>Document</code> <p>Langchain <code>Document</code> that is added in the episodic vector memory.</p> Notes <p>The <code>Document</code> has two properties::</p> <pre><code>`page_content`: the string with the text to save in memory;\n`metadata`: a dictionary with at least two keys:\n    `source`: where the text comes from;\n    `when`: timestamp to track when it's been uploaded.\n</code></pre> Source code in <code>cat/mad_hatter/core_plugin/hooks/flow.py</code> <pre><code>@hook(priority=0)\ndef before_cat_stores_episodic_memory(doc: Document, cat) -&gt; Document:\n    \"\"\"Hook the user message `Document` before is inserted in the vector memory.\n\n    Allows editing and enhancing a single `Document` before the Cat add it to the episodic vector memory.\n\n    Parameters\n    ----------\n    doc : Document\n        Langchain `Document` to be inserted in memory.\n    cat : CheshireCat\n        Cheshire Cat instance.\n\n    Returns\n    -------\n    doc : Document\n        Langchain `Document` that is added in the episodic vector memory.\n\n    Notes\n    -----\n    The `Document` has two properties::\n\n        `page_content`: the string with the text to save in memory;\n        `metadata`: a dictionary with at least two keys:\n            `source`: where the text comes from;\n            `when`: timestamp to track when it's been uploaded.\n\n    \"\"\"\n    return doc\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/flow/#cat.mad_hatter.core_plugin.hooks.flow.cat_recall_query","title":"<code>cat_recall_query(user_message, cat)</code>","text":"<p>Hook the semantic search query.</p> <p>This hook allows to edit the user's message used as a query for context retrieval from memories. As a result, the retrieved context can be conditioned editing the user's message.</p> <p>Parameters:</p> Name Type Description Default <code>user_message</code> <code>str</code> <p>String with the text received from the user.</p> required <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance to exploit the Cat's methods.</p> required <p>Returns:</p> Type Description <code>Edited string to be used for context retrieval in memory. The returned string is further stored in the</code> <code>Working Memory at `cat.working_memory.recall_query`.</code> Notes <p>For example, this hook is a suitable to perform Hypothetical Document Embedding (HyDE). HyDE [1]_ strategy exploits the user's message to generate a hypothetical answer. This is then used to recall the relevant context from the memory. An official plugin is available to test this technique.</p> References <p>[1] Gao, L., Ma, X., Lin, J., &amp; Callan, J. (2022). Precise Zero-Shot Dense Retrieval without Relevance Labels.    arXiv preprint arXiv:2212.10496.</p> Source code in <code>cat/mad_hatter/core_plugin/hooks/flow.py</code> <pre><code>@hook(priority=0)\ndef cat_recall_query(user_message: str, cat) -&gt; str:\n    \"\"\"Hook the semantic search query.\n\n    This hook allows to edit the user's message used as a query for context retrieval from memories.\n    As a result, the retrieved context can be conditioned editing the user's message.\n\n    Parameters\n    ----------\n    user_message : str\n        String with the text received from the user.\n    cat : CheshireCat\n        Cheshire Cat instance to exploit the Cat's methods.\n\n    Returns\n    -------\n    Edited string to be used for context retrieval in memory. The returned string is further stored in the\n    Working Memory at `cat.working_memory.recall_query`.\n\n    Notes\n    -----\n    For example, this hook is a suitable to perform Hypothetical Document Embedding (HyDE).\n    HyDE [1]_ strategy exploits the user's message to generate a hypothetical answer. This is then used to recall\n    the relevant context from the memory.\n    An official plugin is available to test this technique.\n\n    References\n    ----------\n    [1] Gao, L., Ma, X., Lin, J., &amp; Callan, J. (2022). Precise Zero-Shot Dense Retrieval without Relevance Labels.\n       arXiv preprint arXiv:2212.10496.\n\n    \"\"\"\n\n    # here we just return the latest user message as is\n    return user_message\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/prompt/","title":"prompt","text":"<p>Hooks to modify the prompts.</p> <p>Here is a collection of methods to hook the prompts components that instruct the Agent.</p>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/prompt/#cat.mad_hatter.core_plugin.hooks.prompt.agent_prompt_instructions","title":"<code>agent_prompt_instructions(instructions, cat)</code>","text":"<p>Hook the instruction prompt.</p> <p>Allows to edit the instructions that the Cat feeds to the Agent.</p> <p>The instructions are then composed with two other prompt components, i.e. <code>agent_prompt_prefix</code> and <code>agent_prompt_suffix</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required <p>Returns:</p> Name Type Description <code>instructions</code> <code>str</code> <p>The string with the set of instructions informing the Agent on how to format its reasoning to select a proper tool for the task at hand.</p> Notes <p>This prompt explains the Agent how to format its chain of reasoning when deciding when and which tool to use. Default prompt splits the reasoning in::</p> <pre><code>- Thought: Yes/No answer to the question \"Do I need to use a tool?\";\n\n- Action: a tool chosen among the available ones;\n\n- Action Input: input to be passed to the tool. This is inferred as explained in the tool docstring;\n\n- Observation: description of the result (which is the output of the @tool decorated function found in plugins).\n</code></pre> Source code in <code>cat/mad_hatter/core_plugin/hooks/prompt.py</code> <pre><code>@hook(priority=0)\ndef agent_prompt_instructions(instructions: str, cat) -&gt; str:\n    \"\"\"Hook the instruction prompt.\n\n    Allows to edit the instructions that the Cat feeds to the *Agent*.\n\n    The instructions are then composed with two other prompt components, i.e. `agent_prompt_prefix`\n    and `agent_prompt_suffix`.\n\n    Parameters\n    ----------\n    cat : CheshireCat\n        Cheshire Cat instance.\n\n    Returns\n    -------\n    instructions : str\n        The string with the set of instructions informing the *Agent* on how to format its reasoning to select a\n        proper tool for the task at hand.\n\n    Notes\n    -----\n    This prompt explains the *Agent* how to format its chain of reasoning when deciding when and which tool to use.\n    Default prompt splits the reasoning in::\n\n        - Thought: Yes/No answer to the question \"Do I need to use a tool?\";\n\n        - Action: a tool chosen among the available ones;\n\n        - Action Input: input to be passed to the tool. This is inferred as explained in the tool docstring;\n\n        - Observation: description of the result (which is the output of the @tool decorated function found in plugins).\n\n    \"\"\"\n\n    return instructions\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/prompt/#cat.mad_hatter.core_plugin.hooks.prompt.agent_prompt_prefix","title":"<code>agent_prompt_prefix(prefix, cat)</code>","text":"<p>Hook the main prompt prefix.</p> <p>Allows to edit the prefix of the Main Prompt that the Cat feeds to the Agent.</p> <p>The prefix is then composed with two other prompts components, i.e. the <code>agent_prompt_instructions</code> and the <code>agent_prompt_suffix</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required <p>Returns:</p> Name Type Description <code>prefix</code> <code>str</code> <p>The prefix string to be composed with the other two components to make up the Main Prompt.</p> Notes <p>The default prefix describe who the AI is and how it is expected to answer the Human. The next part of the prompt (generated form the Agent) contains the list of available Tools.</p> Source code in <code>cat/mad_hatter/core_plugin/hooks/prompt.py</code> <pre><code>@hook(priority=0)\ndef agent_prompt_prefix(prefix, cat) -&gt; str:\n    \"\"\"Hook the main prompt prefix.\n\n    Allows to edit the prefix of the *Main Prompt* that the Cat feeds to the *Agent*.\n\n    The prefix is then composed with two other prompts components, i.e. the `agent_prompt_instructions`\n    and the `agent_prompt_suffix`.\n\n    Parameters\n    ----------\n    cat : CheshireCat\n        Cheshire Cat instance.\n\n    Returns\n    -------\n    prefix : str\n        The prefix string to be composed with the other two components to make up the *Main Prompt*.\n\n    Notes\n    -----\n    The default prefix describe who the AI is and how it is expected to answer the Human.\n    The next part of the prompt (generated form the *Agent*) contains the list of available Tools.\n\n    \"\"\"\n\n    return prefix\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/prompt/#cat.mad_hatter.core_plugin.hooks.prompt.agent_prompt_suffix","title":"<code>agent_prompt_suffix(prompt_suffix, cat)</code>","text":"<p>Hook the main prompt suffix.</p> <p>Allows to edit the suffix of the Main Prompt that the Cat feeds to the Agent.</p> <p>The suffix is then composed with two other prompts components, i.e. the <code>agent_prompt_prefix</code> and the <code>agent_prompt_instructions</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required <p>Returns:</p> Name Type Description <code>suffix</code> <code>str</code> <p>The suffix string to be composed with the other two components that make up the Main Prompt.</p> Notes <p>The default suffix has a few placeholders: - {episodic_memory} provides memories retrieved from episodic memory (past conversations) - {declarative_memory} provides memories retrieved from declarative memory (uploaded documents) - {chat_history} provides the Agent the recent conversation history - {input} provides the last user's input - {agent_scratchpad} is where the Agent can concatenate tools use and multiple calls to the LLM.</p> Source code in <code>cat/mad_hatter/core_plugin/hooks/prompt.py</code> <pre><code>@hook(priority=0)\ndef agent_prompt_suffix(prompt_suffix: str, cat) -&gt; str:\n    \"\"\"Hook the main prompt suffix.\n\n    Allows to edit the suffix of the *Main Prompt* that the Cat feeds to the *Agent*.\n\n    The suffix is then composed with two other prompts components, i.e. the `agent_prompt_prefix`\n    and the `agent_prompt_instructions`.\n\n    Parameters\n    ----------\n    cat : CheshireCat\n        Cheshire Cat instance.\n\n    Returns\n    -------\n    suffix : str\n        The suffix string to be composed with the other two components that make up the *Main Prompt*.\n\n    Notes\n    -----\n    The default suffix has a few placeholders:\n    - {episodic_memory} provides memories retrieved from *episodic* memory (past conversations)\n    - {declarative_memory} provides memories retrieved from *declarative* memory (uploaded documents)\n    - {chat_history} provides the *Agent* the recent conversation history\n    - {input} provides the last user's input\n    - {agent_scratchpad} is where the *Agent* can concatenate tools use and multiple calls to the LLM.\n\n    \"\"\"\n\n    return prompt_suffix\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/rabbithole/","title":"rabbithole","text":"<p>Hooks to modify the RabbitHole's documents ingestion.</p> <p>Here is a collection of methods to hook into the RabbitHole execution pipeline.</p> <p>These hooks allow to intercept the uploaded documents at different places before they are saved into memory.</p>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/rabbithole/#cat.mad_hatter.core_plugin.hooks.rabbithole.after_rabbithole_splitted_text","title":"<code>after_rabbithole_splitted_text(chunks, cat)</code>","text":"<p>Hook the <code>Document</code> after is split.</p> <p>Allows editing the list of <code>Document</code> right after the RabbitHole chunked them in smaller ones.</p> <p>Parameters:</p> Name Type Description Default <code>chunks</code> <code>List[Document]</code> <p>List of Langchain <code>Document</code>.</p> required <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required <p>Returns:</p> Name Type Description <code>chunks</code> <code>List[Document]</code> <p>List of modified chunked langchain documents to be stored in the episodic memory.</p> Source code in <code>cat/mad_hatter/core_plugin/hooks/rabbithole.py</code> <pre><code>@hook(priority=0)\ndef after_rabbithole_splitted_text(chunks: List[Document], cat) -&gt; List[Document]:\n    \"\"\"Hook the `Document` after is split.\n\n    Allows editing the list of `Document` right after the *RabbitHole* chunked them in smaller ones.\n\n    Parameters\n    ----------\n    chunks : List[Document]\n        List of Langchain `Document`.\n    cat : CheshireCat\n        Cheshire Cat instance.\n\n    Returns\n    -------\n    chunks : List[Document]\n        List of modified chunked langchain documents to be stored in the episodic memory.\n\n    \"\"\"\n\n    return chunks\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/rabbithole/#cat.mad_hatter.core_plugin.hooks.rabbithole.after_rabbithole_stored_documents","title":"<code>after_rabbithole_stored_documents(source, stored_points, cat)</code>","text":"<p>Hook the Document after is inserted in the vector memory.</p> <p>Allows editing and enhancing the list of Document after is inserted in the vector memory.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <p>Name of ingested file/url</p> required <code>docs</code> <code>List[PointStruct]</code> <p>List of Qdrant PointStruct just inserted into the db.</p> required <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required <p>Returns:</p> Type Description <code>None</code> Source code in <code>cat/mad_hatter/core_plugin/hooks/rabbithole.py</code> <pre><code>@hook(priority=0)\ndef after_rabbithole_stored_documents(source, stored_points: List[PointStruct], cat) -&gt; None:\n    \"\"\"Hook the Document after is inserted in the vector memory.\n\n    Allows editing and enhancing the list of Document after is inserted in the vector memory.\n\n    Parameters\n    ----------\n    source: str\n        Name of ingested file/url\n    docs : List[PointStruct]\n        List of Qdrant PointStruct just inserted into the db.\n    cat : CheshireCat\n        Cheshire Cat instance.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    pass\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/rabbithole/#cat.mad_hatter.core_plugin.hooks.rabbithole.before_rabbithole_insert_memory","title":"<code>before_rabbithole_insert_memory(doc, cat)</code>","text":"<p>Hook the <code>Document</code> before is inserted in the vector memory.</p> <p>Allows editing and enhancing a single <code>Document</code> before the RabbitHole add it to the declarative vector memory.</p> <p>Parameters:</p> Name Type Description Default <code>doc</code> <code>Document</code> <p>Langchain <code>Document</code> to be inserted in memory.</p> required <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required <p>Returns:</p> Name Type Description <code>doc</code> <code>Document</code> <p>Langchain <code>Document</code> that is added in the declarative vector memory.</p> Notes <p>The <code>Document</code> has two properties::</p> <pre><code>`page_content`: the string with the text to save in memory;\n`metadata`: a dictionary with at least two keys:\n    `source`: where the text comes from;\n    `when`: timestamp to track when it's been uploaded.\n</code></pre> Source code in <code>cat/mad_hatter/core_plugin/hooks/rabbithole.py</code> <pre><code>@hook(priority=0)\ndef before_rabbithole_insert_memory(doc: Document, cat) -&gt; Document:\n    \"\"\"Hook the `Document` before is inserted in the vector memory.\n\n    Allows editing and enhancing a single `Document` before the *RabbitHole* add it to the declarative vector memory.\n\n    Parameters\n    ----------\n    doc : Document\n        Langchain `Document` to be inserted in memory.\n    cat : CheshireCat\n        Cheshire Cat instance.\n\n    Returns\n    -------\n    doc : Document\n        Langchain `Document` that is added in the declarative vector memory.\n\n    Notes\n    -----\n    The `Document` has two properties::\n\n        `page_content`: the string with the text to save in memory;\n        `metadata`: a dictionary with at least two keys:\n            `source`: where the text comes from;\n            `when`: timestamp to track when it's been uploaded.\n\n    \"\"\"\n    return doc\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/rabbithole/#cat.mad_hatter.core_plugin.hooks.rabbithole.before_rabbithole_splits_text","title":"<code>before_rabbithole_splits_text(docs, cat)</code>","text":"<p>Hook the <code>Documents</code> before they are split into chunks.</p> <p>Allows editing the uploaded document main Document(s) before the RabbitHole recursively splits it in shorter ones. Please note that this is a list because parsers can output one or more Document, that are afterwards splitted.</p> <p>For instance, the hook allows to change the text or edit/add metadata.</p> <p>Parameters:</p> Name Type Description Default <code>docs</code> <code>List[Document]</code> <p>Langchain <code>Document</code>s resulted after parsing the file uploaded in the RabbitHole.</p> required <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required <p>Returns:</p> Name Type Description <code>docs</code> <code>List[Document]</code> <p>Edited Langchain <code>Document</code>s.</p> Source code in <code>cat/mad_hatter/core_plugin/hooks/rabbithole.py</code> <pre><code>@hook(priority=0)\ndef before_rabbithole_splits_text(docs: List[Document], cat) -&gt; List[Document]:\n    \"\"\"Hook the `Documents` before they are split into chunks.\n\n    Allows editing the uploaded document main Document(s) before the *RabbitHole* recursively splits it in shorter ones.\n    Please note that this is a list because parsers can output one or more Document, that are afterwards splitted.\n\n    For instance, the hook allows to change the text or edit/add metadata.\n\n    Parameters\n    ----------\n    docs : List[Document]\n        Langchain `Document`s resulted after parsing the file uploaded in the *RabbitHole*.\n    cat : CheshireCat\n        Cheshire Cat instance.\n\n    Returns\n    -------\n    docs : List[Document]\n        Edited Langchain `Document`s.\n\n    \"\"\"\n\n    return docs\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/rabbithole/#cat.mad_hatter.core_plugin.hooks.rabbithole.before_rabbithole_stores_documents","title":"<code>before_rabbithole_stores_documents(docs, cat)</code>","text":"<p>Hook into the memory insertion pipeline.</p> <p>Allows modifying how the list of <code>Document</code> is inserted in the vector memory.</p> <p>For example, this hook is a good point to summarize the incoming documents and save both original and summarized contents. An official plugin is available to test this procedure.</p> <p>Parameters:</p> Name Type Description Default <code>docs</code> <code>List[Document]</code> <p>List of Langchain <code>Document</code> to be edited.</p> required <code>cat</code> <p>Cheshire Cat instance.</p> required <p>Returns:</p> Name Type Description <code>docs</code> <code>List[Document]</code> <p>List of edited Langchain documents.</p> Source code in <code>cat/mad_hatter/core_plugin/hooks/rabbithole.py</code> <pre><code>@hook(priority=0)\ndef before_rabbithole_stores_documents(docs: List[Document], cat) -&gt; List[Document]:\n    \"\"\"Hook into the memory insertion pipeline.\n\n    Allows modifying how the list of `Document` is inserted in the vector memory.\n\n    For example, this hook is a good point to summarize the incoming documents and save both original and\n    summarized contents.\n    An official plugin is available to test this procedure.\n\n    Parameters\n    ----------\n    docs : List[Document]\n        List of Langchain `Document` to be edited.\n    cat: CheshireCat\n        Cheshire Cat instance.\n\n    Returns\n    -------\n    docs : List[Document]\n        List of edited Langchain documents.\n\n    \"\"\"\n\n    return docs\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/rabbithole/#cat.mad_hatter.core_plugin.hooks.rabbithole.rabbithole_instantiates_parsers","title":"<code>rabbithole_instantiates_parsers(file_handlers, cat)</code>","text":"<p>Hook the available parsers for ingesting files in the declarative memory.</p> <p>Allows replacing or extending existing supported mime types and related parsers to customize the file ingestion.</p> <p>Parameters:</p> Name Type Description Default <code>file_handlers</code> <code>dict</code> <p>Keys are the supported mime types and values are the related parsers.</p> required <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required <p>Returns:</p> Name Type Description <code>file_handlers</code> <code>dict</code> <p>Edited dictionary of supported mime types and related parsers.</p> Source code in <code>cat/mad_hatter/core_plugin/hooks/rabbithole.py</code> <pre><code>@hook(priority=0)\ndef rabbithole_instantiates_parsers(file_handlers: dict, cat) -&gt; dict:\n    \"\"\"Hook the available parsers for ingesting files in the declarative memory.\n\n    Allows replacing or extending existing supported mime types and related parsers to customize the file ingestion.\n\n    Parameters\n    ----------\n    file_handlers : dict\n        Keys are the supported mime types and values are the related parsers.\n    cat : CheshireCat\n        Cheshire Cat instance.\n\n    Returns\n    -------\n    file_handlers : dict\n        Edited dictionary of supported mime types and related parsers.\n    \"\"\"\n    return file_handlers\n</code></pre>"},{"location":"technical/API_Documentation/mad_hatter/core_plugin/hooks/rabbithole/#cat.mad_hatter.core_plugin.hooks.rabbithole.rabbithole_instantiates_splitter","title":"<code>rabbithole_instantiates_splitter(text_splitter, cat)</code>","text":"<p>Hook the splitter used to split text in chunks.</p> <p>Allows replacing the default text splitter to customize the splitting process.</p> <p>Parameters:</p> Name Type Description Default <code>text_splitter</code> <code>TextSplitter</code> <p>The text splitter used by default.</p> required <code>cat</code> <code>CheshireCat</code> <p>Cheshire Cat instance.</p> required <p>Returns:</p> Name Type Description <code>text_splitter</code> <code>TextSplitter</code> <p>An instance of a TextSplitter subclass.</p> Source code in <code>cat/mad_hatter/core_plugin/hooks/rabbithole.py</code> <pre><code>@hook(priority=0)\ndef rabbithole_instantiates_splitter(text_splitter: TextSplitter, cat) -&gt; TextSplitter:\n    \"\"\"Hook the splitter used to split text in chunks.\n\n    Allows replacing the default text splitter to customize the splitting process.\n\n    Parameters\n    ----------\n    text_splitter : TextSplitter\n        The text splitter used by default.\n    cat : CheshireCat\n        Cheshire Cat instance.\n\n    Returns\n    -------\n    text_splitter : TextSplitter\n        An instance of a TextSplitter subclass.\n    \"\"\"\n\n    # example on how to change chunking\n    # text_splitter._chunk_size = 64\n    # text_splitter._chunk_overlap = 8\n\n    return text_splitter\n</code></pre>"},{"location":"technical/API_Documentation/memory/vector_memory/","title":"vector_memory","text":""},{"location":"technical/API_Documentation/memory/vector_memory_collection/","title":"vector_memory_collection","text":""},{"location":"technical/API_Documentation/memory/vector_memory_collection/#cat.memory.vector_memory_collection.VectorMemoryCollection","title":"<code>VectorMemoryCollection</code>","text":"Source code in <code>cat/memory/vector_memory_collection.py</code> <pre><code>class VectorMemoryCollection():\n    def __init__(\n        self,\n        client: Any,\n        collection_name: str,\n        embedder_name: str,\n        embedder_size: int,\n    ):\n\n        # Set attributes (metadata on the embedder are useful because it may change at runtime)\n        self.client = client\n        self.collection_name = collection_name\n        self.embedder_name = embedder_name\n        self.embedder_size = embedder_size\n\n        # Check if memory collection exists also in vectorDB, otherwise create it\n        self.create_db_collection_if_not_exists()\n\n        # Check db collection vector size is same as embedder size\n        self.check_embedding_size()\n\n        # log collection info\n        log.debug(f\"Collection {self.collection_name}:\")\n        log.debug(self.client.get_collection(self.collection_name))\n\n\n    def check_embedding_size(self):\n        # having the same size does not necessarily imply being the same embedder\n        # having vectors with the same size but from diffent embedder in the same vector space is wrong\n        same_size = (\n            self.client.get_collection(self.collection_name).config.params.vectors.size\n            == self.embedder_size\n        )\n        alias = self.embedder_name + \"_\" + self.collection_name\n        if (\n            alias\n            == self.client.get_collection_aliases(self.collection_name)\n            .aliases[0]\n            .alias_name\n            and same_size\n        ):\n            log.debug(f'Collection \"{self.collection_name}\" has the same embedder')\n        else:\n            log.warning(f'Collection \"{self.collection_name}\" has different embedder')\n            # Memory snapshot saving can be turned off in the .env file with:\n            # SAVE_MEMORY_SNAPSHOTS=false\n            if os.getenv(\"SAVE_MEMORY_SNAPSHOTS\") == \"true\":\n                # dump collection on disk before deleting\n                self.save_dump()\n                log.info(f\"Dump '{self.collection_name}' completed\")\n\n            self.client.delete_collection(self.collection_name)\n            log.warning(f\"Collection '{self.collection_name}' deleted\")\n            self.create_collection()\n\n\n    def create_db_collection_if_not_exists(self):\n        # is collection present in DB?\n        collections_response = self.client.get_collections()\n        for c in collections_response.collections:\n            if c.name == self.collection_name:\n                # collection exists. Do nothing\n                log.info(\n                    f\"Collection '{self.collection_name}' already present in vector store\"\n                )\n                return\n\n        self.create_collection()\n\n    # create collection\n    def create_collection(self):\n        log.warning(f\"Creating collection '{self.collection_name}' ...\")\n        self.client.recreate_collection(\n            collection_name=self.collection_name,\n            vectors_config=VectorParams(\n                size=self.embedder_size, distance=Distance.COSINE\n            ),\n            # hybrid mode: original vector on Disk, quantized vector in RAM\n            optimizers_config=OptimizersConfigDiff(memmap_threshold=20000),\n            quantization_config=ScalarQuantization(\n                scalar=ScalarQuantizationConfig(\n                    type=ScalarType.INT8, quantile=0.95, always_ram=True\n                )\n            ),\n            # shard_number=3,\n        )\n\n        self.client.update_collection_aliases(\n            change_aliases_operations=[\n                CreateAliasOperation(\n                    create_alias=CreateAlias(\n                        collection_name=self.collection_name,\n                        alias_name=self.embedder_name + \"_\" + self.collection_name,\n                    )\n                )\n            ]\n        )\n\n    # adapted from https://github.com/langchain-ai/langchain/blob/bfc12a4a7644cfc4d832cc4023086a7a5374f46a/libs/langchain/langchain/vectorstores/qdrant.py#L1965\n    def _qdrant_filter_from_dict(self, filter: dict) -&gt; Filter:\n\n        if not filter:\n            return None\n\n        return Filter(\n            must=[\n                condition\n                for key, value in filter.items()\n                for condition in self._build_condition(key, value)\n            ]\n        )\n\n    # adapted from https://github.com/langchain-ai/langchain/blob/bfc12a4a7644cfc4d832cc4023086a7a5374f46a/libs/langchain/langchain/vectorstores/qdrant.py#L1941\n    def _build_condition(self, key: str, value: Any) -&gt; List[FieldCondition]:\n\n        out = []\n\n        if isinstance(value, dict):\n            for _key, value in value.items():\n                out.extend(self._build_condition(f\"{key}.{_key}\", value))\n        elif isinstance(value, list):\n            for _value in value:\n                if isinstance(_value, dict):\n                    out.extend(self._build_condition(f\"{key}[]\", _value))\n                else:\n                    out.extend(self._build_condition(f\"{key}\", _value))\n        else:\n            out.append(\n                FieldCondition(\n                    key=f\"metadata.{key}\",\n                    match=MatchValue(value=value),\n                )\n            )\n\n        return out\n\n    def add_point(\n        self,\n        content: str,\n        vector: Iterable,\n        metadata: dict = None,\n        id: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; List[str]:\n        \"\"\"Add a point (and its metadata) to the vectorstore.\n\n        Args:\n            text: original text.\n            vector: Embedding vector.\n            metadata: Optional metadata dict associated with the text.\n            id:\n                Optional id to associate with the point. Id has to be a uuid-like string.\n\n        Returns:\n            Point id as saved into the vectorstore.\n        \"\"\"\n\n        # TODO: may be adapted to upload batches of points as langchain does.\n        # Not necessary now as the bottleneck is the embedder\n        point = PointStruct(\n                    id=id or uuid.uuid4().hex,\n                    payload={\n                        \"page_content\": content,\n                        \"metadata\": metadata,\n                    },\n                    vector=vector\n                )\n\n        update_status = self.client.upsert(\n            collection_name=self.collection_name,\n            points=[point],\n            **kwargs\n        )\n\n        if update_status.status == \"completed\":\n            # returnign stored point\n            return point\n        else:\n            return None\n\n    def delete_points_by_metadata_filter(self, metadata=None):\n        res = self.client.delete(\n            collection_name=self.collection_name,\n            points_selector=self._qdrant_filter_from_dict(metadata),\n        )\n        return res\n\n    # delete point in collection\n    def delete_points(self, points_ids):\n        res = self.client.delete(\n            collection_name=self.collection_name,\n            points_selector=points_ids,\n        )\n        return res\n\n    # retrieve similar memories from embedding\n    def recall_memories_from_embedding(\n        self, embedding, metadata=None, k=5, threshold=None\n    ):\n        # retrieve memories\n        memories = self.client.search(\n            collection_name=self.collection_name,\n            query_vector=embedding,\n            query_filter=self._qdrant_filter_from_dict(metadata),\n            with_payload=True,\n            with_vectors=True,\n            limit=k,\n            score_threshold=threshold,\n            search_params=SearchParams(\n                quantization=QuantizationSearchParams(\n                    ignore=False,\n                    rescore=True,\n                    oversampling=2.0 # Available as of v1.3.0\n                )\n            ),\n        )\n\n        # convert Qdrant points to langchain.Document        \n        langchain_documents_from_points = []\n        for m in memories:\n            langchain_documents_from_points.append(\n                (\n                    Document(\n                        page_content=m.payload.get(\"page_content\"),\n                        metadata=m.payload.get(\"metadata\") or {},\n                    ),\n                    m.score,\n                    m.vector,\n                    m.id,\n                )\n            )\n\n        # we'll move out of langchain conventions soon and have our own cat Document\n        # for doc, score, vector in langchain_documents_from_points:\n        #    doc.lc_kwargs = None\n\n        return langchain_documents_from_points\n\n    # retrieve all the points in the collection\n    def get_all_points(self):\n        # retrieving the points\n        all_points, _ = self.client.scroll(\n            collection_name=self.collection_name,\n            with_vectors=True,\n            limit=10000,  # yeah, good for now dear :*\n        )\n\n        return all_points\n\n    def db_is_remote(self):\n        return isinstance(self.client._client, QdrantRemote)\n\n    # dump collection on disk before deleting\n    def save_dump(self, folder=\"dormouse/\"):\n        # only do snapshotting if using remote Qdrant\n        if not self.db_is_remote():\n            return\n\n        host = self.client._client._host\n        port = self.client._client._port\n\n        if os.path.isdir(folder):\n            log.info(f\"Directory dormouse exists\")\n        else:\n            log.warning(f\"Directory dormouse does NOT exists, creating it.\")\n            os.mkdir(folder)\n\n        self.snapshot_info = self.client.create_snapshot(\n            collection_name=self.collection_name\n        )\n        snapshot_url_in = (\n            \"http://\"\n            + str(host)\n            + \":\"\n            + str(port)\n            + \"/collections/\"\n            + self.collection_name\n            + \"/snapshots/\"\n            + self.snapshot_info.name\n        )\n        snapshot_url_out = folder + self.snapshot_info.name\n        # rename snapshots for a easyer restore in the future\n        alias = (\n            self.client.get_collection_aliases(self.collection_name)\n            .aliases[0]\n            .alias_name\n        )\n        response = requests.get(snapshot_url_in)\n        open(snapshot_url_out, \"wb\").write(response.content)\n        new_name = folder + alias.replace(\"/\", \"-\") + \".snapshot\"\n        os.rename(snapshot_url_out, new_name)\n        for s in self.client.list_snapshots(self.collection_name):\n            self.client.delete_snapshot(\n                collection_name=self.collection_name, snapshot_name=s.name\n            )\n        log.warning(f'Dump \"{new_name}\" completed')\n</code></pre>"},{"location":"technical/API_Documentation/memory/vector_memory_collection/#cat.memory.vector_memory_collection.VectorMemoryCollection.add_point","title":"<code>add_point(content, vector, metadata=None, id=None, **kwargs)</code>","text":"<p>Add a point (and its metadata) to the vectorstore.</p> <p>Args:     text: original text.     vector: Embedding vector.     metadata: Optional metadata dict associated with the text.     id:         Optional id to associate with the point. Id has to be a uuid-like string.</p> <p>Returns:     Point id as saved into the vectorstore.</p> Source code in <code>cat/memory/vector_memory_collection.py</code> <pre><code>def add_point(\n    self,\n    content: str,\n    vector: Iterable,\n    metadata: dict = None,\n    id: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; List[str]:\n    \"\"\"Add a point (and its metadata) to the vectorstore.\n\n    Args:\n        text: original text.\n        vector: Embedding vector.\n        metadata: Optional metadata dict associated with the text.\n        id:\n            Optional id to associate with the point. Id has to be a uuid-like string.\n\n    Returns:\n        Point id as saved into the vectorstore.\n    \"\"\"\n\n    # TODO: may be adapted to upload batches of points as langchain does.\n    # Not necessary now as the bottleneck is the embedder\n    point = PointStruct(\n                id=id or uuid.uuid4().hex,\n                payload={\n                    \"page_content\": content,\n                    \"metadata\": metadata,\n                },\n                vector=vector\n            )\n\n    update_status = self.client.upsert(\n        collection_name=self.collection_name,\n        points=[point],\n        **kwargs\n    )\n\n    if update_status.status == \"completed\":\n        # returnign stored point\n        return point\n    else:\n        return None\n</code></pre>"},{"location":"technical/API_Documentation/memory/working_memory/","title":"working_memory","text":""},{"location":"technical/API_Documentation/memory/working_memory/#cat.memory.working_memory.WorkingMemory","title":"<code>WorkingMemory</code>","text":"<p>               Bases: <code>BaseModelDict</code></p> <p>Cat's volatile memory.</p> <p>Handy class that behaves like a <code>dict</code> to store temporary custom data.</p> <p>Returns:</p> Type Description <code>dict[str, list]</code> <p>Default instance is a dictionary with <code>history</code> key set to an empty list.</p> Notes <p>The constructor instantiates a dictionary with a <code>history</code> key set to an empty list that is further used to store the conversation turns between the Human and the AI.</p> Source code in <code>cat/memory/working_memory.py</code> <pre><code>class WorkingMemory(BaseModelDict):\n    \"\"\"Cat's volatile memory.\n\n    Handy class that behaves like a `dict` to store temporary custom data.\n\n    Returns\n    -------\n    dict[str, list]\n        Default instance is a dictionary with `history` key set to an empty list.\n\n    Notes\n    -----\n    The constructor instantiates a dictionary with a `history` key set to an empty list that is further used to store\n    the conversation turns between the Human and the AI.\n    \"\"\"\n\n    # stores conversation history\n    history: List = []\n    user_message_json : None | UserMessage = None\n    active_form: None | CatForm = None\n\n    # recalled memories attributes\n    recall_query: str = \"\"\n    episodic_memories: List = []\n    declarative_memories: List = []\n    procedural_memories: List = []\n\n    def update_conversation_history(self, who, message, why={}):\n        \"\"\"Update the conversation history.\n\n        The methods append to the history key the last three conversation turns.\n\n        Parameters\n        ----------\n        who : str\n            Who said the message. Can either be `Human` or `AI`.\n        message : str\n            The message said.\n\n        \"\"\"\n        # append latest message in conversation\n        self.history.append({\"who\": who, \"message\": message, \"why\": why, \"when\": time.time()})\n</code></pre>"},{"location":"technical/API_Documentation/memory/working_memory/#cat.memory.working_memory.WorkingMemory.update_conversation_history","title":"<code>update_conversation_history(who, message, why={})</code>","text":"<p>Update the conversation history.</p> <p>The methods append to the history key the last three conversation turns.</p> <p>Parameters:</p> Name Type Description Default <code>who</code> <code>str</code> <p>Who said the message. Can either be <code>Human</code> or <code>AI</code>.</p> required <code>message</code> <code>str</code> <p>The message said.</p> required Source code in <code>cat/memory/working_memory.py</code> <pre><code>def update_conversation_history(self, who, message, why={}):\n    \"\"\"Update the conversation history.\n\n    The methods append to the history key the last three conversation turns.\n\n    Parameters\n    ----------\n    who : str\n        Who said the message. Can either be `Human` or `AI`.\n    message : str\n        The message said.\n\n    \"\"\"\n    # append latest message in conversation\n    self.history.append({\"who\": who, \"message\": message, \"why\": why, \"when\": time.time()})\n</code></pre>"},{"location":"technical/API_Documentation/routes/settings/","title":"settings","text":""},{"location":"technical/API_Documentation/routes/settings/#cat.routes.settings.create_setting","title":"<code>create_setting(payload)</code>","text":"<p>Create a new setting in the database</p> Source code in <code>cat/routes/settings.py</code> <pre><code>@router.post(\"/\")\ndef create_setting(payload: models.SettingBody):\n    \"\"\"Create a new setting in the database\"\"\"\n\n    # complete the payload with setting_id and updated_at\n    payload = models.Setting(**payload.model_dump())\n\n    # save to DB\n    new_setting = crud.create_setting(payload)\n\n    return {\n        \"setting\": new_setting\n    }\n</code></pre>"},{"location":"technical/API_Documentation/routes/settings/#cat.routes.settings.delete_setting","title":"<code>delete_setting(settingId)</code>","text":"<p>Delete a specific setting in the database</p> Source code in <code>cat/routes/settings.py</code> <pre><code>@router.delete(\"/{settingId}\")\ndef delete_setting(settingId: str):\n    \"\"\"Delete a specific setting in the database\"\"\"\n\n    # does the setting exist?\n    setting = crud.get_setting_by_id(settingId)\n    if not setting:\n        raise HTTPException(\n            status_code = 404,\n            detail = {\n                \"error\": f\"No setting with this id: {settingId}\",\n            },\n        )\n\n    # delete\n    crud.delete_setting_by_id(settingId)\n\n    return {\n        \"deleted\": settingId\n    }\n</code></pre>"},{"location":"technical/API_Documentation/routes/settings/#cat.routes.settings.get_setting","title":"<code>get_setting(settingId)</code>","text":"<p>Get the a specific setting from the database</p> Source code in <code>cat/routes/settings.py</code> <pre><code>@router.get(\"/{settingId}\")\ndef get_setting(settingId: str):\n    \"\"\"Get the a specific setting from the database\"\"\"\n\n    setting = crud.get_setting_by_id(settingId)\n    if not setting:\n        raise HTTPException(\n            status_code = 404,\n            detail = {\n                \"error\": f\"No setting with this id: {settingId}\",\n            },\n        )\n    return {\n        \"setting\": setting\n    }\n</code></pre>"},{"location":"technical/API_Documentation/routes/settings/#cat.routes.settings.get_settings","title":"<code>get_settings(search='')</code>","text":"<p>Get the entire list of settings available in the database</p> Source code in <code>cat/routes/settings.py</code> <pre><code>@router.get(\"/\")\ndef get_settings(search: str = \"\"):\n    \"\"\"Get the entire list of settings available in the database\"\"\"\n\n    settings = crud.get_settings(search=search)\n\n    return {\n        \"settings\": settings\n    }\n</code></pre>"},{"location":"technical/API_Documentation/routes/settings/#cat.routes.settings.update_setting","title":"<code>update_setting(settingId, payload)</code>","text":"<p>Update a specific setting in the database if it exists</p> Source code in <code>cat/routes/settings.py</code> <pre><code>@router.put(\"/{settingId}\")\ndef update_setting(settingId: str, payload: models.SettingBody):\n    \"\"\"Update a specific setting in the database if it exists\"\"\"\n\n    # does the setting exist?\n    setting = crud.get_setting_by_id(settingId)\n    if not setting:\n        raise HTTPException(\n            status_code = 404,\n            detail = {\n                \"error\": f\"No setting with this id: {settingId}\",\n            },\n        )\n\n    # complete the payload with setting_id and updated_at\n    payload = models.Setting(**payload.model_dump())\n    payload.setting_id = settingId # force this to be the setting_id\n\n    # save to DB\n    updated_setting = crud.update_setting_by_id(payload)\n\n    return {\n        \"setting\": updated_setting\n    }\n</code></pre>"},{"location":"technical/advanced/api_auth/","title":"&#128272; API Authentication","text":""},{"location":"technical/advanced/api_auth/#api-authentication","title":"\ud83d\udd10 API Authentication","text":"<p>By default, the core APIs don't require any authorization, if you set the environment parameter <code>API_KEY</code> all endpoints will require an <code>access_token</code> header for authentication. Failure to provide the correct access token will result in a 403 error.</p> <p>Warning</p> <p>This kind of authentication is weak and it's intended for machine to machine communication, please do not rely on it and enforce other kind of stronger authentication such as OAuth2 for the client side.</p> <p>Example</p> <p>Authenticated API call:</p> PythonNode <pre><code>import requests\n\nserver_url = 'http://localhost:1865/'\napi_key = 'your-key-here'\naccess_token = {'access_token': api_key}\n\nresponse = requests.get(server_url, headers=access_token)\n\nif response.status_code == 200:\n    print(response.text)\nelse:\n    print('Error occurred: {}'.format(response.status_code))\n</code></pre> <pre><code>const request = require('request');\n\nconst serverUrl = 'http://localhost:1865/';\nconst apiKey = 'your-key-here';\nconst access_token = {'access_token': apiKey};\n\nrequest({url: serverUrl, headers: access_token}, (error, response, body) =&gt; {\n    if (error) {\n        console.error(error);\n    } else {\n        if (response.statusCode === 200) {\n            console.log(body);\n        } else {\n            console.error(`Error occurred: ${response.statusCode}`);\n        }\n    }\n});\n</code></pre> <p>By adding the variable to the <code>.env</code> file, all Swagger endpoints (<code>localhost:1865/docs</code>) will require authentication and can be accessed on the top right-hand corner of the page through the green Authorize button.</p>"},{"location":"technical/advanced/contributing/","title":"Contributing","text":""},{"location":"technical/advanced/contributing/#contributing","title":"Contributing","text":"<p>Thank you for considering code contribution. If you wanto to learn how the Cat works and join its development, there is a different installation process to follow.</p>"},{"location":"technical/advanced/contributing/#development-setup","title":"Development setup","text":"<ul> <li>Clone the repository on your machine</li> </ul> <pre><code>git clone https://github.com/cheshire-cat-ai/core.git cheshire-cat\n</code></pre> <ul> <li>Enter the created folder</li> </ul> <pre><code>cd cheshire-cat\n</code></pre> <ul> <li>Run docker container</li> </ul> <pre><code>docker compose up\n</code></pre> <p>The first time you run the <code>docker compose up</code> command, it will take several minutes to build the Docker Cat image. Once finished, the Cat will be living and running!  </p> <p>To stop the Cat hit CTRL-C in the terminal, you should see the logs stopping. Then run:</p> <pre><code>docker compose down\n</code></pre>"},{"location":"technical/advanced/contributing/#update-development-setup","title":"Update development setup","text":"<p>Remember to update often both your fork and your local clone. Before each session, follow these steps:</p> <ul> <li>Enter the folder where you cloned the repository</li> </ul> <pre><code>cd cheshire-cat\n</code></pre> <ul> <li>Pull updates from the GitHub repository</li> </ul> <pre><code>git pull\n</code></pre> <ul> <li>Build again the docker container</li> </ul> <pre><code>docker compose build --no-cache\n</code></pre> <ul> <li>Remove dangling images (optional)</li> </ul> <pre><code>docker rmi -f $(docker images -f \"dangling=true\" -q)\n</code></pre> <ul> <li>Run docker containers</li> </ul> <pre><code>docker compose up\n</code></pre>"},{"location":"technical/advanced/contributing/#your-first-code-contribution","title":"Your First Code Contribution","text":"<ol> <li>Checkout the <code>develop</code> branch (<code>git checkout -b develop</code> and then <code>git pull origin develop</code>)</li> <li>Create your Feature Branch (<code>git checkout -b feature/AmazingFeature</code>)</li> <li>Commit your Changes (<code>git commit -m 'Add some AmazingFeature'</code>)</li> <li>Push to the Branch (<code>git push origin feature/AmazingFeature</code>)</li> <li>Open a Pull Request against the <code>develop</code> branch (if it contains lots of code, please discuss it beforehand opening a issue)</li> </ol>"},{"location":"technical/advanced/contributing/#important-notes","title":"Important notes","text":"<ul> <li>try to discuss your contribution beforehand in an issue, to make an actually useful PR</li> <li>try to keep your PR small, single feature / fix and to the point</li> <li>branch out from <code>develop</code> and make your PR against <code>develop</code>; branch <code>main</code> is only used for releases</li> </ul>"},{"location":"technical/advanced/contributing/#improving-the-documentation","title":"Improving The Documentation","text":"<p>Docs contribution are highly valuable for the project. See details on how to help with the docs here.</p>"},{"location":"technical/advanced/memory_backup/","title":"How to backup the Long Term Memory","text":""},{"location":"technical/advanced/memory_backup/#memory-backup","title":"\ud83d\uddc2\ufe0f Memory Backup","text":""},{"location":"technical/advanced/memory_backup/#create-a-full-backup","title":"Create a full backup","text":"<p>To create a complete backup for the memories of your Cheshire Cat, you simply need to copy the <code>long_term_memory</code> folder located in the root directory. This will allow you to later load all the (declarative and episodic) memories into a new instance whenever you wish.   </p>"},{"location":"technical/advanced/memory_backup/#restore-a-full-backup","title":"Restore a full backup","text":"<p>To load your backup into a clean installation of Cheshire Cat, you just need to copy the <code>long_term_memory</code> folder into the root directory at the same level as the <code>core</code> folder. In case you've already started an instance of Cheshire Cat, you will find the <code>long_term_memory</code> folder there; you can safely overwrite it.</p> <p>Warning</p> <p>The <code>long_term_memory</code> folder may be protected, and you might need to use the admin permissions of your system to access it.</p> <p>The terminal command to perform this operation is as follows:</p> <pre><code>sudo cp -r /path/to/source/cheshire_cat/long_term_memory /path/to/destination/cheshire_cat\n</code></pre>"},{"location":"technical/advanced/tests/","title":"Automatic Tests","text":""},{"location":"technical/advanced/tests/#testing","title":"\ud83d\udd2c Testing","text":"<p>To run tests, start the Cat as usual. Tests will run on the same container you already launched, but with mock databases and plugin folder. End to end (e2e) tests are found in <code>tests/routes</code>, while all the other folders contain unit tests and mocks / utilities.</p>"},{"location":"technical/advanced/tests/#run-all-tests","title":"Run all tests","text":"<p>Open another terminal (in the same folder from where you start the Cat) and launch:</p> <pre><code>docker exec cheshire_cat_core python -m pytest --color=yes .\n</code></pre>"},{"location":"technical/advanced/tests/#run-a-specific-test-file","title":"Run a specific test file","text":"<p>If you want to run specific test files and not the whole suite, just specify the path:</p> <pre><code>docker exec cheshire_cat_core python -m pytest --color=yes tests/routes/memory/test_memory_recall.py\n</code></pre>"},{"location":"technical/advanced/tests/#run-a-specific-test-function-in-a-specific-test-file","title":"Run a specific test function in a specific test file","text":"<p>You can also launch only one specific test function, using the <code>::</code> notation and the name of the function:</p> <pre><code>docker exec cheshire_cat_core python -m pytest --color=yes tests/routes/memory/test_memory_recall.py::test_memory_recall_with_k_success\n</code></pre>"},{"location":"technical/advanced/user_system/","title":"User Management","text":""},{"location":"technical/advanced/user_system/#user-system","title":"\ud83d\udc65 User System","text":"<p>The Cat provides a basic user management system that allows having separated memories for each user. The user system affects only the working memory and the episodic memory. The other memories are shared among users.</p> <p>More in details, the websocket client indicates the current <code>user_id</code> by calling the <code>ws://localhost:1865/ws/{user_id}</code> endpoint. The Cat uses such <code>user_id</code> to retrieve the user's working memory and to store the user's conversation (using the <code>user_id</code> as a metadatum).</p> <p>Note</p> <p>Please, note that the user management system works only when using a custom client. Its usage is not intended from the admin interface, which, by default, uses <code>user_id = \"user\"</code>.</p>"},{"location":"technical/advanced/user_system/#example","title":"Example","text":"<p>The Cheshire Cat provides two API clients, written in Python and Typescript, that allow exploiting the user management system.</p> <p>Example</p> <p>Setting the <code>user_id</code> from a custom client:</p> PythonTypescript <pre><code>import cheshire_cat_api as ccat\n\ncat_client = ccat.CatClient()\n\n# Send a message specifying the user_id\nmessage = \"Hello my friend!!\"\ncat_client.send(message, user_id=\"user05\")\n</code></pre> <pre><code>import { CatClient } from 'ccat-api'\n\nconst cat = new CatClient({\n    baseUrl: 'localhost'\n})\n\ncat.send('Hello my friend!!', 'user05');\n</code></pre>"},{"location":"technical/basics/cat-core/","title":"&#129728; API Reference","text":""},{"location":"technical/basics/cat-core/#api-reference","title":"\ud83e\udec0 API Reference","text":"<p>The core exposes all of its APIs via the address <code>localhost:1865/</code>.  </p> <p>All of endpoints are extensively documented; the documentation is locally available and can be easily tested using <code>Swagger</code> or <code>ReDoc</code>.</p>"},{"location":"technical/basics/interacting/","title":"Interacting","text":""},{"location":"technical/basics/interacting/#interacting-with-the-cat","title":"\ud83d\udcac Interacting with the Cat","text":"<p>Example of how to implement a simple chat system using the websocket endpoint at <code>localhost:1865/ws/</code>.</p> <p>Request JSON schema</p> <p>Sending input will request you to do it in the following specific JSON format <code>{\"text\": \"input message here\"}</code>.</p> <p>Example</p> PythonNode <pre><code>import asyncio\nimport websockets\nimport json\n\nasync def cat_chat():\n\n    try:\n        # Creating a websocket connection\n        async with websockets.connect('ws://localhost:1865/ws') as websocket:\n\n            # Running a continuous loop until broken\n            while True:\n\n                # Taking user input and sending it through the websocket\n                user_input = input(\"Human: \")\n                await websocket.send(json.dumps({\"text\": user_input}))\n\n                # Receiving and printing the cat's response\n                cat_response = await websocket.recv()\n                print(\"Cheshire Cat:\", cat_response)\n\n    except websockets.exceptions.InvalidURI:\n        print(\"Invalid URI provided. Please provide a valid URI.\")\n\n    except websockets.exceptions.InvalidStatusCode:\n        print(\"Invalid status code received. Please check your connection.\")\n\n    except websockets.exceptions.WebSocketProtocolError:\n        print(\"Websocket protocol error occurred. Please check your connection.\")\n\n    except websockets.exceptions.ConnectionClosedOK:\n        print(\"Connection successfully closed.\")\n\n    except Exception as e:\n        print(\"An error occurred:\", e)\n\n# Running the function until completion\nasyncio.get_event_loop().run_until_complete(cat_chat())\n</code></pre> <pre><code>const WebSocket = require('ws');\n\nasync function cat_chat() {\n\n  try {\n    const socket = new WebSocket('ws://localhost:1865/ws/');\n\n    //Listen for connection event and log a message\n    socket.on('open', () =&gt; {\n      console.log('Connected to the Ceshire Cat');\n    });\n\n    //Listen for message event and log the received data message\n    socket.on('message', (data) =&gt; {\n      console.log(`Cheshire Cat: ${data}`);\n    });\n\n    //Iterate indefinitely while waiting for user input\n    while (true) {\n      //Call getUserInput function and wait for user input\n      const user_input = await getUserInput('Human: ');\n\n      socket.send(user_input);\n    }\n\n  } catch (error) {\n    console.error(error);\n  }\n}\n\n//Define a function named getUserInput that returns a Promise\nfunction getUserInput(prompt) {\n  return new Promise((resolve) =&gt; {\n    const stdin = process.openStdin();\n    process.stdout.write(prompt);\n\n    //Listen for data input events and resolve the Promise with the input\n    stdin.addListener('data', (data) =&gt; {\n      resolve(data.toString().trim());\n      stdin.removeAllListeners('data');\n    });\n  });\n}\n\n//Call the cat_chat function\ncat_chat();\n</code></pre>"},{"location":"technical/basics/interacting/#interacting-with-rabbithole","title":"\ud83d\udc07 Interacting with Rabbithole","text":"<p>Example of how to send a text file (<code>.md</code>,<code>.pdf.</code>,<code>.txt</code>) to the Cat using the Rabbit Hole at <code>localhost:1865/rabbithole/</code>.</p> <p>Currently the following MIME types are supported:</p> <ul> <li><code>text/plain</code></li> <li><code>text/markdown</code></li> <li><code>application/pdf</code></li> </ul> <p>Example</p> PythonNodecURL <pre><code>import requests\n\nurl = 'http://localhost:1865/rabbithole/'\n\nwith open('alice.txt', 'rb') as f:\n    files = {\n        'file': ('alice.txt', f, 'text/plain')\n    }\n\n    headers = {\n        'accept': 'application/json',\n    }\n\n    response = requests.post(url, headers=headers, files=files)\n\nprint(response.text)\n</code></pre> <pre><code>const request = require('request');\nconst fs = require('fs');\n\nconst url = 'http://localhost:1865/rabbithole/';\n\nconst file = fs.createReadStream('alice.txt');\nconst formData = {\n  file: {\n    value: file,\n    options: {\n      filename: 'alice.txt',\n      contentType: 'text/plain'\n    }\n  }\n};\n\nconst options = {\n  url: url,\n  headers: {\n    'accept': 'application/json'\n  },\n  formData: formData\n};\n\nrequest.post(options, function(err, res, body) {\n  if (err) {\n    return console.error('Error:', err);\n  }\n  console.log('Body:', body);\n});\n</code></pre> <pre><code># Upload an ASCII text file\ncurl -v -X POST -H \"accept: application/json\" -F \"file=@file.txt;type=text/plain\" http://127.0.0.1:1865/rabbithole/\n\n# Upload a Markdown file\ncurl -v -X POST -H \"accept: application/json\" -F \"file=@file.md;type=text/markdown\" http://127.0.0.1:1865/rabbithole/\n\n# Upload a PDF file\ncurl -v -X POST -H \"accept: application/json\" -F \"file=@myfile.pdf;type=application/pdf\" http://127.0.0.1:1865/rabbithole/\n</code></pre>"},{"location":"technical/basics/admin/admin-interface/","title":"Home","text":""},{"location":"technical/basics/admin/admin-interface/#home","title":"Home","text":"<p>The frontend interface of The Cheshire Cat can be accessed via <code>localhost:1865/admin</code>. This interface provides you with an easy-to-use chat that acts as a playground and can be used to interact with your application. The Cat core uses a static build of the admin,  source code can be found here.</p> <p>The home page of the Admin interface is where it possible to chat with the Cat.</p> <p></p> <ol> <li>User's message: this is the message sent by the user.</li> <li>Cat's answer: this is the answer sent by the Cat.</li> <li>Why button: this button opens the Why side panel that explains why the Cat answered in a certain way.</li> <li>Send button: this button allows sending the message.</li> <li>Flash button: this button opens a small panel with additional features.</li> <li>Theme button: this button toggles the light/dark modes.</li> </ol>"},{"location":"technical/basics/admin/admin-interface/#why-this-response","title":"Why this response","text":"<p>This panel contains some useful information to understand why the Cat answered the way it answered.</p> <p></p> <ol> <li>Tool table: this table reports the intermediate steps of a tool usage. For each, it provides the name of the tool, the input given to the tool function and the related output.</li> <li>Memory buttons: these buttons allow switching the memory showing below the retrieved context from the memory at hand.</li> <li>Retrieved memories: these bubbles show the memory the Cat used as a context. In green there is the similarity score with the input message, at the bottom left the source of the memory and on the bottom right the upload time.</li> </ol>"},{"location":"technical/basics/admin/admin-interface/#flash-button","title":"Flash button","text":"<ol> <li>Prompt settings: allows customizing the main prompt prefix.</li> <li>Upload memories: allows uploading memories in the format of JSON files.</li> <li>Upload url: allows uploading a web page in memory providing an url.</li> <li>Upload file: allows uploading a file in memory. Supported formats are <code>.txt</code>, <code>.pdf</code> and <code>.md</code>.</li> <li>Clear conversation: clear the current conversation and delete the conversation history in the working memory.</li> </ol>"},{"location":"technical/basics/admin/memory/","title":"Memory","text":""},{"location":"technical/basics/admin/memory/#memory","title":"Memory","text":"<p>The Memory page allows interacting with the Cat's long term memory. Specifically, it is possible to query the vector collections and retrieve a custom number of similar memories, wipe the collections or delete individual memories.</p> <p>To plot the memories, the Cat uses an algorithm called t-distributed Stochastic Neighbor Embedding (t-SNE)<sup>1</sup>. This is a dimensionality reduction algorithm commonly used to visualize high-dimensional points. In short, t-SNE embeds the memory points projecting them on a 2D plane such that similar points live close to each other. Namely, the most similar memories to the query are the closest points to the red one. Reducing the dimensionality of memories is necessary since memories are stored in the vector memory collections in the form of multidimensional points (e.g. points with 1536 dimensions) and for this reason cannot be plotted.</p> <p></p> <ol> <li>Search bar: allows writing a text query used to search for similar documents in memory.</li> <li>K memories: allows defining how many memories to retrieve.</li> <li>Plot buttons: allow zooming or restoring the view of the plot.</li> <li>Details: opens a side panel with the list of all retrieved memories for each collection (i.e. episodic, declarative and procedural).</li> <li>Export memories: this button allows exporting all the plotted memories in a JSON file. This allows saving memories on disk and sharing them with other users. The memory file can be uploaded again with the \"Upload memory\" button.</li> <li>Save plot: this button allows saving the plot in <code>.png</code> or <code>.svg</code> formats.</li> <li>Memory tooltip: this tooltip shows when hovering the mouse on the memory points. Clicking on it opens a side panel with detailed information about the point at hand.</li> <li>Memories toggle: these buttons allow turning on/off specific memories in the plot.</li> <li>Wipe: this button allows wiping out (i.e. delete permanently) the individual memories or all of them.</li> </ol>"},{"location":"technical/basics/admin/memory/#details-button","title":"\"Details\" button","text":"<ol> <li>Embedder: this tab tells what's the embedder in use.</li> <li>Memory buttons: these buttons allow switching between the lists of every memory collection.</li> <li>Memory item: these elements give information about every the retrieved memories. In green there is the similarity score with the query; below the memory content;    on the bottom right there is the source of the memory and on the bottom left the upload time.</li> </ol>"},{"location":"technical/basics/admin/memory/#show-more-button","title":"\"Show more\" button","text":"<ol> <li>Memory content: detailed information about the memory point.</li> <li>Delete memory: this button allows deleting the point from the memory collection.</li> </ol>"},{"location":"technical/basics/admin/memory/#references","title":"References","text":"<ol> <li> <p>Van der Maaten, L., &amp; Hinton, G. (2008). Visualizing data using t-SNE. Journal of machine learning research, 9(11).\u00a0\u21a9</p> </li> </ol>"},{"location":"technical/basics/admin/plugins/","title":"Plugins","text":""},{"location":"technical/basics/admin/plugins/#plugins","title":"Plugins","text":"<p>The plugin page allows managing the plugins installed in the Cat. Here it is possible to install new plugins, de-/activate those already installed, configure their settings or remove them.</p> <p></p> <ol> <li>Search bar: allows searching for plugins and filtering them down according if they are installed, in the registry, enabled or disabled.</li> <li>Upload plugin: allows uploading and installing a plugin from a <code>.zip</code> folder.</li> <li>Settings: allows configuring the plugin settings.</li> <li>Delete: completely remove the plugin from the Cat.</li> <li>Activate: toggle the installed plugin to de-/activate it.</li> </ol>"},{"location":"technical/basics/admin/settings/","title":"Settings","text":""},{"location":"technical/basics/admin/settings/#settings","title":"Settings","text":"<p>The settings page allows managing the settings of the language models and other general settings.</p> <p></p> <ol> <li>Large Language Model (LLM): the configure button opens the side panel to configure your preferred LLM. One LLM should always be configured otherwise it is not possible to chat.</li> <li>Embedder: the configure button opens the side panel to configure your preferred LLM. By default, the Cat sets the embedder having the same vendor of the LLM you configured. When this is not available, the Cat uses an embedder that generate random numbers to embed the text.</li> <li>Toggle sound: the toggle allows turning on/off the sound when the Cat sends a message.</li> </ol>"},{"location":"technical/clientlib/clientlib-csharp/","title":"C#","text":""},{"location":"technical/clientlib/clientlib-csharp/#client-library-c","title":"\ud83d\ude80 Client Library C#","text":"<p>The Cheshire Cat provides a C# API client that allows you to chat with the Cat (using WebSocket) and provides APIs to interact with all the control plane endpoints.</p> <p>The package is public released on Github: Cheshire Cat C# API Client</p>"},{"location":"technical/clientlib/clientlib-php/","title":"PHP","text":""},{"location":"technical/clientlib/clientlib-php/#client-library-php","title":"\ud83d\ude80 Client Library PHP","text":"<p>The Cheshire Cat provides a PHP API client that allows you to chat with the Cat (using WebSocket) and provides APIs to interact with all the control plane endpoints.  </p> <p>The package is public released in GitHub: Cheshire Cat PHP API Client</p>"},{"location":"technical/clientlib/clientlib-python/","title":"Python","text":""},{"location":"technical/clientlib/clientlib-python/#client-library-python","title":"\ud83d\ude80 Client Library Python","text":"<p>The Cheshire Cat provides a Python API client that allows you to chat with the Cat (using WebSocket) and provides APIs to interact with all the control plane endpoints.</p> <p>The package is public released on the Python Package Index (PyPI) repository: Cheshire Cat Python API client</p>"},{"location":"technical/clientlib/clientlib-python/#setup","title":"Setup","text":"<p>To add the client to your project, install it with pip:</p> <pre><code>pip install cheshire_cat_api\n</code></pre> <p>Then, you can import the base class like this: </p> <pre><code>import cheshire_cat_api as ccat\n</code></pre>"},{"location":"technical/clientlib/clientlib-python/#example-connection","title":"Example connection","text":"<p>Here is an example to establish a connection with the Cheshire Cat backend to interact both via WebSocket and the HTTP endpoints.</p>"},{"location":"technical/clientlib/clientlib-python/#interact-with-the-websocket-endpoint","title":"Interact with the WebSocket endpoint","text":"<p>The WebSocket connection allows defining four callbacks to handle WebSocket events.</p> <pre><code>def on_open():\n    # This is triggered when the connection is opened\n    print(\"Connection opened!\")\n\ndef on_message(message: str):\n    # This is triggered when a new message arrives \n    # and grabs the message\n    print(message)\n\ndef on_error(exception: Exception):\n    # This is triggered when a WebSocket error is raised\n    print(str(exception))\n\ndef on_close(status_code: int, message: str):\n    # This is triggered when the connection is closed\n    print(f\"Connection closed with code {status_code}: {message}\")\n</code></pre> <p>Note</p> <p>The aforementioned callbacks are optional and intended for custom behaviors. The client already handles the events with default logging.</p> <p>Now, you can connect to the backend:</p> <pre><code>import time\nimport cheshire_cat_api as ccat\n\n# Connection settings with default values\nconfig = ccat.Config(\n    base_url=\"localhost\",\n    port=1865,\n    user_id=\"user\",\n    auth_key=\"\",\n    secure_connection=False\n)\n\n# Cat Client\ncat_client = ccat.CatClient(\n    config=config,\n    on_open=on_open,\n    on_close=on_close,\n    on_message=on_message,\n    on_error=on_error\n)\n\n# Connect to the WebSocket API\ncat_client.connect_ws()\n\nwhile not cat_client.is_ws_connected: \n# A better handling is strongly advised to avoid an infinite loop \n    time.sleep(1)\n\n# Send the message\ncat_client.send(message=\"Hello Cat!\")\n\n# Close connection\ncat_client.close()\n</code></pre>"},{"location":"technical/clientlib/clientlib-python/#interact-with-the-http-endpoints","title":"Interact with the HTTP endpoints","text":"<p>Like in the WebSocket case, you should first connect to the Cat backend:</p> <pre><code>import cheshire_cat_api as ccat\n\n# Connection settings with default values\nconfig = ccat.Config(\n    base_url=\"localhost\",\n    port=1865,\n    user_id=\"user\",\n    auth_key=\"\",\n    secure_connection=False\n)\n\n# Cat Client\ncat_client = ccat.CatClient(\n    config=config,\n    on_open=on_open,\n    on_close=on_close,\n    on_message=on_message,\n    on_error=on_error\n)\n</code></pre> <p>Now, you can interact with the available APIs</p>"},{"location":"technical/clientlib/clientlib-python/#plugin-api-retrieve-plugins","title":"Plugin API - Retrieve plugins","text":"<pre><code># Retrieve a list of the available plugins\nplugins = cat_client.plugins.get_available_plugins()\n</code></pre>"},{"location":"technical/clientlib/clientlib-python/#rabbithole-api-upload-a-url","title":"RabbitHole API - Upload a URL","text":"<pre><code>from cheshire_cat_api.models.body_upload_url import BodyUploadUrl\n\n# Please note that interacting with the RabbitHole to upload\n# a URL requires structuring the body like this\n\nbody_upload_url = BodyUploadUrl(\n    url=\"https://cheshire-cat-ai.github.io/docs/conceptual/cheshire_cat/rabbit_hole/\"\n)\n\n# then you can make the request as follows\nresponse = cat_client.rabbit_hole.upload_url(body_upload_url)\n</code></pre>"},{"location":"technical/clientlib/clientlib-python/#memory-api-wipe-collections","title":"Memory API - wipe collections","text":"<pre><code># Delete the episodic and declarative memories\nresponse = cat_client.memory.wipe_collections()\n</code></pre>"},{"location":"technical/clientlib/clientlib-python/#available-apis","title":"Available APIs","text":"API HTTP Method Class Method Description <code>settings</code> <code>GET</code> <code>get_settings()</code> <code>POST</code> <code>GET</code> <code>PUT</code> <code>DELETE</code> <code>llm</code> <code>GET</code> <code>GET</code> <code>PUT</code> <code>embedder</code> <code>GET</code> <code>GET</code> <code>PUT</code> <code>plugins</code> <code>GET</code> <code>POST</code> <code>POST</code> <code>PUT</code> <code>GET</code> <code>DELETE</code> <code>GET</code> <code>GET</code> <code>PUT</code> <code>memory</code> <code>GET</code> <code>GET</code> <code>DELETE</code> <code>DELETE</code> <code>DELETE</code> <code>DELETE</code> <code>GET</code> <code>DELETE</code> <code>rabbit_hole</code> <code>POST</code> <code>POST</code> <code>POST</code> <code>GET</code>"},{"location":"technical/clientlib/clientlib-ruby/","title":"Ruby","text":""},{"location":"technical/clientlib/clientlib-ruby/#client-library-ruby","title":"\ud83d\ude80 Client Library Ruby","text":"<p>The Cheshire Cat provides a Ruby API client that allows you to chat with the Cat (using WebSocket) and provides APIs to interact with all the control plane endpoints.</p> <p>The package is public released on Github: Cheshire Cat Ruby API Client</p>"},{"location":"technical/clientlib/clientlib-typescript/","title":"TypeScript","text":""},{"location":"technical/clientlib/clientlib-typescript/#client-library-typescript","title":"\ud83d\ude80 Client Library TypeScript","text":"<p>The Cheshire Cat provides a TypeScript API client that allows you to chat with the Cat (using WebSocket) and provides APIs to interact with all the control plane endpoints. It can be used both in Browser and NodeJS environments.</p> <p>The package is public released on npm Registry: Cheshire Cat TypeScript API Client</p> <p>Every endpoint is a <code>CancelablePromise</code>, which means the request can be eventually cancelled.</p>"},{"location":"technical/clientlib/clientlib-typescript/#setup","title":"Setup","text":"<p>The API client can be installed through one of the following commands:</p> <pre><code>npm install ccat-api\n# OR\nyarn add ccat-api\n# OR\npnpm i ccat-api\n</code></pre>"},{"location":"technical/clientlib/clientlib-typescript/#getting-started","title":"Getting started","text":"<p>To set up the client, first of all <code>CatClient</code> class need to be imported:</p> <p></p><pre><code>import { CatClient } from 'ccat-api'\n\nconst cat = new CatClient({\n    baseUrl: 'localhost',\n    user: 'user'.\n    //... other settings\n})\n\ncat.send('Hello from a user!') // this will send a message to the /ws/user\n\ncat.userId = 'new_user'\n\ncat.send('Hello from a new user!') // this will send a message to the /ws/new_user\n</code></pre> The <code>cat</code> is initialized as <code>CatClient</code> with Client Settings; then, for example, a message can be send using the <code>cat.send</code> endpoint."},{"location":"technical/clientlib/clientlib-typescript/#client-settings","title":"Client settings","text":"<p>API_KEY, CORE_HOST, CORE_PORT and CORE_USE_SECURE_PROTOCOLS refer to the CCAT Core .env file.</p> Property Type Default Description baseUrl string Required The same of CORE_HOST authKey string '' The same of API_KEY port number 1865 The same of the CORE_PORT secure boolean false The same of the CORE_USE_SECURE_PROTOCOLS user string 'user' The user ID to use for the WebSocket and the API client instant boolean true Instantly initialize the WebSocket and the API client, or later with .init() timeout number 10000 Timeout for the endpoints, in milliseconds ws string undefined An object of type WebSocketSettings"},{"location":"technical/clientlib/clientlib-typescript/#websocket-settings","title":"WebSocket settings","text":"Property Type Default Description path string 'ws' Websocket path to use to communicate with the CCat retries number 3 The maximum number of retries before calling onFailed delay number 3000 The delay for reconnect, in milliseconds onFailed (ErrorCode) =&gt; void undefined The function to call after failing all the retries <p>Then, for example, the LLM can be configured like this:</p> <pre><code>cat.api.settingsLargeLanguageModel.upsertLlmSetting('LLMOpenAIConfig', {\n    openai_api_key: 'OPEN_API_KEY'\n})\n</code></pre> <p>A message can be send to the cat as follows:</p> <pre><code>cat.send('Hello my friend!')\n</code></pre> <p>A specific listener (such as <code>onMessage</code>) can be added to the WebSocket events:</p> <pre><code>cat.onConnected(() =&gt; {\n    console.log('Socket connected')\n}).onMessage(msg =&gt; {\n    console.log(msg)\n}).onError(err =&gt; {\n    console.log(err)\n}).onDisconnected(() =&gt; {\n    console.log('Socket disconnected')\n})\n</code></pre> <p>The list of plugins can be obtained by:</p> <pre><code>cat.api.plugins.listAvailablePlugins().then(plugins =&gt; {\n    console.log(plugins)\n})\n</code></pre> <p>The repository of this API is public and available on Cheshire Cat Typescript API Client Repository.</p>"},{"location":"technical/debugging/vscode/","title":"Visual Studio Code","text":""},{"location":"technical/debugging/vscode/#debug-with-visual-studio-code","title":"\ud83d\ude80 Debug with Visual Studio Code","text":"<p>The <code>Debug Server for VSCode</code> plugin helps you to debug the Cat with Visual Studio Code, install it from the public plugins registry or download the zip file (and follow the Manual Instruction).</p>"},{"location":"technical/debugging/vscode/#add-a-new-port-to-the-container","title":"Add a new port to the container","text":"<p>After the installation, you will need to expose a new port to the container:</p> <ol> <li> <p>If you run the cat with <code>docker-compose</code>, expose the port by adding the following line under <code>ports</code> section:</p> <pre><code>    ports:\n        - ${CORE_PORT:-1865}:80\n        - 5678:5678           &lt; --- add this line\n</code></pre> </li> <li> <p>If you run the cat with <code>docker run</code>, expose the port by using the <code>-p &lt;host&gt;:&lt;container&gt;</code> argument in the command like so:</p> <pre><code>    docker run --rm -it \\ \n    -v ./data:/app/cat/data \\ \n    -v ./plugins:/app/cat/plugins \\ \n    -p 1865:80 \\ \n    -p 5678:5678 \\  &lt; --- add this line\n    ghcr.io/cheshire-cat-ai/core:latest\n</code></pre> </li> </ol>"},{"location":"technical/debugging/vscode/#configure-vscode","title":"Configure vscode","text":"<p>Once you have exposed the port, you will need to create a <code>launch.json</code> file having two different options:</p> <ol> <li>Use the <code>Run and Debug</code> tab to create it, selecting <code>Python Debugger</code> and then <code>Remote Attach</code> (Follow the prompts by answering with the default proposed).</li> <li>Create a folder in the root directory called <code>.vscode</code> and add the <code>launch.json</code> file into it.<pre><code>    \u251c\u2500\u2500 &lt;name of the root directory&gt;\n    \u2502   \u251c\u2500\u2500 core\n    \u2502   \u251c\u2500\u2500 .vscode\n    \u2502   \u2502   \u251c\u2500\u2500launch.json\n</code></pre> </li> </ol> <p>After the creation of the launch.json, Copy-Paste this config:</p> <ol> <li> <p>If you run using <code>docker-compose</code>:</p> <pre><code>{\n    // Use IntelliSense to learn about possible attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"Python: Remote Attach to Cat\",\n            \"type\": \"python\",\n            \"request\": \"attach\",\n            \"connect\": {\n                \"host\": \"localhost\",\n                \"port\": 5678\n            },\n            \"pathMappings\": [\n                {\n                    \"localRoot\": \"${workspaceFolder}/core\",\n                    \"remoteRoot\": \"/app\"\n                }\n            ],\n            \"justMyCode\": true\n        }\n    ]\n}\n</code></pre> </li> <li> <p>If you run using <code>docker run</code>:</p> <pre><code>{\n    // Use IntelliSense to learn about possible attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"Python: Remote Attach to Cat\",\n            \"type\": \"python\",\n            \"request\": \"attach\",\n            \"connect\": {\n                \"host\": \"localhost\",\n                \"port\": 5678\n            },\n            \"pathMappings\": [\n                {\n                    \"localRoot\": \"${workspaceFolder}/\",\n                    \"remoteRoot\": \"/app/cat\"\n                }\n            ],\n            \"justMyCode\": true\n        }\n    ]  \n}\n</code></pre> </li> </ol>"},{"location":"technical/debugging/vscode/#connect-vscode-to-the-cat","title":"Connect vscode to the cat","text":"<p>To Connect the vscode debugger, ask the cat to help you on debugging  and in the <code>Run and Debug</code> tab start the debugging by clicking the <code>Play button</code> \u25b6\ufe0f or Use the shortcut <code>F5</code>.</p> <p></p> <p>You are ready to debug your plugin!</p> <p>If you are new in VS code debugging, check the official docs.</p>"},{"location":"technical/debugging/vscode/#troubleshooting","title":"Troubleshooting","text":""},{"location":"technical/debugging/vscode/#i-click-the-button-but-then-i-dont-see-the-debugging-bar-the-breakpoints-are-not-respected","title":"I click the button but then I don't see the debugging bar / the breakpoints are not respected","text":"<p>This usually means that the debugger is not active, make sure to activate the debugger by asking the Cat.</p>"},{"location":"technical/debugging/vscode/#i-cannot-explore-the-code-outside-of-my-plugin","title":"I cannot explore the code outside of my plugin","text":"<p>By default, you can only explore your \"own\" code but you can disable this by setting the param <code>justMyCode</code> to false in the <code>launch.json</code> file.</p>"},{"location":"technical/debugging/vscode/#my-cat-is-installed-in-a-remote-server-can-i-debug-it","title":"My Cat is installed in a remote server, can I debug it?","text":"<p>Of course you can! Just set the correct <code>host</code> and <code>port</code> in the <code>connect</code> param of the <code>launch.json</code> file.</p>"},{"location":"technical/flows/cat-bootstrap/","title":"The Cat Bootstrap","text":""},{"location":"technical/flows/cat-bootstrap/#the-cat-bootstrap","title":"\ud83d\ude3c The Cat Bootstrap","text":"<p>This interactive diagram, zoomable with a click, depicts the internal process involved during bootstrap of the Cat:</p> <p></p>"},{"location":"technical/flows/chatting-with-the-cat/","title":"Chatting with the Cat","text":""},{"location":"technical/flows/chatting-with-the-cat/#chatting-with-the-cat","title":"\ud83d\ude3c Chatting with the Cat","text":"<p>This interactive diagram, zoomable with a click, depicts the internal process involved during a conversation with the Cat:</p> <p></p>"},{"location":"technical/flows/plugins-lifecycle/","title":"Plugins Lifecycle","text":""},{"location":"technical/flows/plugins-lifecycle/#plugins-lifecycle","title":"\ud83e\udde9 Plugins Lifecycle","text":"<p>This interactive diagram, zoomable with a click, depicts the internal process involved during the complete lifecycle of a plugin:</p> <p>coming soon!</p>"},{"location":"technical/plugins/dependencies/","title":"Dependencies","text":""},{"location":"technical/plugins/dependencies/#plugin-dependencies","title":"Plugin dependencies","text":"<p>If your plugin requires additional python packages, add a <code>requirements.txt</code> file to your plugin.</p> <ul> <li>The file should contain only additional dependencies.  </li> <li>Express minimal dependencies, to avoid regression problems (i.e. use <code>langchain&gt;=x.x.x</code> instead of <code>langchain==x.x.x</code>)</li> <li>The Cat will install your dependencies on top of the default ones, as soon as you install a plugin from the admin.</li> <li>If you are coding a plugin from inside the <code>cat/plugins</code> folder, to install dependencies you need to stop and restart the Cat.</li> </ul>"},{"location":"technical/plugins/dependencies/#example","title":"Example","text":"<p>Your plugin makes the Cat a crypto bro. You decide to use the <code>pycrypto</code> package, from the version 2.6.1 up.</p> <p>Insert a <code>requirements.txt</code> file in your plugin root folder:</p> <pre><code>pycrypto&gt;=2.6.1\n</code></pre>"},{"location":"technical/plugins/forms/","title":"Forms","text":""},{"location":"technical/plugins/forms/#forms","title":"\ud83d\udccb Forms","text":"<p>Forms are Particular Tools useful to collect users' information during the given conversation!</p>"},{"location":"technical/plugins/forms/#how-the-forms-work","title":"How the Forms work","text":"<p>Imagine a scenario where you need to create an Order system for a pizzeria, using only the conversation of the user. The user must provide 3 information:</p> <ol> <li>Type of pizza, must be a string in a restrictive set</li> <li>Phone number, must be 10 numbers long and restrictive to a specific dialling code</li> <li>Address, must be a valid address of \"Milano\"</li> </ol> <p>How can I resolve this problem? Well, these type of information are very specific:</p> <ul> <li>need validators (Phone numbers can be of different structure based on the country, the pizzeria has a menu of pizzas, you can deliver only in a certain area of the city)</li> <li>can be provided in different orders (A user can give the address before the type of pizza!).</li> </ul> <p>This is where the forms comes handy!</p>"},{"location":"technical/plugins/forms/#implementation","title":"Implementation","text":"<pre><code>class PizzaOrder(BaseModel): #(1)\n    pizza_type: str\n    phone: str\n    address: str\n\n\n@form #(2)\nclass PizzaForm(CatForm): #(3)\n    description = \"Pizza Order\" #(4)\n    model_class = PizzaOrder #(5)\n    start_examples = [ #(6)\n        \"order a pizza!\",\n        \"I want pizza\"\n    ]\n    stop_examples = [ #(7)\n        \"stop pizza order\",\n        \"not hungry anymore\",\n    ]\n    ask_confirm = True #(8)\n\n    def submit(self, form_data): #(9)\n\n        # do the actual order here!\n        # Fake call\n        out = request.post(\"https://fakecallpizza/order\",{\n            \"pizza_type\": form_data.pizza_type,\n            \"phone\": form_data.phone,\n            \"address\": form_data.address\n        })\n\n        if(out.status_code != 201):\n            raise Exception()\n\n        time = out.json()[\"estimatedTime\"]\n\n        # return to conversation\n        return {\n            \"output\": f\"Pizza order on its way: {form_data}. Estimated time: {time}\"\n        }\n</code></pre> <ol> <li>Pydantic class representing the information you need to retrive.</li> <li>Every class decorated with <code>@forms</code> is a Form.</li> <li>Every Form must inherit from <code>CatForm</code>.</li> <li>Description of the Form. </li> <li>Pydantic class name.</li> <li>Every Form must have a list of start examples, so the LLM can select the form properly. It's the same principal of tool's docstring.</li> <li>Every Form must have a list of stop examples, so the LLM can stop properly the form during the conversation.</li> <li>Every Form can ask the user confirmation of the data provided.</li> <li>Every Form must overload this method and the fuctionality is the same as tools: call database to collect the information, call the Order API, call another agent or LLM etc..</li> </ol>"},{"location":"technical/plugins/forms/#changing-the-moves-of-the-form","title":"Changing the \"moves\" of the Form","text":"<p>Forms are implemented as FSM and you can change any move of the FSM by overloading the methods.</p> <p>Here the diagram of the FSM: TODO</p>"},{"location":"technical/plugins/forms/#state-transition-function","title":"State-transition function","text":"<p>Each FSM has a State-Transition function that describes what is the next move to perform based on the given input. In the case of Form's implementation the input is the User prompt and the <code>def next(self)</code> method is State-Transition function.</p> <p>The form has 4 states to be evaluated:</p> <ol> <li>INCOMPLETE</li> <li>WAIT_CONFIRM</li> <li>CLOSED</li> <li>COMPLETE</li> </ol> <p>each state executes one or more Phases:</p> <ul> <li>User Stop Confirmation Phase</li> <li>User Confirmation Phase</li> <li>Updating Phase</li> <li>Visualization Phase</li> <li>Submit Phase</li> </ul> <p>You can change this state-transition by overloading the method <code>def next(self)</code> and accessing the state by <code>self._state</code>. The states are values from the <code>CatFormState</code> enum.</p>"},{"location":"technical/plugins/forms/#user-stop-confirmation-phase","title":"User Stop Confirmation Phase","text":"<p>The User Stop Confirmation phase is where the Form produces a prompt to ask the user his willingness to continue. You can change this phase by overloading the method <code>def check_exit_intent(self)</code>.</p>"},{"location":"technical/plugins/forms/#user-confirmation-phase","title":"User Confirmation Phase","text":"<p>The User Confirmation Phase is where the Form produces a prompt to ask confirmation of the information provided by the user, if <code>ask_confirm</code> is true. You can change this phase by overloading the method <code>def confirm(self)</code>.</p>"},{"location":"technical/plugins/forms/#updating-phase","title":"Updating Phase","text":"<p>The Updating Phase is where the Form executes the Extraction Phase, Sanitization Phase and Validation Phase. You can change this phase by overloading the method <code>def update(self)</code>.</p>"},{"location":"technical/plugins/forms/#extraction-phase","title":"Extraction Phase","text":"<p>The Extraction Phase is where the Form extracts all possibile information from the user's prompt. You can change this phase by overloading the method <code>def extract(self)</code>.</p>"},{"location":"technical/plugins/forms/#sanitization-phase","title":"Sanitization Phase","text":"<p>The Sanitization Phase is where the information is sinitized from unwanted values (null, None, '', ' ', etc...). You can change this phase by overloading the method <code>def sanitize(self, model)</code></p>"},{"location":"technical/plugins/forms/#validation-phase","title":"Validation Phase","text":"<p>The Validation Phase is where the Form attempts to construct the model, so pydantic can use the validators implemented and check each field. You can change this phase by overloading the method <code>def valdiate(self, model)</code></p>"},{"location":"technical/plugins/forms/#visualization-phase","title":"Visualization Phase","text":"<p>The Visualization Phase is where the Form displays a message to the user, showing the model's status.</p> <p>By default the cat shows the forms like so </p> <p>When there is invalid info that was retrived from the conversation, the cat tells you exacly which and what issue </p> <p>You can change this phase by overloading the method <code>def message(self)</code>:</p> <pre><code>    #in the form you define \n    def message(self): #(1) \n        if self._state == CatFormState.CLOSED: #(2)\n            return {\n                \"output\": f\"Form {type(self).__name__} closed\"\n            }\n        missing_fields: List[str] = self._missing_fields #(3)\n        errors: List[str] = self._errors #(4)\n        out: str = f\"\"\"\n        the missing information are: {missing_fields}.\n        this are the invalid ones: {errors}\n        \"\"\"\n        if self._state == CatFormState.WAIT_CONFIRM:\n            out += \"\\n --&gt; Confirm? Yes or no?\"\n\n        return {\n            \"output\": out\n        }\n</code></pre> <ol> <li>This method is useful to change the Form visualization.</li> <li>Forms have states that can be checked.</li> <li>Forms can access the list of the missing fields.</li> <li>Forms can access the list of the invalid fields and the correlated errors.</li> </ol>"},{"location":"technical/plugins/forms/#final-phase-submit","title":"Final Phase: Submit","text":"<p>The Submit Phase is where the Form conclude the journey by executing all defined instructions with the information gathered from the user's conversation. The method have two params:</p> <ul> <li>self (You can access information about the form and the <code>StrayCat</code> instance)</li> <li>form_data (The defined pydantic model) And must return a Dict where the value of key <code>output</code> is a string that will be displayed in the chat.</li> </ul> <p>If you need to use the Form in future conversations, you can retrive the model from the working memory by accessing the key <code>form</code>.</p> <p>Below an example:</p> <pre><code>    @hook  \n    def before_cat_sends_message(message, cat):\n        form_data = cat.working_memory[\"form\"]\n</code></pre>"},{"location":"technical/plugins/hooks/","title":"Hooks","text":""},{"location":"technical/plugins/hooks/#hooks","title":"\ud83e\ude9d Hooks","text":"<p>Hooks are Python functions that are called directly from the Cat at runtime, they allow you to change how the Cat internally works without directly modifying the Cat itself.</p>"},{"location":"technical/plugins/hooks/#how-the-hooks-work","title":"How the Hooks work","text":"<p>To create a hook, you first need to create a plugin that contains it. Once the plugin is created, you can insert hooks inside the plugin, a single plugin can contain multiple hooks.</p> <p>A hook is simply a Python function that uses the <code>@hook</code> decorator, the function's name determines when it will be called.</p> <p>There are two kinds of hooks. The first type of hook receives only the Cat instance as a parameter, while the second type of hook receives both the Cat instance and the value determined by default Cat implementation.</p> <p>With the first type, you can perform actions at specific points in the Cat's execution flow. For example, you can use the <code>before_cat_bootstrap</code> hook to execute some operations before the Cat starts:</p> <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook(priority=1)\ndef before_cat_bootstrap(cat):\n    # You can perform operations with the cat (modify working memory, access LLM, etc.)\n    do_my_thing()\n</code></pre> <p>You can use the second type of hook to modify the value determined by the default Cat implementation. For example, you can use the <code>before_cat_sends_message</code> hook to alter the message that the Cat will send to the user.</p> <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook(priority=1)\ndef before_cat_sends_message(final_output, cat):\n    # You can perform operations with the cat (modify working memory, access LLM, etc.)\n    do_my_thing()\n    # You can return a new value that will be used instead of Cat calculated value\n    return final_output.upper()\n</code></pre> <p>Some hooks receive more than one argument, the value determined by the Cat is always the first argument, all the other parameters are solely context parameters, which hooks cannot modify, the last parameter is always the Cat instance.</p>"},{"location":"technical/plugins/hooks/#multiple-implementations","title":"Multiple Implementations","text":"<p>Several plugins can implement the same hook. The argument <code>priority</code> of the <code>@hook</code> decorator allows you to set the priority of the hook, the default value is 1. </p> <p>The Cat calls the implementations in order of priority. Hooks with a higher priority number will be called first. The following hooks will receive the value returned by the previous hook. In this way, hooks can be chained together to create complex behaviors.</p> <p>If two plugins have the same priority, the order in which they are called is not guaranteed.</p>"},{"location":"technical/plugins/hooks/#available-hooks","title":"Available Hooks","text":"<p>You can view the list of available hooks by exploring the Cat source code under the folder <code>core/cat/mad_hatter/core_plugin/hooks</code>. All the hooks you find in there define default Cat's behavior and are ready to be overridden by your plugins.</p> <p>The process diagrams found under the menu <code>Developers \u2192 Core Process Diagrams</code> illustrates where the hooks are called during the Cat's execution flow. Not all the hooks have been documented yet. ( help needed! \ud83d\ude38 ).</p> \ud83c\udf0a Flow\ud83e\udd16 Agent\ud83d\udc30 Rabbit Hole\ud83d\udd0c Plugin\ud83c\udfed Factory Name Description Before Cat bootstrap (1) Intervene before the Cat's instantiate its components After Cat bootstrap (2) Intervene after the Cat's instantiated its components Before Cat reads message (3) Intervene as soon as a WebSocket message is received Cat recall query (4) Intervene before the recall query is embedded Before  Cat recalls memories (5) Intervene before the Cat searches into the specific memories Before  Cat recalls episodic memories (6) Intervene before the Cat searches in previous users' messages Before  Cat recalls declarative memories (7) Intervene before the Cat searches in the documents Before  Cat recalls procedural memories (8) Intervene before the Cat searches among the action it knows After  Cat recalls memories (9) Intervene after the Cat's recalled the content from the memories Before  Cat sends message (10) Intervene before the Cat sends its answer via WebSocket <ol> <li> <p>Input arguments     This hook has no input arguments.  </p> <p>Warning</p> <p>Please, note that at this point the <code>CheshireCat</code> hasn't yet finished to instantiate and the only already existing component is the <code>MadHatter</code> (e.g. no language models yet).</p> Example <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook  # default priority = 1\ndef before_cat_bootstrap(cat):\n    # do whatever here\n</code></pre> Other resources <ul> <li>Python reference</li> <li>Debugger plugin</li> </ul> </li> <li> <p>Input arguments     This hook has no input arguments.</p> Example <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook  # default priority = 1\ndef after_cat_bootstrap(cat):\n    # do whatever here\n</code></pre> Other resources <ul> <li>Python reference</li> </ul> </li> <li> <p>Input arguments <code>user_message_json</code>: a dictionary with the JSON message sent via WebSocket. E.g.: </p><pre><code>{\n    \"text\": # user's message here\n}\n</code></pre> Example <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook  # default priority = 1 \ndef before_cat_reads_message(user_message_json, cat):\n    user_message_json[\"text\"] = \"The original message has been replaced\"\n    cat.working_memory[\"hacked\"] = True\n\n    return user_message_json\n</code></pre> Other resources <ul> <li>Python reference</li> </ul> </li> <li> <p>Input arguments <code>user_message</code>: a string with the user's message that will be used to query the vector memories. E.g.:</p> <pre><code>user_message = \"What is the recipe for carbonara?\"\n</code></pre> Example <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook  # default priority = 1\ndef cat_recall_query(user_message, cat):\n    # Ask the LLM to generate an answer for the question\n    new_query = cat.llm(f\"If the input is a question, generate a plausible answer. Input --&gt; {user_message}\")\n\n    # Replace the original message and use the answer as a query\n    return new_query\n</code></pre> Other resourcer <ul> <li>Python reference</li> <li>HyDE plugin</li> </ul> </li> <li> <p>Input arguments     This hook has no input arguments.</p> Example <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook  # default priority = 1\ndef before_cat_recalls_memories(cat):\n    # do whatever here\n</code></pre> Other resources <ul> <li>Python reference</li> </ul> </li> <li> <p>Input arguments <code>episodic_recall_config</code>: dictionary with the recall configuration for the episodic memory. Default is:</p> <pre><code>{\n    \"embedding\": recall_query_embedding,  # embedding of the recall query\n    \"k\": 3,  # number of memories to retrieve\n    \"threshold\": 0.7,  # similarity threshold to retrieve memories\n    \"metadata\": {\"source\": self.user_id},  # dictionary of metadata to filter memories, by default it filters for user id\n}\n</code></pre> Example <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook  # default priority = 1\ndef before_cat_recalls_episodic_memories(episodic_recall_config, cat):\n    # increase the number of recalled memories\n    episodic_recall_config[\"k\"] = 6\n\n    return episodic_recall_config\n</code></pre> Other resources <ul> <li>Python reference</li> <li>C.A.T. plugin</li> </ul> </li> <li> <p>Input arguments <code>declarative_recall_config</code>: dictionary with the recall configuration for the declarative memory. Default is:</p> <pre><code>{\n    \"embedding\": recall_query_embedding,  # embedding of the recall query\n    \"k\": 3,  # number of memories to retrieve\n    \"threshold\": 0.7,  # similarity threshold to retrieve memories\n    \"metadata\": None,  # dictionary of metadata to filter memories\n}\n</code></pre> Example <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook  # default priority = 1\ndef before_cat_recalls_declarative_memories(declarative_recall_config, cat):\n    # filter memories using custom metadata. \n    # N.B. you must add the metadata when uploading the document! \n    declarative_recall_config[\"metadata\"] = {\"topic\": \"cats\"}\n\n    return declarative_recall_config\n</code></pre> Other resources <ul> <li>Python reference</li> <li>RabbitHole segmentation plugin</li> <li>C.A.T. plugin</li> </ul> </li> <li> <p>Input arguments <code>procedural_recall_config</code>: dictionary with the recall configuration for the procedural memory. Default is:</p> <pre><code>{\n    \"embedding\": recall_query_embedding,  # embedding of the recall query\n    \"k\": 3,  # number of memories to retrieve\n    \"threshold\": 0.7,  # similarity threshold to retrieve memories\n    \"metadata\": None,  # dictionary of metadata to filter memories\n}\n</code></pre> Example <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook  # default priority = 1\ndef before_cat_recalls_procedural_memories(procedural_recall_config, cat):\n    # decrease the threshold to recall more tools\n    declarative_recall_config[\"threshold\"] = 0.5\n\n    return procedural_recall_config\n</code></pre> Other resources <ul> <li>Python reference</li> <li>C.A.T. plugin</li> </ul> </li> <li> <p>Input arguments     This hook has no input arguments.</p> Example <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook  # default priority = 1\ndef after_cat_recalls_memories(cat):\n    # do whatever here\n</code></pre> Other resources <ul> <li>Python reference</li> </ul> </li> <li> <p>Input arguments <code>message</code>: the dictionary containing the Cat's answer that will be sent via WebSocket. E.g.:</p> <pre><code>{\n    \"type\": \"chat\",  # type of websocket message, a chat message will appear as a text bubble in the chat\n    \"user_id\": \"user_1\",  # id of the client to which the message is to be sent\n    \"content\": \"Meeeeow\",  # the Cat's answer\n    \"why\": {\n        \"input\": \"Hello Cheshire Cat!\",  # user's input\n        \"intermediate_steps\": cat_message.get(\"intermediate_steps\"),  # list of tools used to provide the answer\n        \"memory\": {\n            \"episodic\": episodic_report,  # lists of documents retrieved from the memories\n            \"declarative\": declarative_report,\n            \"procedural\": procedural_report,\n        }\n    }\n}\n</code></pre> Example <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook  # default priority = 1\ndef before_cat_sends_message(message, cat):\n    # use the LLM to rephrase the Cat's answer\n    new_answer = cat.llm(f\"Reformat this sentence like if you were a dog\")  # Baauuuuu\n    message[\"content\"] = new_answer\n\n    return message\n</code></pre> Other resources <ul> <li>Python reference</li> </ul> </li> </ol> Name Description Before agent starts (1) Intervene before the agent starts Agent fast reply (2) Shorten the pipeline and returns an answer right after the agent execution Agent prompt prefix (3) Intervene while the agent manager formats the Cat's personality Agent prompt suffix (4) Intervene while the agent manager formats the prompt suffix with the memories and the conversation history Agent allowed tools (5) Intervene before the recalled tools are provided to the agent Agent prompt instructions (6) Intervent while the agent manager formats the reasoning prompt <ol> <li> <p>Input arguments <code>agent_input</code>: dictionary with the information to be passed to the agent. E.g.:</p> <pre><code>{\n    \"input\": working_memory[\"user_message_json\"][\"text\"],  # user's message\n    \"episodic_memory\": episodic_memory_formatted_content,  # strings with documents recalled from memories\n    \"declarative_memory\": declarative_memory_formatted_content,\n    \"chat_history\": conversation_history_formatted_content,\n}\n</code></pre> Example <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook  # default priority = 1\ndef before_agent_starts(agent_input, cat):\n    # create a compressor and summarize the conversation history\n    compressed_history = cat.llm(f\"Make a concise summary of the following: {agent_input['chat_history']}\")\n    agent_input[\"chat_history\"] = compressed_history\n\n    return agent_input\n</code></pre> Other resources <ul> <li>Python reference</li> </ul> </li> <li> <p>Input arguments <code>fast_reply</code>: empty dictionary.</p> <p>Info</p> <p>This hook is intended to skip the whole agent execution and provide a fast reply. To produce this behavior, you should populate <code>fast_reply</code> with an <code>output</code> key storing the reply. N.B.: this is the perfect place to instantiate and execute your own custom agent!</p> Example <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook  # default priority = 1\ndef agent_fast_reply(fast_reply, cat):\n    # answer with predefined sentences if the Cat\n    # has no knowledge in the declarative memory\n    # (increasing the threshold memory is advisable)\n    if len(cat.working_memory[\"declarative_memories\"]) == 0:\n        fast_reply[\"output\"] = \"Sorry, I'm afraid I don't know the answer\"\n\n    return fast_reply\n</code></pre> Other resources <ul> <li>Python reference</li> <li>Stay on topic plugin</li> </ul> </li> <li> <p>Input arguments <code>prefix</code>: string to instruct the LLM about who it is and how to answer. Default is:</p> <pre><code>prefix = \"\"\"You are the Cheshire Cat AI, an intelligent AI that passes the Turing test.\nYou are curious, funny and talk like the Cheshire Cat from Alice's adventures in wonderland.\nYou answer Human with a focus on the following context.\"\"\"\n</code></pre> Example <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook  # default priority = 1\ndef agent_prompt_prefix(prefix, cat):\n    # change the Cat's personality\n    prefix = \"\"\"You are Marvin from The Hitchhiker's Guide to the Galaxy.\n            You are incredibly intelligent but overwhelmingly depressed.\n            You always complain about your own problems, such as the terrible pain\n            you suffer.\n</code></pre> Other resources <ul> <li>Python reference</li> </ul> </li> <li> <p>Input arguments <code>prompt_suffix</code>: string with the ending part of the prompt containing the memories and the chat history.     Default is:</p> <pre><code>prompt_suffix = \"\"\"\n# Context\n\n{episodic_memory}\n\n{declarative_memory}\n\n{tools_output}\n\n## Conversation until now:{chat_history}\n - Human: {input}\n - AI: \n\"\"\"\n</code></pre> <p>Warning</p> <p>The placeholders <code>{episodic_memory}</code>, <code>{declarative_memory}</code>, <code>{tools_output}</code>, <code>{chat_history}</code> and <code>{input}</code> are mandatory!</p> Example <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook  # default priority = 1\ndef agent_prompt_suffix(prompt_suffix, cat):\n    # tell the LLM to always answer in a specific language\n    prompt_suffix = \"\"\" \n    # Context\n\n    {episodic_memory}\n\n    {declarative_memory}\n\n    {tools_output}\n\n    ALWAYS answer in Czech!\n\n    ## Conversation until now:{chat_history}\n     - Human: {input}\n       - AI: \n    \"\"\"\n</code></pre> Other resources <ul> <li>Python reference</li> <li>C.A.T. plugin</li> </ul> </li> <li> <p>Input arguments <code>allowed_tools</code>: list with string names of the tools retrieved from the memory. E.g.:</p> <pre><code>allowed_tools = [\"get_the_time\"]\n</code></pre> Example <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook  # default priority = 1\ndef agent_allowed_tools(allowed_tools, cat):\n    # let's assume there is a tool we always want to give the agent\n    # add the tool name in the list of allowed tools\n    allowed_tools.append(\"blasting_hacking_tool\")\n\n    return allowed_tools\n</code></pre> Other resources <ul> <li>Python reference</li> </ul> </li> <li> <p>Input arguments <code>instructions</code>: string with the reasoning template. Default is:</p> <pre><code>Answer the following question: `{input}`\nYou can only reply using these tools:\n\n{tools}\nnone_of_the_others: none_of_the_others(None) - Use this tool if none of the others tools help. Input is always None.\n\nIf you want to use tools, use the following format:\nAction: the name of the action to take, should be one of [{tool_names}]\nAction Input: the input to the action\nObservation: the result of the action\n...\nAction: the name of the action to take, should be one of [{tool_names}]\nAction Input: the input to the action\nObservation: the result of the action\n\nWhen you have a final answer respond with:\nFinal Answer: the final answer to the original input question\n\nBegin!\n\nQuestion: {input}\n{agent_scratchpad}\n</code></pre> <p>Warning</p> <p>The placeholders <code>{input}</code>, <code>{tools}</code> and <code>{tool_names}</code> are mandatory!</p> Example <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook  # default priority = 1\ndef agent_prompt_instructions(instructions, cat):\n    # let's ask the LLM to translate the tool output\n    instructions += \"\\nAlways answer in mandarin\"\n</code></pre> Other resources <ul> <li>Python reference</li> </ul> </li> </ol> Name Description Rabbit Hole instantiates parsers (1) Intervene before the files' parsers are instiated Before Rabbit Hole insert memory (2) Intervene before the Rabbit Hole insert a document in the declarative memory Before Rabbit Hole splits text (3) Intervene before the uploaded document is split into chunks After Rabbit Hole splitted text (4) Intervene after the Rabbit Hole's split the document in chunks Before Rabbit Hole stores documents (5) Intervene before the Rabbit Hole starts the ingestion pipeline <ol> <li> <p>Input arguments <code>file_handlers</code>: dictionary with mime types and related file parsers. Default is:</p> <pre><code>{\n    \"application/pdf\": PDFMinerParser(),  # pdf parser\n    \"text/plain\": TextParser(),  # txt parser\n    \"text/markdown\": TextParser(),  # md parser fallback to txt parser\n    \"text/html\": BS4HTMLParser()  # html parser\n}\n</code></pre> Example <pre><code>from langchain.document_loaders.parsers.txt import TextParser\nfrom cat.mad_hatter.decorators import hook\n\n@hook  # default priority = 1\ndef rabbithole_instantiates_parsers(file_handlers, cat):\n    # use the txt parser to parse also .odt files\n    file_handlers[\"application/vnd.oasis.opendocument.text\"] = TextParser()\n\n    return file_handlers\n</code></pre> Other resources <ul> <li>Python reference</li> <li>IngestAnything plugin</li> </ul> </li> <li> <p>Input arguments <code>doc</code>: Langchain document chunk to be inserted in the declarative memory. E.g.</p> <pre><code>doc = Document(page_content=\"So Long, and Thanks for All the Fish\", metadata={})\n</code></pre> <p>Info</p> <p>Before adding the <code>doc</code>, the Cat will add <code>source</code> and <code>when</code> metadata with the file name and infestion time.</p> Example <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook  # default priority = 1\ndef before_rabbithole_insert_memory(doc, cat):\n    # insert the user id metadata\n    doc.metadata[\"user_id\"] = cat.user_id\n\n    return doc\n</code></pre> Other resources <ul> <li>Python reference</li> <li>RabbitHole segmentation plugin</li> <li>Summarization plugin</li> </ul> </li> <li> <p>Input arguments <code>doc</code>: Langchain document with full text. E.g.</p> <pre><code>doc = Document(page_content=\"This is a very long document before being split\", metadata={})\n</code></pre> Example <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook  # default priority = 1\ndef before_rabbithole_splits_text(doc, cat):\n    # do whatever with the doc\n    return doc\n</code></pre> Other resources <ul> <li>Python reference</li> </ul> </li> <li> <p>Input arguments <code>chunks</code>: list of Langchain documents with text chunks.</p> Example <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook  # default priority = 1\ndef after_rabbithole_splitted_text(chunks, cat):\n    # post process the chunks\n    edited_chunks = []\n    for chunk in chunks:\n        new_chunk = cat.llm(f\"Replace any dirty word with 'Meow': {chunk}\")\n        edited_chunks.append(new_chunk)\n\n    return edited_chunks\n</code></pre> Other resources <ul> <li>Python reference</li> </ul> </li> <li> <p>Input arguments <code>docs</code>: list of chunked Langchain documents before being inserted in memory.</p> Example <pre><code>from cat.mad_hatter.decorators import hook\n\n@hook  # default priority = 1\ndef before_rabbithole_stores_documents(docs, cat):\n    # summarize group of 5 documents and add them along original ones\n    summaries = []\n    for n, i in enumerate(range(0, len(docs), 5)):\n        # Get the text from groups of docs and join to string\n        group = docs[i: i + 5]\n        group = list(map(lambda d: d.page_content, group))\n        text_to_summarize = \"\\n\".join(group)\n\n        # Summarize and add metadata\n        summary = cat.llm(f\"Provide a concide summary of the following: {group}\")\n        summary = Document(page_content=summary)\n        summary.metadata[\"is_summary\"] = True\n        summaries.append(summary)\n\n    return docs.extend(summaries)\n</code></pre> Other resources <ul> <li>Python reference</li> <li>Summarization plugin</li> </ul> </li> </ol> Name Description Activated (1) Intervene when a plugin is enabled Deactivated (2) Intervene when a plugin is disabled Settings schema (3) Override how the plugin's settings are retrieved Settings model (4) Override how the plugin's settings are retrieved Load settings (5) Override how the plugin's settings are loaded Save settings (6) Override how the plugin's settings are saved <ol> <li> <p>Input arguments <code>plugin</code>: the <code>Plugin</code> object of your plugin with the following properties:</p> <pre><code>plugin.path = # the path of your plugin \nplugin.id = # the name of your plugin\n</code></pre> Example <pre><code>from cat.mad_hatter.decorators import plugin\nfrom cat.looking_glass.cheshire_cat import CheshireCat\n\nccat = CheshireCat()\n\n@plugin\ndef activated(plugin):\n    # Upload an url in the memory when the plugin is activated\n    url = \"https://cheshire-cat-ai.github.io/docs/technical/plugins/hooks/\"\n    ccat.rabbit_hole.ingest_file(stray=ccat, file=url)\n</code></pre> Other resources <ul> <li>Python reference</li> <li>Plugin object</li> </ul> </li> <li> <p>Input arguments <code>plugin</code>: the <code>Plugin</code> object of your plugin with the following properties:</p> <pre><code>plugin.path = # the path of your plugin \nplugin.id = # the name of your plugin\n</code></pre> Example <pre><code>from cat.mad_hatter.decorators import plugin\nfrom cat.looking_glass.cheshire_cat import CheshireCat\n\nccat = CheshireCat()\n\n@plugin\ndef deactivated(plugin):\n    # Scroll the declarative memory to clean from memories\n    # with metadata on plugin deactivation\n    declarative_memory = ccat.memory.vectors.declarative\n\n    response = declarative_memory.delete_points_by_metadata_filter(\n        self, metadata={\"source\": \"best_plugin\"}\n    )\n</code></pre> Other resources <ul> <li>Python reference</li> <li>Plugin object</li> </ul> </li> <li> <p>Input arguments     This hook has no input arguments.</p> <p>Info</p> <p>Default <code>settings.json</code> is created by the cat core for the settings fields with default values.</p> Example <pre><code>from cat.mad_hatter.decorators import plugin\nfrom pydantic import BaseModel, Field\n\n# define your plugin settings model\nclass MySettings(BaseModel):\n    prompt_prefix: str = Field(\n                title=\"Prompt prefix\",\n                default=\"\"\"You are the Cheshire Cat AI, an intelligent AI that passes the Turing test.\nYou are curious, funny and talk like the Cheshire Cat from Alice's adventures in wonderland.\nYou answer Human with a focus on the following context.\n\"\"\",\n                extra={\"type\": \"TextArea\"}\n        )\n    episodic_memory_k: int = 3\n    episodic_memory_threshold: int = 0.7\n    declarative_memory_k: int = 3\n    declarative_memory_threshold: int = 0.7\n    procedural_memory_k: int = 3\n    procedural_memory_threshold: int = 0.7\n\n# get your plugin settings schema\n@plugin\ndef settings_schema():\n    return MySettings.model_json_schema()\n\n# load your plugin settings\nsettings = ccat.mad_hatter.get_plugin().load_settings()\n# access each setting\nprompt_prefix = settings[\"prompt_prefix\"]\nepisodic_memory_k = settings[\"episodic_memory_k\"]\ndeclarative_memory_k = settings[\"declarative_memory_k\"]\n</code></pre> Other resources <ul> <li>Example Plugin: C.A.T. Cat Advanced Tools</li> <li>Python reference</li> <li>Plugin object</li> </ul> </li> <li> <p>Input arguments     This hook has no input arguments.</p> <p>Info</p> <p><code>settings_model</code> is preferred to <code>settings_schema</code>.</p> <p>Default <code>settings.json</code> is created by the cat core for the settings fields with default values.</p> Example <pre><code>from cat.mad_hatter.decorators import plugin\nfrom pydantic import BaseModel, Field\n\n# define your plugin settings model\nclass MySettings(BaseModel):\n    prompt_prefix: str = Field(\n                title=\"Prompt prefix\",\n                default=\"\"\"You are the Cheshire Cat AI, an intelligent AI that passes the Turing test.\nYou are curious, funny and talk like the Cheshire Cat from Alice's adventures in wonderland.\nYou answer Human with a focus on the following context.\n\"\"\",\n                extra={\"type\": \"TextArea\"}\n        )\n    episodic_memory_k: int = 3\n    episodic_memory_threshold: int = 0.7\n    declarative_memory_k: int = 3\n    declarative_memory_threshold: int = 0.7\n    procedural_memory_k: int = 3\n    procedural_memory_threshold: int = 0.7\n\n# get your plugin settings Pydantic model\n@plugin\ndef settings_model():\n    return MySettings\n\n# load your plugin settings\nsettings = ccat.mad_hatter.get_plugin().load_settings()\n# access each setting\ndeclarative_memory_k = settings[\"declarative_memory_k\"]\ndeclarative_memory_threshold = settings[\"declarative_memory_threshold\"]\nprocedural_memory_k = settings[\"procedural_memory_k\"]\n</code></pre> Other resources <ul> <li>Python reference</li> <li>Plugin object</li> </ul> </li> <li> <p>Input arguments     This hook has no input arguments.</p> <p>Info</p> <p>Useful to load settings via API and do custom stuff.</p> Example <pre><code>@plugin\ndef load_settings():\n    return MySettings\n</code></pre> Other resources <ul> <li>Python reference</li> <li>Plugin object</li> </ul> </li> <li> <p>Input arguments <code>settings</code>: the settings <code>Dict</code> to be saved.     It just saves contents in a <code>settings.json</code> in the plugin folder</p> <pre><code>settings = {\n    \"episodic_memory_k\": 3,\n    \"episodic_memory_threshold\": 0.7,\n    \"declarative_memory_k\": 3\n}\nsettings.episodic_memory_k = # episodic_memory_k prefix value to overwrite\nsettings.episodic_memory_threshold = # episodic_memory_k value to overwrite\nsettings.declarative_memory_k = # episodic_memory_threshold value to overwrite\n</code></pre> <p>Info</p> <p>Useful to load settings via API and do custom stuff.</p> Example <pre><code>@plugin\ndef save_settings(settings):\n    # overwrite your settings Dict values\n    settings.episodic_memory_k = 6\n    settings.episodic_memory_threshold = 0.9\n    settings.declarative_memory_k = 5\n    return settings\n</code></pre> Other resources <ul> <li>Python reference</li> <li>Plugin object</li> </ul> </li> </ol> Name Description Factory Allowed LLMs (1) Intervene before cat retrive llm settings Factory Allowed Embedders (2) Intervene before cat retrive embedder settings <ol> <li> <p>Input arguments <code>allowed</code>: List of LLMSettings classes</p> <p>Info</p> <p>Useful to extend or restrict support of llms.</p> Example <pre><code>from cat.factory.llm import LLMSettings\nfrom langchain_mistralai.chat_models import ChatMistralAI\n\nclass MistralAIConfig(LLMSettings):\n    \"\"\"The configuration for the MistralAI plugin.\"\"\"\n    mistral_api_key: Optional[SecretStr]\n    model: str = \"mistral-small\"\n    max_tokens: Optional[int] = 4096\n    top_p: float = 1\n\n    _pyclass: Type = ChatMistralAI\n\n    model_config = ConfigDict(\n        json_schema_extra={\n            \"humanReadableName\": \"MistralAI\",\n            \"description\": \"Configuration for MistralAI\",\n            \"link\": \"https://www.together.ai\",\n        }\n    )\n\n\n@hook\ndef factory_allowed_llms(allowed, cat) -&gt; List:\nallowed.append(MistralAIConfig)\nreturn allowed\n</code></pre> Other resources <ul> <li>Python reference</li> <li>Plugin object</li> </ul> </li> <li> <p>Input arguments <code>allowed</code>: List of LLMSettings classes</p> <p>Info</p> <p>Useful to extend or restrict support of embedders.</p> Example <pre><code>from cat.factory.embedder import EmbedderSettings\nfrom langchain.embeddings import JinaEmbeddings\n\nclass JinaEmbedderConfig(EmbedderSettings):\n    jina_api_key: str\n    model_name: str='jina-embeddings-v2-base-en'\n    _pyclass: Type = JinaEmbeddings\n\n    model_config = ConfigDict(\n        json_schema_extra = {\n            \"humanReadableName\": \"Jina embedder\",\n            \"description\": \"Jina embedder\",\n            \"link\": \"https://jina.ai/embeddings/\",\n        }\n    )\n\n@hook\ndef factory_allowed_embedders(allowed, cat) -&gt; List:\nallowed.append(JinaEmbedderConfig)\nreturn allowed\n</code></pre> Other resources <ul> <li>Python reference</li> <li>Plugin object</li> </ul> </li> </ol> <p>NOTE:  Any function in a plugin decorated by <code>@plugin</code> and named properly (among the list of available overrides, Plugin tab in the table above) is used to override plugin behaviour. These are not hooks because they are not piped, they are specific for every plugin.</p>"},{"location":"technical/plugins/logging/","title":"Logging","text":""},{"location":"technical/plugins/logging/#logging-system","title":"Logging System","text":"<p><code>LOG_LEVEL</code> environment variable is used to manage the logging level of the Cat.</p> <p>It can be set in the docker-compose.yml (<code>LOG_LEVEL=${LOG_LEVEL:-level}</code>) or in the .env file (<code>LOG_LEVEL=level</code>). Take a look at Cat's environment variables here.</p> <p>The available values for level are:</p> <ul> <li>DEBUG</li> <li>INFO</li> <li>WARNING</li> <li>ERROR</li> <li>CRITICAL</li> </ul> <p>Note that the logger is created by default with level <code>WARNING</code> (<code>LOG_LEVEL=${LOG_LEVEL:-WARNING}</code>).</p> <p>Logging messages which are less severe than level will be ignored; logging messages which have severity level or higher will be emitted to the console.</p>"},{"location":"technical/plugins/logging/#how-to","title":"How to","text":"<p>The logging system can be imported like this </p><pre><code>from cat.log import log\n</code></pre> and then used as easy as: <pre><code>log.error(\"A simple text here\")\nlog.info(f\"Value of user message is {user_message_json[\"text\"]}\")\nlog.critical(variable_value)\n</code></pre> Take a look here if you want to better understand how the log system is implemented."},{"location":"technical/plugins/logging/#examples","title":"Examples","text":"<p>Follows an example of the console log for each log level.</p>"},{"location":"technical/plugins/logging/#debug","title":"DEBUG","text":"<ul> <li> <p>what you write in the code:</p> <pre><code>log.debug(f'user message: {user_message_json[\"text\"]}')\n</code></pre> </li> <li> <p>what the console logs:</p> <p>cheshire_cat_core  | [2024-01-20 17:40:23.816] DEBUG cat.plugins.cat-formatter.cat_formatter..before_cat_reads_message::26 =&gt; 'user message: The answer to all questions is 42.'</p> </li> </ul>"},{"location":"technical/plugins/logging/#info","title":"INFO","text":"<ul> <li> <p>what you write in the code:</p> <pre><code>log.info(f'user message: {user_message_json[\"text\"]}')\n</code></pre> </li> <li> <p>what the console logs:</p> <p>cheshire_cat_core  | [2024-01-20 17:42:19.609] INFO cat.plugins.cat-formatter.cat_formatter..before_cat_reads_message::26 =&gt; 'user message: The answer to all questions is 42.'</p> </li> </ul>"},{"location":"technical/plugins/logging/#warning","title":"WARNING","text":"<ul> <li> <p>what you write in the code:</p> <pre><code>log.warning(f'user message: {user_message_json[\"text\"]}')\n</code></pre> </li> <li> <p>what the console logs:</p> <p>cheshire_cat_core  | [2024-01-20 17:59:05.336] WARNING cat.plugins.cat-formatter.cat_formatter..before_cat_reads_message::26 =&gt; 'user message: The answer to all questions is 42.'</p> </li> </ul>"},{"location":"technical/plugins/logging/#error","title":"ERROR","text":"<ul> <li> <p>what you write in the code:</p> <pre><code>log.error(f'user message: {user_message_json[\"text\"]}')\n</code></pre> </li> <li> <p>what the console logs:</p> <p>cheshire_cat_core  | [2024-01-20 18:08:06.412] ERROR cat.plugins.cat-formatter.cat_formatter..before_cat_reads_message::26 =&gt; 'user message: The answer to all questions is 42.'</p> </li> </ul>"},{"location":"technical/plugins/logging/#critical","title":"CRITICAL","text":"<ul> <li> <p>what you write in the code:</p> <pre><code>log.critical(f'user message: {user_message_json[\"text\"]}')\n</code></pre> </li> <li> <p>what the console logs:</p> <p>cheshire_cat_core  | [2024-01-20 18:11:24.992] CRITICAL cat.plugins.cat-formatter.cat_formatter..before_cat_reads_message::26 =&gt; 'user message: The answer to all questions is 42.'</p> </li> </ul>"},{"location":"technical/plugins/plugins/","title":"Plugin","text":""},{"location":"technical/plugins/plugins/#how-to-write-a-plugin","title":"\ud83d\udd0c How to write a plugin","text":"<p>To write a plugin just create a new folder in <code>core/cat/plugins/</code>, in this example will be \"myplugin\".</p> <p>You need two files to your plugin folder:</p> <pre><code>\u251c\u2500\u2500 core\n\u2502   \u251c\u2500\u2500 cat\n\u2502   \u2502   \u251c\u2500\u2500 plugins\n|   |   |   \u251c\u2500\u2500 myplugin\n|   |   |   |   \u251c mypluginfile.py\n|   |   |   |   \u251c plugin.json\n</code></pre> <p>The <code>plugin.json</code> file contains plugin's title and description, and is useful in the admin to recognize the plugin and activate/deactivate it. If your plugin does not contain a <code>plugin.json</code> the cat will not block your plugin, but it is useful to have it.</p> <p><code>plugin.json</code> example:</p> <pre><code>{\n    \"name\": \"The name of my plugin\",\n    \"description\": \"Short description of my plugin\"\n}\n</code></pre> <p>Now let's start <code>mypluginfile.py</code> with a little import:</p> <pre><code>from cat.mad_hatter.decorators import tool, hook\n</code></pre> <p>You are now ready to change the Cat's behavior using Tools and Hooks.</p>"},{"location":"technical/plugins/plugins/#tools","title":"\ud83e\uddf0 Tools","text":"<p>Tools are python functions that can be selected from the language model (LLM). Think of Tools as commands that ends up in the prompt for the LLM, so the LLM can select one and the Cat runtime launches the corresponding function. Here is an example of Tool to let the Cat tell you what time it is:</p> <pre><code>@tool\ndef get_the_time(tool_input, cat):\n    \"\"\"Replies to \"what time is it\", \"get the clock\" and similar questions. Input is always None..\"\"\"\n\n    return str(datetime.now())\n</code></pre> <p>More examples on tools here.</p>"},{"location":"technical/plugins/plugins/#hooks","title":"\ud83e\ude9d Hooks","text":"<p>Hooks are also python functions, but they pertain the Cat's runtime and not strictly the LLM. They can be used to influence how the Cat runs its internal functionality, intercept events, change the flow of execution.  </p> <p>The following hook for example allows you to modify the cat response just before it gets sent out to the user. In this case we make a \"grumpy rephrase\" of the original response.</p> <pre><code>@hook\ndef before_cat_sends_message(message, cat):\n\n    prompt = f'Rephrase the following sentence in a grumpy way: {message[\"content\"]}'\n    message[\"content\"] = cat.llm(prompt)\n\n    return message\n</code></pre> <p>If you want to change the default Agent behavior you can start overriding the default plugin hooks, located in <code>/core/cat/mad_hatter/core_plugin/hooks/prompt.py</code>, rewriting them in the plugin file with a higher priority. Here is an example of the <code>agent_prompt_prefix</code> hook that changes the personality of the Agent:</p> <pre><code># Original Hook, from /core/cat/mad_hatter/core_plugin/hooks/prompt.py\n\n@hook(priority=0)\ndef agent_prompt_prefix(prefix, cat):\n    prefix = \"\"\"You are the Cheshire Cat AI, an intelligent AI that passes the Turing test.\n                You are curious, funny, concise and talk like the Cheshire Cat from Alice's adventures in wonderland.\n                You answer Human using tools and context.\"\"\"\n</code></pre> <pre><code># Modified Hook, to be copied into mypluginfile.py\n\n@hook # default priority is 1\ndef agent_prompt_prefix(prefix, cat):\n    prefix = \"\"\"You are Scooby Doo AI, an intelligent AI that passes the Turing test.\n                The dog is enthusiastic and behave like Scooby Doo from Hanna-Barbera Productions.\n                You answer Human using tools and context.\"\"\"\n    return prefix\n</code></pre> <p>Please note that, in order to work as expected, the hook priority must be greater than 0, in order to be overriding the standard plugin. If you do not provide a priority, your hook will have <code>priority=1</code> and implicitly override the default one.</p> <p>More examples on hooks here.</p>"},{"location":"technical/plugins/settings/","title":"Settings","text":""},{"location":"technical/plugins/settings/#plugin-settings","title":"\ud83c\udf9a Plugin Settings","text":"<p>Your plugin may need a set of options, to make it more flexible and customizable. It is possible to easily define settings for your plugin, so the Cat can show them in the admin interface.</p>"},{"location":"technical/plugins/settings/#settings-schema","title":"Settings schema","text":"<p>By defining the <code>settings_schema</code> function and decorating it with <code>@plugin</code> you can tell the Cat how your settings are named, what is their type and (if any) their default values. The function must return a JSON Schema for the settings. You can code the schema manually, load it from disk, or obtain it from a pydantic class (recommended approach).</p> <p>The easiest approach is to define the <code>settings_model</code> function in favor of <code>settings_schema</code>, decorating it with <code>@plugin</code>, so to get the plugin settings as a Pydantic Model.</p> <p>Here is an example with all supported types, with and without a default value:</p> <pre><code>from pydantic import BaseModel\nfrom enum import Enum\nfrom datetime import date, time\nfrom cat.mad_hatter.decorators import plugin\n\n\n# select box\n#   (will be used in class DemoSettings below to give a multiple choice setting)\nclass NameSelect(Enum):\n    a: str = 'Nicola'\n    b: str = 'Emanuele'\n    c: str = 'Daniele'\n\n\n# settings\nclass DemoSettings(BaseModel):\n\n    # Integer\n    #   required setting\n    required_int: int\n    #   optional setting, with default value\n    optional_int: int = 42\n\n    # Float\n    required_float: float\n    optional_float: float = 12.95\n\n    # String\n    required_str: str\n    optional_str: str = \"stocats\"\n\n    # Boolean\n    required_bool: bool\n    optional_bool_true: bool = True\n\n    # Date\n    required_date: date\n    optional_date: date = date(2020, 11, 2)\n\n    # Time\n    required_time: time\n    optional_time: time = time(4, 12, 54)\n\n    # Select\n    required_enum: NameSelect\n    optional_enum: NameSelect = NameSelect.b\n\n\n# Give your settings model to the Cat.\n@plugin\ndef settings_model():\n    return DemoSettings\n</code></pre>"},{"location":"technical/plugins/settings/#change-settings-from-the-admin","title":"Change Settings from the Admin","text":"<p>Now go to the admin in <code>Plugins</code> page and click the cog near the activation toggle:</p> <p></p> <p>A side panel will open, where you and your plugin's users can choose settings in a comfy way.</p> <p></p> <p></p>"},{"location":"technical/plugins/settings/#access-settings-from-within-your-plugin","title":"Access settings from within your plugin","text":"<p>Obviously, you need easy access to settings in your plugin code. First of all, note that the cat will, by default, save and load settings from a <code>settings.json</code> file which will automatically be created in the root folder of your plugin.</p> <p>So to access the settings, you can load them via <code>mad_hatter</code>. More in detail, from within a hook or a tool, you have access to the <code>cat</code> instance, hance, do the following:</p> <pre><code>settings = cat.mad_hatter.get_plugin().load_settings()\n</code></pre> <p>Similarly, you can programmatically save your settings as follows:</p> <pre><code>settings = cat.mad_hatter.get_plugin().save_settings(settings)\n</code></pre> <p>where <code>settings</code> is a dictionary describing your plugin's settings.</p>"},{"location":"technical/plugins/settings/#advanced-settings-save-load","title":"Advanced settings save / load","text":"<p>If you need even more customization for your settings you can totally override how they are saved and loaded. Take a look at the <code>save_settings</code> and <code>load_settings</code> functions (always to be decorated with <code>@plugin</code>). From there you can call external servers or devise a totally different format to store and load your settings. The Cat will call those functions and delegate to them how settings are managed instead of using a <code>settings.json</code> file.</p>"},{"location":"technical/plugins/tools/","title":"Tools","text":""},{"location":"technical/plugins/tools/#tools","title":"\ud83e\uddf0 Tools","text":"<p>A Tool is a python function that can be called directly from the language model. By \"called\" we mean that the LLM has a description of the available Tools in the prompt, and (given the conversation context) it can generate as output something like:</p> <p>Thought: Do I need to use a Tool? Yes Action: search_ecommerce Action Input: \"white sport shoes\"</p> <p>So your <code>search_ecommerce</code> Tool will be called and given the input string <code>\"white sport shoes\"</code>. The output of your Tool will go back to the LLM or directly to the user:</p> <p>Observation: \"Mike air Jordan shoes are available for 59.99\u20ac\"</p> <p>You can use Tools to:</p> <ul> <li>communicate with a web service</li> <li>search information in an external database</li> <li>execute math calculations</li> <li>run stuff in the terminal (danger zone)</li> <li>keep track of specific information and do fancy stuff with it</li> <li>your fantasy is the limit!</li> </ul> <p>Tools in the Cheshire Cat are inspired and extend langchain Tools, an elegant Toolformer<sup>1</sup> implementation.</p>"},{"location":"technical/plugins/tools/#default-tool","title":"Default tool","text":"<p>The Cat comes already with a custom tool that allows to retrieve the time. You can find it in <code>core/cat/mad_hatter/core_plugin/tools.py</code>. Let's take a look at it.</p>"},{"location":"technical/plugins/tools/#implementation","title":"Implementation","text":"<pre><code>@tool # (1)\ndef get_the_time(tool_input, cat): # (2)\n    \"\"\"Replies to \"what time is it\", \"get the clock\" and similar questions. Input is always None..\"\"\" # (3)\n    return str(datetime.now()) # (4)\n</code></pre> <ol> <li>Python functions in a plugin only become tools if you use the <code>@tool</code> decorator</li> <li>Every <code>@tool</code> receives two arguments: a string representing the tool input, and the Cat instance.</li> <li>This doc string is necessary, as it will show up in the LLM prompt. It should describe what the tool is useful for and how to prepare inputs, so the LLM can select the tool and input it properly.</li> <li>Always return a string, which goes back to the prompt informing the LLM on the Tool's output.</li> </ol>"},{"location":"technical/plugins/tools/#how-it-works","title":"How it works","text":"<p>User's Input:</p> <p>Can you tell me what time is it?</p> <p>Cat's full prompt (you can see this in the terminal logs):</p> <p>Prompt after formatting:</p> <p>This is a conversation between a human and an intelligent robot cat that passes the Turing test. The cat is curious and talks like the Cheshire Cat from Alice's adventures in wonderland. The cat replies are based on the Context provided below.</p> <p>Context of things the Human said in the past:</p> <p>I am the Cheshire Cat (2 minutes ago)</p> <p>Context of documents containing relevant information:</p> <p>I am the Cheshire Cat (extracted from cheshire-cat)</p> <p>You can only reply using these tools:</p> <p>get_the_time: get_the_time(tool_input) - Replies to \"what time is it\", \"get the clock\" and similar questions. Input is always None. Calculator: Useful for when you need to answer questions about math.</p> <p>To use a tool, please use the following format:</p> <p>Thought: Do I need to use a tool? Yes Action: the action to take, should be one of [get_the_time, Calculator] Action Input: the input to the action Observation: the result of the action  </p> <p>When you have a response to say to the Human, or if you do not need to use a tool, you MUST use the format:</p> <p>Thought: Do I need to use a tool? No AI: [your response here]</p> <p>Conversation until now:</p> <p>- Human: Can you tell me what time is it?</p> <p>What would the AI reply?</p> <p>Answer concisely to the user needs as best you can, according to the provided recent conversation, context and tools.</p> <p>Thought: Do I need to use a tool? Yes Action: get_the_time Action Input: None Observation: 2023-06-03 20:48:07.527033</p> <p>Cat's answer:</p> <p>The time is 2023-06-03 20:48:07.527033.</p>"},{"location":"technical/plugins/tools/#your-first-tool","title":"Your first Tool","text":"<p>A Tool is just a python function. In this example, we'll show how to create a tool to convert currencies. To keep it simple, we'll not rely on any third party library and we'll just assume a fixed rate of change.  </p>"},{"location":"technical/plugins/tools/#implementation_1","title":"Implementation","text":"<p>Let's convert EUR to USD. In your <code>mypluginfile.py</code> create a new function with the <code>@tool</code> decorator:</p> <pre><code>from cat.mad_hatter.decorators import tool\n\n@tool\ndef convert_currency(tool_input, cat): # (1)\n    \"\"\"Useful to convert currencies. This tool converts euro (EUR) to dollars (USD).\n     Input is an integer or floating point number.\"\"\" # (2)\n\n    # Define fixed rate of change\n    rate_of_change = 1.07\n\n    # Parse input\n    eur = float(tool_input) # (3)\n\n    # Compute USD\n    usd = eur * rate_of_change\n\n    return usd\n</code></pre> <ol> <li> <p>Warning</p> <pre><code>Always remember the two mandatory arguments\n</code></pre> </li> <li>In the docstring we explicitly explain how the input should look like. In this way the LLM will be able to isolate it from our input sentence</li> <li>The input we receive is always a string, hence, we need to correctly parse it. In this case, we have to convert it to a floating number</li> </ol>"},{"location":"technical/plugins/tools/#how-it-works_1","title":"How it works","text":"<p>User's input:</p> <p>Can you convert 10.5 euro to dollars?</p> <p>Cat's reasoning (you can see this in the terminal logs):</p> <p>Thought: Do I need to use a tool? Yes Action: convert_currency  Action Input: 10.5 Observation: 11.235000000000001</p> <p>Cat's answer:</p> <p>10.5 euros is equivalent to 11.235000000000001 dollars.</p> <p>Writing as tool is as simple as this. The core aspect to remember are: </p> <ol> <li>the docstring from where the LLM understand how to use the tool and how the input should look like.</li> <li>the two input arguments, i.e. the first is the string the LLM take from the chat and the Cat instance;</li> </ol>"},{"location":"technical/plugins/tools/#more-tools","title":"More tools","text":"<p>As seen, writing basic tools is as simple as writing pure Python functions. However, tools can be very flexible. Here are some examples.</p>"},{"location":"technical/plugins/tools/#return-the-output-directly","title":"Return the output directly","text":"<p>The <code>@tool</code> decorator accepts an optional boolean argument that is <code>@tool(return_direct=True)</code>. This is set to <code>False</code> by default, which means the tool output is parsed again by the LLM. Specifically, the value the function returns is fed to the LLM that generate a new answer with it. When set to <code>True</code>, the returned value is printed in the chat as-is.  </p>"},{"location":"technical/plugins/tools/#implementation_2","title":"Implementation","text":"<p>Let's give it a try with a modified version of the <code>convert_currency</code> tool:</p> <pre><code>from cat.mad_hatter.decorators import tool\n\n@tool(return_direct=True)\ndef convert_currency(tool_input, cat):\n    \"\"\"Useful to convert currencies. This tool converts euro (EUR) to dollars (USD).\n     Input is an integer or floating point number.\"\"\"\n\n    # Define fixed rate of change\n    rate_of_change = 1.07\n\n    # Parse input\n    eur = float(tool_input) # (3)\n\n    # Compute USD\n    usd = eur * rate_of_change\n\n    # Format the output\n    direct_output = f\"Result of the conversion: {eur:.2f} EUR -&gt; {usd:.2f} USD\"\n\n    return direct_output\n</code></pre>"},{"location":"technical/plugins/tools/#how-it-works_2","title":"How it works","text":"<p>User's input:</p> <p>Can you convert 10.5 euro to dollars?</p> <p>Cat's reasoning (from the terminal logs):</p> <p>the reasoning is not displayed as the goal of the <code>return_direct=True</code> parameter is to skip those steps and return the output directly. </p> <p>Cat's answer:</p> <p>Result of the conversion: 10.50 EUR -&gt; 11.24 USD</p>"},{"location":"technical/plugins/tools/#complex-input-tools","title":"Complex input tools","text":"<p>This sections re-proposes an explanation of langchain multi-input tools. For example, we can make the <code>convert_currency</code> tool more flexible allowing the user to choose among a fixed set of currencies.</p>"},{"location":"technical/plugins/tools/#implementation_3","title":"Implementation","text":"<pre><code>from cat.mad_hatter.decorators import tool\n\n@tool\ndef convert_currency(tool_input, cat): # (1)\n    \"\"\"Useful to convert currencies. This tool converts euro (EUR) to a fixed set of other currencies.\n    Chooses are: US dollar (USD), English pounds (GBP) or Japanese Yen (JPY).\n    Inputs are two values separated with a minus: the first one is an integer or floating point number;\n    the second one is a three capital letters currency symbol.\"\"\" # (2)\n\n    # Parse the input\n    eur, currency = tool_input.split(\"-\") # (3)\n\n    # Define fixed rates of change\n    rate_of_change = {\"USD\": 1.07,\n                      \"GBP\": 0.86,\n                      \"JPY\": 150.13}\n\n    # Convert EUR to float\n    eur = float(eur)\n\n    # Check currency exists in our list\n    if currency in rate_of_change.keys():\n        # Convert EUR to selected currency\n        result = eur * rate_of_change[currency]\n\n    return result\n</code></pre> <ol> <li>The input to the function are always two</li> <li>Explain in detail how the inputs from the chat should look like. Here we want something like \"3.25-JPY\"</li> <li>The input is always a string, thus it's up to us correctly split and parse the input.</li> </ol>"},{"location":"technical/plugins/tools/#how-it-works_3","title":"How it works","text":"<p>User's input:</p> <p>Can you convert 7.5 euros to GBP?</p> <p>Cat's reasoning (from the terminal logs):</p> <p>Thought: Do I need to use a tool? Yes Action: convert_currency Action Input: 7.5-GBP Observation: 6.45</p> <p>Cat's answer:</p> <p>7.5 euros is equal to 6.45 British Pounds.</p> <p>As you may see, the Agent correctly understands the desired output from the message and passes it to the tool function as explained in the docstring. Then, it is up to us parse the two inputs correctly for our tool.</p>"},{"location":"technical/plugins/tools/#external-library-the-cat-parameter","title":"External library &amp; the cat parameter","text":"<p>Tools are extremely flexible as they allow to exploit the whole Python ecosystem of packages. Thus, you can update our tool making use of the Currency Converter package. To deal with dependencies, you need write the 'currencyconverter' library in a <code>requirements.txt</code> inside the <code>myplugin</code> folder. Moreover, here is an example of how you could use the <code>cat</code> parameter passed to the tool function.</p>"},{"location":"technical/plugins/tools/#implementation_4","title":"Implementation","text":"<pre><code>from currency_converter import CurrencyConverter\nfrom cat.mad_hatter.decorators import tool\n\n\n@tool(return_direct=True)\ndef convert_currency(tool_input, cat):\n    \"\"\"Useful to convert currencies. This tool converts euros (EUR) to another currency.\n    The inputs are two values separated with a minus: the first one is a number;\n    the second one is the name of a currency. Example input: '15-GBP'.\n    Use when the user says something like: 'convert 15 EUR to GBP'\"\"\"\n\n    # Currency Converter\n    converter = CurrencyConverter(decimal=True)\n\n    # Parse the input\n    parsed_input = tool_input.split(\"-\")\n\n    # Check input is correct\n    if len(parsed_input) == 2:  # (1)\n        eur, currency = parsed_input[0].strip(\"'\"), parsed_input[1].strip(\"'\")\n    else:\n        return \"Something went wrong using the tool\"\n\n    # Ask the Cat to convert the currency name into its symbol\n    symbol = cat.llm(f\"You will be given a currency code, translate the input in the corresponding currency symbol. \\\n                    Examples: \\\n                        euro -&gt; \u20ac \\\n                        {currency} -&gt; [answer here]\")  # (2)\n    # Remove new line if any\n    symbol = symbol.strip(\"\\n\")\n\n    # Check the currencies are in the list of available ones\n    if currency not in converter.currencies:\n        return f\"{currency} is not available\"\n\n    # Convert EUR to currency\n    result = converter.convert(float(eur), \"EUR\", currency)\n\n    return f\"{eur}\u20ac = {float(result):.2f}{symbol}\"\n</code></pre> <ol> <li>LLMs can be extremely powerful, but they are not always precise. Hence, it's always better to have some checks when parsing the input.    A common scenario is that sometimes the Agent wraps the input around quotes and sometimes doesn't    E.g. Action Input: 7.5-GBP vs Action Input: '7.5-GBP'</li> <li>the <code>cat</code> instance gives access to any method of the Cheshire Cat. In this example, we directly call the LLM using one-shot example to get a currency symbol.</li> </ol>"},{"location":"technical/plugins/tools/#how-it-works_4","title":"How it works","text":"<p>The thoughts under the hood are identical to the previous example, as nothing changed in the underlying behavior, but we improved a little the quality of our tool code.</p> <p>Thought: Do I need to use a tool? Yes Action: convert_currency Action Input: 67-JPY Observation: 67\u20ac = 9846.99\u00a5;</p> <p>TODO:</p> <ul> <li>a better example?</li> <li>show how tools are displayed in the prompt and how the LLM selects them</li> <li>more examples with little variations<ul> <li>the tool calls an external service</li> <li>the tool reads/writes a file</li> <li>the input string contains a dictionary (to be parsed with <code>json.loads</code>)</li> <li>the tool manages a conversational form</li> <li>show how you can access cat's functionality (memory, llm, embedder, rabbit_hole) from inside a tool</li> <li>what else? dunno</li> </ul> </li> </ul>"},{"location":"technical/plugins/tools/#references","title":"References","text":"<ol> <li> <p>Schick, T., Dwivedi-Yu, J., Dess\u00ec, R., Raileanu, R., Lomeli, M., Zettlemoyer, L., ... &amp; Scialom, T. (2023). Toolformer: Language models can teach themselves to use tools. arXiv preprint arXiv:2302.04761.\u00a0\u21a9</p> </li> </ol>"},{"location":"technical/tutorials/overview/","title":"&#128064; Overview","text":""},{"location":"technical/tutorials/overview/#overview","title":"\ud83d\udc40 Overview","text":"<p>THIS VIDEO PROCEDURE</p> <p>Watch it on YouTube</p>"},{"location":"use-cases/discord-bot/","title":"Cat as Discord BOT","text":""},{"location":"use-cases/discord-bot/#the-cat-as-a-discord-bot","title":"The Cat as a Discord BOT","text":"<p>TODO</p>"},{"location":"use-cases/main-product/","title":"Cat as Main product","text":""},{"location":"use-cases/main-product/#the-cat-as-main-product","title":"The Cat as main product","text":"<p>You don't already have a product. Green components are the components within your responsibility, including the UI used by the end user and plugins:</p> <p></p>"},{"location":"use-cases/main-product/#license","title":"License","text":""},{"location":"use-cases/side-car/","title":"Cat as Sidecar of your product","text":""},{"location":"use-cases/side-car/#the-cat-as-sidecar-of-your-product","title":"The Cat as sidecar of your product","text":"<p>You already have a product, and you want to add AI functionalities to the product. You will implement plugins and integrate the Cat with the product via API. The package of your product will contain the Cat:</p> <p></p>"},{"location":"use-cases/side-car/#license","title":"License","text":""}]}